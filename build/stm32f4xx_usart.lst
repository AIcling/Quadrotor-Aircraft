ARM GAS  /tmp/cc9pQZm7.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"stm32f4xx_usart.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./Lib/Src/stm32f4xx_usart.c"
  20              		.section	.text.USART_DeInit,"ax",%progbits
  21              		.align	1
  22              		.global	USART_DeInit
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	USART_DeInit:
  28              	.LFB123:
   1:./Lib/Src/stm32f4xx_usart.c **** /**
   2:./Lib/Src/stm32f4xx_usart.c ****   ******************************************************************************
   3:./Lib/Src/stm32f4xx_usart.c ****   * @file    stm32f4xx_usart.c
   4:./Lib/Src/stm32f4xx_usart.c ****   * @author  MCD Application Team
   5:./Lib/Src/stm32f4xx_usart.c ****   * @version V1.8.1
   6:./Lib/Src/stm32f4xx_usart.c ****   * @date    27-January-2022
   7:./Lib/Src/stm32f4xx_usart.c ****   * @brief   This file provides firmware functions to manage the following 
   8:./Lib/Src/stm32f4xx_usart.c ****   *          functionalities of the Universal synchronous asynchronous receiver
   9:./Lib/Src/stm32f4xx_usart.c ****   *          transmitter (USART):           
  10:./Lib/Src/stm32f4xx_usart.c ****   *           + Initialization and Configuration
  11:./Lib/Src/stm32f4xx_usart.c ****   *           + Data transfers
  12:./Lib/Src/stm32f4xx_usart.c ****   *           + Multi-Processor Communication
  13:./Lib/Src/stm32f4xx_usart.c ****   *           + LIN mode
  14:./Lib/Src/stm32f4xx_usart.c ****   *           + Half-duplex mode
  15:./Lib/Src/stm32f4xx_usart.c ****   *           + Smartcard mode
  16:./Lib/Src/stm32f4xx_usart.c ****   *           + IrDA mode
  17:./Lib/Src/stm32f4xx_usart.c ****   *           + DMA transfers management
  18:./Lib/Src/stm32f4xx_usart.c ****   *           + Interrupts and flags management 
  19:./Lib/Src/stm32f4xx_usart.c ****   *           
  20:./Lib/Src/stm32f4xx_usart.c ****   @verbatim       
  21:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
  22:./Lib/Src/stm32f4xx_usart.c ****                         ##### How to use this driver #####
  23:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
  24:./Lib/Src/stm32f4xx_usart.c ****     [..]
  25:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable peripheral clock using the following functions
  26:./Lib/Src/stm32f4xx_usart.c ****           RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
  27:./Lib/Src/stm32f4xx_usart.c ****           RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, 
  28:./Lib/Src/stm32f4xx_usart.c ****           UART4 or UART5.
  29:./Lib/Src/stm32f4xx_usart.c ****   
  30:./Lib/Src/stm32f4xx_usart.c ****       (#) According to the USART mode, enable the GPIO clocks using 
ARM GAS  /tmp/cc9pQZm7.s 			page 2


  31:./Lib/Src/stm32f4xx_usart.c ****           RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
  32:./Lib/Src/stm32f4xx_usart.c ****           or/and SCLK). 
  33:./Lib/Src/stm32f4xx_usart.c ****   
  34:./Lib/Src/stm32f4xx_usart.c ****       (#) Peripheral's alternate function: 
  35:./Lib/Src/stm32f4xx_usart.c ****         (++) Connect the pin to the desired peripherals' Alternate 
  36:./Lib/Src/stm32f4xx_usart.c ****             Function (AF) using GPIO_PinAFConfig() function
  37:./Lib/Src/stm32f4xx_usart.c ****         (++) Configure the desired pin in alternate function by:
  38:./Lib/Src/stm32f4xx_usart.c ****             GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
  39:./Lib/Src/stm32f4xx_usart.c ****         (++) Select the type, pull-up/pull-down and output speed via 
  40:./Lib/Src/stm32f4xx_usart.c ****             GPIO_PuPd, GPIO_OType and GPIO_Speed members
  41:./Lib/Src/stm32f4xx_usart.c ****         (++) Call GPIO_Init() function
  42:./Lib/Src/stm32f4xx_usart.c ****           
  43:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
  44:./Lib/Src/stm32f4xx_usart.c ****           flow control and Mode(Receiver/Transmitter) using the USART_Init()
  45:./Lib/Src/stm32f4xx_usart.c ****           function.
  46:./Lib/Src/stm32f4xx_usart.c ****   
  47:./Lib/Src/stm32f4xx_usart.c ****       (#) For synchronous mode, enable the clock and program the polarity,
  48:./Lib/Src/stm32f4xx_usart.c ****           phase and last bit using the USART_ClockInit() function.
  49:./Lib/Src/stm32f4xx_usart.c ****   
  50:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the NVIC and the corresponding interrupt using the function 
  51:./Lib/Src/stm32f4xx_usart.c ****          USART_ITConfig() if you need to use interrupt mode. 
  52:./Lib/Src/stm32f4xx_usart.c ****   
  53:./Lib/Src/stm32f4xx_usart.c ****       (#) When using the DMA mode 
  54:./Lib/Src/stm32f4xx_usart.c ****         (++) Configure the DMA using DMA_Init() function
  55:./Lib/Src/stm32f4xx_usart.c ****         (++) Active the needed channel Request using USART_DMACmd() function
  56:./Lib/Src/stm32f4xx_usart.c ****    
  57:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
  58:./Lib/Src/stm32f4xx_usart.c ****    
  59:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
  60:./Lib/Src/stm32f4xx_usart.c ****     
  61:./Lib/Src/stm32f4xx_usart.c ****       -@- Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
  62:./Lib/Src/stm32f4xx_usart.c ****           for more details
  63:./Lib/Src/stm32f4xx_usart.c ****     
  64:./Lib/Src/stm32f4xx_usart.c ****     [..]        
  65:./Lib/Src/stm32f4xx_usart.c ****     In order to reach higher communication baudrates, it is possible to
  66:./Lib/Src/stm32f4xx_usart.c ****     enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
  67:./Lib/Src/stm32f4xx_usart.c ****     This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
  68:./Lib/Src/stm32f4xx_usart.c ****     and before calling the function USART_Init().
  69:./Lib/Src/stm32f4xx_usart.c ****             
  70:./Lib/Src/stm32f4xx_usart.c ****     @endverbatim        
  71:./Lib/Src/stm32f4xx_usart.c ****   ******************************************************************************
  72:./Lib/Src/stm32f4xx_usart.c ****   * @attention
  73:./Lib/Src/stm32f4xx_usart.c ****   *
  74:./Lib/Src/stm32f4xx_usart.c ****   * Copyright (c) 2016 STMicroelectronics.
  75:./Lib/Src/stm32f4xx_usart.c ****   * All rights reserved.
  76:./Lib/Src/stm32f4xx_usart.c ****   *
  77:./Lib/Src/stm32f4xx_usart.c ****   * This software is licensed under terms that can be found in the LICENSE file
  78:./Lib/Src/stm32f4xx_usart.c ****   * in the root directory of this software component.
  79:./Lib/Src/stm32f4xx_usart.c ****   * If no LICENSE file comes with this software, it is provided AS-IS.
  80:./Lib/Src/stm32f4xx_usart.c ****   *
  81:./Lib/Src/stm32f4xx_usart.c ****   ******************************************************************************
  82:./Lib/Src/stm32f4xx_usart.c ****   */
  83:./Lib/Src/stm32f4xx_usart.c **** 
  84:./Lib/Src/stm32f4xx_usart.c **** /* Includes ------------------------------------------------------------------*/
  85:./Lib/Src/stm32f4xx_usart.c **** #include "stm32f4xx_usart.h"
  86:./Lib/Src/stm32f4xx_usart.c **** #include "stm32f4xx_rcc.h"
  87:./Lib/Src/stm32f4xx_usart.c **** 
ARM GAS  /tmp/cc9pQZm7.s 			page 3


  88:./Lib/Src/stm32f4xx_usart.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  89:./Lib/Src/stm32f4xx_usart.c ****   * @{
  90:./Lib/Src/stm32f4xx_usart.c ****   */
  91:./Lib/Src/stm32f4xx_usart.c **** 
  92:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART 
  93:./Lib/Src/stm32f4xx_usart.c ****   * @brief USART driver modules
  94:./Lib/Src/stm32f4xx_usart.c ****   * @{
  95:./Lib/Src/stm32f4xx_usart.c ****   */
  96:./Lib/Src/stm32f4xx_usart.c **** 
  97:./Lib/Src/stm32f4xx_usart.c **** /* Private typedef -----------------------------------------------------------*/
  98:./Lib/Src/stm32f4xx_usart.c **** /* Private define ------------------------------------------------------------*/
  99:./Lib/Src/stm32f4xx_usart.c **** 
 100:./Lib/Src/stm32f4xx_usart.c **** /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
 101:./Lib/Src/stm32f4xx_usart.c **** #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
 102:./Lib/Src/stm32f4xx_usart.c ****                                               USART_CR1_PS | USART_CR1_TE | \
 103:./Lib/Src/stm32f4xx_usart.c ****                                               USART_CR1_RE))
 104:./Lib/Src/stm32f4xx_usart.c **** 
 105:./Lib/Src/stm32f4xx_usart.c **** /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
 106:./Lib/Src/stm32f4xx_usart.c **** #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
 107:./Lib/Src/stm32f4xx_usart.c ****                                               USART_CR2_CPHA | USART_CR2_LBCL))
 108:./Lib/Src/stm32f4xx_usart.c **** 
 109:./Lib/Src/stm32f4xx_usart.c **** /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
 110:./Lib/Src/stm32f4xx_usart.c **** #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
 111:./Lib/Src/stm32f4xx_usart.c **** 
 112:./Lib/Src/stm32f4xx_usart.c **** /*!< USART Interrupts mask */
 113:./Lib/Src/stm32f4xx_usart.c **** #define IT_MASK                   ((uint16_t)0x001F)
 114:./Lib/Src/stm32f4xx_usart.c **** 
 115:./Lib/Src/stm32f4xx_usart.c **** /* Private macro -------------------------------------------------------------*/
 116:./Lib/Src/stm32f4xx_usart.c **** /* Private variables ---------------------------------------------------------*/
 117:./Lib/Src/stm32f4xx_usart.c **** /* Private function prototypes -----------------------------------------------*/
 118:./Lib/Src/stm32f4xx_usart.c **** /* Private functions ---------------------------------------------------------*/
 119:./Lib/Src/stm32f4xx_usart.c **** 
 120:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Private_Functions
 121:./Lib/Src/stm32f4xx_usart.c ****   * @{
 122:./Lib/Src/stm32f4xx_usart.c ****   */
 123:./Lib/Src/stm32f4xx_usart.c **** 
 124:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group1 Initialization and Configuration functions
 125:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   Initialization and Configuration functions 
 126:./Lib/Src/stm32f4xx_usart.c ****  *
 127:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
 128:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
 129:./Lib/Src/stm32f4xx_usart.c ****             ##### Initialization and Configuration functions #####
 130:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
 131:./Lib/Src/stm32f4xx_usart.c ****     [..]
 132:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to initialize the USART 
 133:./Lib/Src/stm32f4xx_usart.c ****     in asynchronous and in synchronous modes.
 134:./Lib/Src/stm32f4xx_usart.c ****       (+) For the asynchronous mode only these parameters can be configured: 
 135:./Lib/Src/stm32f4xx_usart.c ****         (++) Baud Rate
 136:./Lib/Src/stm32f4xx_usart.c ****         (++) Word Length 
 137:./Lib/Src/stm32f4xx_usart.c ****         (++) Stop Bit
 138:./Lib/Src/stm32f4xx_usart.c ****         (++) Parity: If the parity is enabled, then the MSB bit of the data written
 139:./Lib/Src/stm32f4xx_usart.c ****              in the data register is transmitted but is changed by the parity bit.
 140:./Lib/Src/stm32f4xx_usart.c ****              Depending on the frame length defined by the M bit (8-bits or 9-bits),
 141:./Lib/Src/stm32f4xx_usart.c ****              the possible USART frame formats are as listed in the following table:
 142:./Lib/Src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+     
 143:./Lib/Src/stm32f4xx_usart.c ****    |   M bit |  PCE bit  |            USART frame                |
 144:./Lib/Src/stm32f4xx_usart.c ****    |---------------------|---------------------------------------|             
ARM GAS  /tmp/cc9pQZm7.s 			page 4


 145:./Lib/Src/stm32f4xx_usart.c ****    |    0    |    0      |    | SB | 8 bit data | STB |          |
 146:./Lib/Src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 147:./Lib/Src/stm32f4xx_usart.c ****    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
 148:./Lib/Src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 149:./Lib/Src/stm32f4xx_usart.c ****    |    1    |    0      |    | SB | 9 bit data | STB |          |
 150:./Lib/Src/stm32f4xx_usart.c ****    |---------|-----------|---------------------------------------|  
 151:./Lib/Src/stm32f4xx_usart.c ****    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
 152:./Lib/Src/stm32f4xx_usart.c ****    +-------------------------------------------------------------+            
 153:./Lib/Src/stm32f4xx_usart.c ****         (++) Hardware flow control
 154:./Lib/Src/stm32f4xx_usart.c ****         (++) Receiver/transmitter modes
 155:./Lib/Src/stm32f4xx_usart.c **** 
 156:./Lib/Src/stm32f4xx_usart.c ****     [..]
 157:./Lib/Src/stm32f4xx_usart.c ****     The USART_Init() function follows the USART  asynchronous configuration 
 158:./Lib/Src/stm32f4xx_usart.c ****     procedure (details for the procedure are available in reference manual (RM0090)).
 159:./Lib/Src/stm32f4xx_usart.c **** 
 160:./Lib/Src/stm32f4xx_usart.c ****      (+) For the synchronous mode in addition to the asynchronous mode parameters these 
 161:./Lib/Src/stm32f4xx_usart.c ****          parameters should be also configured:
 162:./Lib/Src/stm32f4xx_usart.c ****         (++) USART Clock Enabled
 163:./Lib/Src/stm32f4xx_usart.c ****         (++) USART polarity
 164:./Lib/Src/stm32f4xx_usart.c ****         (++) USART phase
 165:./Lib/Src/stm32f4xx_usart.c ****         (++) USART LastBit
 166:./Lib/Src/stm32f4xx_usart.c ****   
 167:./Lib/Src/stm32f4xx_usart.c ****     [..]
 168:./Lib/Src/stm32f4xx_usart.c ****     These parameters can be configured using the USART_ClockInit() function.
 169:./Lib/Src/stm32f4xx_usart.c **** 
 170:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
 171:./Lib/Src/stm32f4xx_usart.c ****   * @{
 172:./Lib/Src/stm32f4xx_usart.c ****   */
 173:./Lib/Src/stm32f4xx_usart.c ****   
 174:./Lib/Src/stm32f4xx_usart.c **** /**
 175:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 176:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 177:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 178:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 179:./Lib/Src/stm32f4xx_usart.c ****   */
 180:./Lib/Src/stm32f4xx_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 181:./Lib/Src/stm32f4xx_usart.c **** {
  29              		.loc 1 181 1
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 8
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 80B5     		push	{r7, lr}
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 82B0     		sub	sp, sp, #8
  38              		.cfi_def_cfa_offset 16
  39 0004 00AF     		add	r7, sp, #0
  40              		.cfi_def_cfa_register 7
  41 0006 7860     		str	r0, [r7, #4]
 182:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 183:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 184:./Lib/Src/stm32f4xx_usart.c **** 
 185:./Lib/Src/stm32f4xx_usart.c ****   if (USARTx == USART1)
  42              		.loc 1 185 6
  43 0008 7B68     		ldr	r3, [r7, #4]
  44 000a 3B4A     		ldr	r2, .L11
ARM GAS  /tmp/cc9pQZm7.s 			page 5


  45 000c 9342     		cmp	r3, r2
  46 000e 08D1     		bne	.L2
 186:./Lib/Src/stm32f4xx_usart.c ****   {
 187:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  47              		.loc 1 187 5
  48 0010 0121     		movs	r1, #1
  49 0012 1020     		movs	r0, #16
  50 0014 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 188:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  51              		.loc 1 188 5
  52 0018 0021     		movs	r1, #0
  53 001a 1020     		movs	r0, #16
  54 001c FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 189:./Lib/Src/stm32f4xx_usart.c ****   }
 190:./Lib/Src/stm32f4xx_usart.c ****   else if (USARTx == USART2)
 191:./Lib/Src/stm32f4xx_usart.c ****   {
 192:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 193:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 194:./Lib/Src/stm32f4xx_usart.c ****   }
 195:./Lib/Src/stm32f4xx_usart.c ****   else if (USARTx == USART3)
 196:./Lib/Src/stm32f4xx_usart.c ****   {
 197:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 198:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 199:./Lib/Src/stm32f4xx_usart.c ****   }    
 200:./Lib/Src/stm32f4xx_usart.c ****   else if (USARTx == UART4)
 201:./Lib/Src/stm32f4xx_usart.c ****   {
 202:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 203:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 204:./Lib/Src/stm32f4xx_usart.c ****   }
 205:./Lib/Src/stm32f4xx_usart.c ****   else if (USARTx == UART5)
 206:./Lib/Src/stm32f4xx_usart.c ****   {
 207:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 208:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 209:./Lib/Src/stm32f4xx_usart.c ****   }  
 210:./Lib/Src/stm32f4xx_usart.c ****   else if (USARTx == USART6)
 211:./Lib/Src/stm32f4xx_usart.c ****   {
 212:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 213:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 214:./Lib/Src/stm32f4xx_usart.c ****   }
 215:./Lib/Src/stm32f4xx_usart.c ****   else if (USARTx == UART7)
 216:./Lib/Src/stm32f4xx_usart.c ****   {
 217:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, ENABLE);
 218:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
 219:./Lib/Src/stm32f4xx_usart.c ****   }     
 220:./Lib/Src/stm32f4xx_usart.c ****   else
 221:./Lib/Src/stm32f4xx_usart.c ****   {
 222:./Lib/Src/stm32f4xx_usart.c ****     if (USARTx == UART8)
 223:./Lib/Src/stm32f4xx_usart.c ****     { 
 224:./Lib/Src/stm32f4xx_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, ENABLE);
 225:./Lib/Src/stm32f4xx_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, DISABLE);
 226:./Lib/Src/stm32f4xx_usart.c ****     }
 227:./Lib/Src/stm32f4xx_usart.c ****   }
 228:./Lib/Src/stm32f4xx_usart.c **** }
  55              		.loc 1 228 1
  56 0020 65E0     		b	.L10
  57              	.L2:
 190:./Lib/Src/stm32f4xx_usart.c ****   {
ARM GAS  /tmp/cc9pQZm7.s 			page 6


  58              		.loc 1 190 11
  59 0022 7B68     		ldr	r3, [r7, #4]
  60 0024 354A     		ldr	r2, .L11+4
  61 0026 9342     		cmp	r3, r2
  62 0028 0AD1     		bne	.L4
 192:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  63              		.loc 1 192 5
  64 002a 0121     		movs	r1, #1
  65 002c 4FF40030 		mov	r0, #131072
  66 0030 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 193:./Lib/Src/stm32f4xx_usart.c ****   }
  67              		.loc 1 193 5
  68 0034 0021     		movs	r1, #0
  69 0036 4FF40030 		mov	r0, #131072
  70 003a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  71              		.loc 1 228 1
  72 003e 56E0     		b	.L10
  73              	.L4:
 195:./Lib/Src/stm32f4xx_usart.c ****   {
  74              		.loc 1 195 11
  75 0040 7B68     		ldr	r3, [r7, #4]
  76 0042 2F4A     		ldr	r2, .L11+8
  77 0044 9342     		cmp	r3, r2
  78 0046 0AD1     		bne	.L5
 197:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  79              		.loc 1 197 5
  80 0048 0121     		movs	r1, #1
  81 004a 4FF48020 		mov	r0, #262144
  82 004e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 198:./Lib/Src/stm32f4xx_usart.c ****   }    
  83              		.loc 1 198 5
  84 0052 0021     		movs	r1, #0
  85 0054 4FF48020 		mov	r0, #262144
  86 0058 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  87              		.loc 1 228 1
  88 005c 47E0     		b	.L10
  89              	.L5:
 200:./Lib/Src/stm32f4xx_usart.c ****   {
  90              		.loc 1 200 11
  91 005e 7B68     		ldr	r3, [r7, #4]
  92 0060 284A     		ldr	r2, .L11+12
  93 0062 9342     		cmp	r3, r2
  94 0064 0AD1     		bne	.L6
 202:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  95              		.loc 1 202 5
  96 0066 0121     		movs	r1, #1
  97 0068 4FF40020 		mov	r0, #524288
  98 006c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 203:./Lib/Src/stm32f4xx_usart.c ****   }
  99              		.loc 1 203 5
 100 0070 0021     		movs	r1, #0
 101 0072 4FF40020 		mov	r0, #524288
 102 0076 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 103              		.loc 1 228 1
 104 007a 38E0     		b	.L10
 105              	.L6:
 205:./Lib/Src/stm32f4xx_usart.c ****   {
ARM GAS  /tmp/cc9pQZm7.s 			page 7


 106              		.loc 1 205 11
 107 007c 7B68     		ldr	r3, [r7, #4]
 108 007e 224A     		ldr	r2, .L11+16
 109 0080 9342     		cmp	r3, r2
 110 0082 0AD1     		bne	.L7
 207:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 111              		.loc 1 207 5
 112 0084 0121     		movs	r1, #1
 113 0086 4FF48010 		mov	r0, #1048576
 114 008a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 208:./Lib/Src/stm32f4xx_usart.c ****   }  
 115              		.loc 1 208 5
 116 008e 0021     		movs	r1, #0
 117 0090 4FF48010 		mov	r0, #1048576
 118 0094 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 119              		.loc 1 228 1
 120 0098 29E0     		b	.L10
 121              	.L7:
 210:./Lib/Src/stm32f4xx_usart.c ****   {
 122              		.loc 1 210 11
 123 009a 7B68     		ldr	r3, [r7, #4]
 124 009c 1B4A     		ldr	r2, .L11+20
 125 009e 9342     		cmp	r3, r2
 126 00a0 08D1     		bne	.L8
 212:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 127              		.loc 1 212 5
 128 00a2 0121     		movs	r1, #1
 129 00a4 2020     		movs	r0, #32
 130 00a6 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 213:./Lib/Src/stm32f4xx_usart.c ****   }
 131              		.loc 1 213 5
 132 00aa 0021     		movs	r1, #0
 133 00ac 2020     		movs	r0, #32
 134 00ae FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 135              		.loc 1 228 1
 136 00b2 1CE0     		b	.L10
 137              	.L8:
 215:./Lib/Src/stm32f4xx_usart.c ****   {
 138              		.loc 1 215 11
 139 00b4 7B68     		ldr	r3, [r7, #4]
 140 00b6 164A     		ldr	r2, .L11+24
 141 00b8 9342     		cmp	r3, r2
 142 00ba 0AD1     		bne	.L9
 217:./Lib/Src/stm32f4xx_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
 143              		.loc 1 217 5
 144 00bc 0121     		movs	r1, #1
 145 00be 4FF08040 		mov	r0, #1073741824
 146 00c2 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 218:./Lib/Src/stm32f4xx_usart.c ****   }     
 147              		.loc 1 218 5
 148 00c6 0021     		movs	r1, #0
 149 00c8 4FF08040 		mov	r0, #1073741824
 150 00cc FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 151              		.loc 1 228 1
 152 00d0 0DE0     		b	.L10
 153              	.L9:
 222:./Lib/Src/stm32f4xx_usart.c ****     { 
ARM GAS  /tmp/cc9pQZm7.s 			page 8


 154              		.loc 1 222 8
 155 00d2 7B68     		ldr	r3, [r7, #4]
 156 00d4 0F4A     		ldr	r2, .L11+28
 157 00d6 9342     		cmp	r3, r2
 158 00d8 09D1     		bne	.L10
 224:./Lib/Src/stm32f4xx_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, DISABLE);
 159              		.loc 1 224 7
 160 00da 0121     		movs	r1, #1
 161 00dc 4FF00040 		mov	r0, #-2147483648
 162 00e0 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 225:./Lib/Src/stm32f4xx_usart.c ****     }
 163              		.loc 1 225 7
 164 00e4 0021     		movs	r1, #0
 165 00e6 4FF00040 		mov	r0, #-2147483648
 166 00ea FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 167              	.L10:
 168              		.loc 1 228 1
 169 00ee 00BF     		nop
 170 00f0 0837     		adds	r7, r7, #8
 171              		.cfi_def_cfa_offset 8
 172 00f2 BD46     		mov	sp, r7
 173              		.cfi_def_cfa_register 13
 174              		@ sp needed
 175 00f4 80BD     		pop	{r7, pc}
 176              	.L12:
 177 00f6 00BF     		.align	2
 178              	.L11:
 179 00f8 00100140 		.word	1073811456
 180 00fc 00440040 		.word	1073759232
 181 0100 00480040 		.word	1073760256
 182 0104 004C0040 		.word	1073761280
 183 0108 00500040 		.word	1073762304
 184 010c 00140140 		.word	1073812480
 185 0110 00780040 		.word	1073772544
 186 0114 007C0040 		.word	1073773568
 187              		.cfi_endproc
 188              	.LFE123:
 190              		.section	.text.USART_Init,"ax",%progbits
 191              		.align	1
 192              		.global	USART_Init
 193              		.syntax unified
 194              		.thumb
 195              		.thumb_func
 197              	USART_Init:
 198              	.LFB124:
 229:./Lib/Src/stm32f4xx_usart.c **** 
 230:./Lib/Src/stm32f4xx_usart.c **** /**
 231:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 232:./Lib/Src/stm32f4xx_usart.c ****   *         parameters in the USART_InitStruct .
 233:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 234:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 235:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
 236:./Lib/Src/stm32f4xx_usart.c ****   *         the configuration information for the specified USART peripheral.
 237:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 238:./Lib/Src/stm32f4xx_usart.c ****   */
 239:./Lib/Src/stm32f4xx_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 240:./Lib/Src/stm32f4xx_usart.c **** {
ARM GAS  /tmp/cc9pQZm7.s 			page 9


 199              		.loc 1 240 1
 200              		.cfi_startproc
 201              		@ args = 0, pretend = 0, frame = 40
 202              		@ frame_needed = 1, uses_anonymous_args = 0
 203 0000 80B5     		push	{r7, lr}
 204              		.cfi_def_cfa_offset 8
 205              		.cfi_offset 7, -8
 206              		.cfi_offset 14, -4
 207 0002 8AB0     		sub	sp, sp, #40
 208              		.cfi_def_cfa_offset 48
 209 0004 00AF     		add	r7, sp, #0
 210              		.cfi_def_cfa_register 7
 211 0006 7860     		str	r0, [r7, #4]
 212 0008 3960     		str	r1, [r7]
 241:./Lib/Src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00, apbclock = 0x00;
 213              		.loc 1 241 12
 214 000a 0023     		movs	r3, #0
 215 000c 7B62     		str	r3, [r7, #36]
 216              		.loc 1 241 27
 217 000e 0023     		movs	r3, #0
 218 0010 3B62     		str	r3, [r7, #32]
 242:./Lib/Src/stm32f4xx_usart.c ****   uint32_t integerdivider = 0x00;
 219              		.loc 1 242 12
 220 0012 0023     		movs	r3, #0
 221 0014 FB61     		str	r3, [r7, #28]
 243:./Lib/Src/stm32f4xx_usart.c ****   uint32_t fractionaldivider = 0x00;
 222              		.loc 1 243 12
 223 0016 0023     		movs	r3, #0
 224 0018 BB61     		str	r3, [r7, #24]
 244:./Lib/Src/stm32f4xx_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 245:./Lib/Src/stm32f4xx_usart.c **** 
 246:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 247:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 248:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 249:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 250:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 251:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 252:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 253:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 254:./Lib/Src/stm32f4xx_usart.c **** 
 255:./Lib/Src/stm32f4xx_usart.c ****   /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
 256:./Lib/Src/stm32f4xx_usart.c ****   if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
 257:./Lib/Src/stm32f4xx_usart.c ****   {
 258:./Lib/Src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
 259:./Lib/Src/stm32f4xx_usart.c ****   }
 260:./Lib/Src/stm32f4xx_usart.c **** 
 261:./Lib/Src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 262:./Lib/Src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 225              		.loc 1 262 18
 226 001a 7B68     		ldr	r3, [r7, #4]
 227 001c 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 228 001e 9BB2     		uxth	r3, r3
 229              		.loc 1 262 10
 230 0020 7B62     		str	r3, [r7, #36]
 263:./Lib/Src/stm32f4xx_usart.c **** 
 264:./Lib/Src/stm32f4xx_usart.c ****   /* Clear STOP[13:12] bits */
 265:./Lib/Src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
ARM GAS  /tmp/cc9pQZm7.s 			page 10


 231              		.loc 1 265 10
 232 0022 7B6A     		ldr	r3, [r7, #36]
 233 0024 23F44053 		bic	r3, r3, #12288
 234 0028 7B62     		str	r3, [r7, #36]
 266:./Lib/Src/stm32f4xx_usart.c **** 
 267:./Lib/Src/stm32f4xx_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
 268:./Lib/Src/stm32f4xx_usart.c ****       Set STOP[13:12] bits according to USART_StopBits value */
 269:./Lib/Src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 235              		.loc 1 269 39
 236 002a 3B68     		ldr	r3, [r7]
 237 002c DB88     		ldrh	r3, [r3, #6]
 238              		.loc 1 269 13
 239 002e 1A46     		mov	r2, r3
 240              		.loc 1 269 10
 241 0030 7B6A     		ldr	r3, [r7, #36]
 242 0032 1343     		orrs	r3, r3, r2
 243 0034 7B62     		str	r3, [r7, #36]
 270:./Lib/Src/stm32f4xx_usart.c ****   
 271:./Lib/Src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 272:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 244              		.loc 1 272 17
 245 0036 7B6A     		ldr	r3, [r7, #36]
 246 0038 9AB2     		uxth	r2, r3
 247              		.loc 1 272 15
 248 003a 7B68     		ldr	r3, [r7, #4]
 249 003c 1A82     		strh	r2, [r3, #16]	@ movhi
 273:./Lib/Src/stm32f4xx_usart.c **** 
 274:./Lib/Src/stm32f4xx_usart.c **** /*---------------------------- USART CR1 Configuration -----------------------*/
 275:./Lib/Src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR1;
 250              		.loc 1 275 18
 251 003e 7B68     		ldr	r3, [r7, #4]
 252 0040 9B89     		ldrh	r3, [r3, #12]	@ movhi
 253 0042 9BB2     		uxth	r3, r3
 254              		.loc 1 275 10
 255 0044 7B62     		str	r3, [r7, #36]
 276:./Lib/Src/stm32f4xx_usart.c **** 
 277:./Lib/Src/stm32f4xx_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 278:./Lib/Src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 256              		.loc 1 278 10
 257 0046 7B6A     		ldr	r3, [r7, #36]
 258 0048 23F4B053 		bic	r3, r3, #5632
 259 004c 23F00C03 		bic	r3, r3, #12
 260 0050 7B62     		str	r3, [r7, #36]
 279:./Lib/Src/stm32f4xx_usart.c **** 
 280:./Lib/Src/stm32f4xx_usart.c ****   /* Configure the USART Word Length, Parity and mode: 
 281:./Lib/Src/stm32f4xx_usart.c ****      Set the M bits according to USART_WordLength value 
 282:./Lib/Src/stm32f4xx_usart.c ****      Set PCE and PS bits according to USART_Parity value
 283:./Lib/Src/stm32f4xx_usart.c ****      Set TE and RE bits according to USART_Mode value */
 284:./Lib/Src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 261              		.loc 1 284 39
 262 0052 3B68     		ldr	r3, [r7]
 263 0054 9A88     		ldrh	r2, [r3, #4]
 264              		.loc 1 284 76
 265 0056 3B68     		ldr	r3, [r7]
 266 0058 1B89     		ldrh	r3, [r3, #8]
 267              		.loc 1 284 91
 268 005a 1343     		orrs	r3, r3, r2
ARM GAS  /tmp/cc9pQZm7.s 			page 11


 269 005c 9AB2     		uxth	r2, r3
 285:./Lib/Src/stm32f4xx_usart.c ****             USART_InitStruct->USART_Mode;
 270              		.loc 1 285 29
 271 005e 3B68     		ldr	r3, [r7]
 272 0060 5B89     		ldrh	r3, [r3, #10]
 284:./Lib/Src/stm32f4xx_usart.c ****             USART_InitStruct->USART_Mode;
 273              		.loc 1 284 91
 274 0062 1343     		orrs	r3, r3, r2
 275 0064 9BB2     		uxth	r3, r3
 276 0066 1A46     		mov	r2, r3
 284:./Lib/Src/stm32f4xx_usart.c ****             USART_InitStruct->USART_Mode;
 277              		.loc 1 284 10
 278 0068 7B6A     		ldr	r3, [r7, #36]
 279 006a 1343     		orrs	r3, r3, r2
 280 006c 7B62     		str	r3, [r7, #36]
 286:./Lib/Src/stm32f4xx_usart.c **** 
 287:./Lib/Src/stm32f4xx_usart.c ****   /* Write to USART CR1 */
 288:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR1 = (uint16_t)tmpreg;
 281              		.loc 1 288 17
 282 006e 7B6A     		ldr	r3, [r7, #36]
 283 0070 9AB2     		uxth	r2, r3
 284              		.loc 1 288 15
 285 0072 7B68     		ldr	r3, [r7, #4]
 286 0074 9A81     		strh	r2, [r3, #12]	@ movhi
 289:./Lib/Src/stm32f4xx_usart.c **** 
 290:./Lib/Src/stm32f4xx_usart.c **** /*---------------------------- USART CR3 Configuration -----------------------*/  
 291:./Lib/Src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR3;
 287              		.loc 1 291 18
 288 0076 7B68     		ldr	r3, [r7, #4]
 289 0078 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 290 007a 9BB2     		uxth	r3, r3
 291              		.loc 1 291 10
 292 007c 7B62     		str	r3, [r7, #36]
 292:./Lib/Src/stm32f4xx_usart.c **** 
 293:./Lib/Src/stm32f4xx_usart.c ****   /* Clear CTSE and RTSE bits */
 294:./Lib/Src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 293              		.loc 1 294 10
 294 007e 7B6A     		ldr	r3, [r7, #36]
 295 0080 23F44073 		bic	r3, r3, #768
 296 0084 7B62     		str	r3, [r7, #36]
 295:./Lib/Src/stm32f4xx_usart.c **** 
 296:./Lib/Src/stm32f4xx_usart.c ****   /* Configure the USART HFC : 
 297:./Lib/Src/stm32f4xx_usart.c ****       Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 298:./Lib/Src/stm32f4xx_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 297              		.loc 1 298 29
 298 0086 3B68     		ldr	r3, [r7]
 299 0088 9B89     		ldrh	r3, [r3, #12]
 300 008a 1A46     		mov	r2, r3
 301              		.loc 1 298 10
 302 008c 7B6A     		ldr	r3, [r7, #36]
 303 008e 1343     		orrs	r3, r3, r2
 304 0090 7B62     		str	r3, [r7, #36]
 299:./Lib/Src/stm32f4xx_usart.c **** 
 300:./Lib/Src/stm32f4xx_usart.c ****   /* Write to USART CR3 */
 301:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR3 = (uint16_t)tmpreg;
 305              		.loc 1 301 17
 306 0092 7B6A     		ldr	r3, [r7, #36]
ARM GAS  /tmp/cc9pQZm7.s 			page 12


 307 0094 9AB2     		uxth	r2, r3
 308              		.loc 1 301 15
 309 0096 7B68     		ldr	r3, [r7, #4]
 310 0098 9A82     		strh	r2, [r3, #20]	@ movhi
 302:./Lib/Src/stm32f4xx_usart.c **** 
 303:./Lib/Src/stm32f4xx_usart.c **** /*---------------------------- USART BRR Configuration -----------------------*/
 304:./Lib/Src/stm32f4xx_usart.c ****   /* Configure the USART Baud Rate */
 305:./Lib/Src/stm32f4xx_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 311              		.loc 1 305 3
 312 009a 07F10803 		add	r3, r7, #8
 313 009e 1846     		mov	r0, r3
 314 00a0 FFF7FEFF 		bl	RCC_GetClocksFreq
 306:./Lib/Src/stm32f4xx_usart.c **** 
 307:./Lib/Src/stm32f4xx_usart.c ****   if ((USARTx == USART1) || (USARTx == USART6))
 315              		.loc 1 307 6
 316 00a4 7B68     		ldr	r3, [r7, #4]
 317 00a6 304A     		ldr	r2, .L21
 318 00a8 9342     		cmp	r3, r2
 319 00aa 03D0     		beq	.L14
 320              		.loc 1 307 26 discriminator 1
 321 00ac 7B68     		ldr	r3, [r7, #4]
 322 00ae 2F4A     		ldr	r2, .L21+4
 323 00b0 9342     		cmp	r3, r2
 324 00b2 02D1     		bne	.L15
 325              	.L14:
 308:./Lib/Src/stm32f4xx_usart.c ****   {
 309:./Lib/Src/stm32f4xx_usart.c ****     //apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 310:./Lib/Src/stm32f4xx_usart.c **** 	  apbclock=16000000;
 326              		.loc 1 310 12
 327 00b4 2E4B     		ldr	r3, .L21+8
 328 00b6 3B62     		str	r3, [r7, #32]
 329 00b8 01E0     		b	.L16
 330              	.L15:
 311:./Lib/Src/stm32f4xx_usart.c ****   }
 312:./Lib/Src/stm32f4xx_usart.c ****   else
 313:./Lib/Src/stm32f4xx_usart.c ****   {
 314:./Lib/Src/stm32f4xx_usart.c ****     apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 331              		.loc 1 314 14
 332 00ba 3B69     		ldr	r3, [r7, #16]
 333 00bc 3B62     		str	r3, [r7, #32]
 334              	.L16:
 315:./Lib/Src/stm32f4xx_usart.c ****   }
 316:./Lib/Src/stm32f4xx_usart.c ****   
 317:./Lib/Src/stm32f4xx_usart.c ****   /* Determine the integer part */
 318:./Lib/Src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 335              		.loc 1 318 14
 336 00be 7B68     		ldr	r3, [r7, #4]
 337 00c0 9B89     		ldrh	r3, [r3, #12]	@ movhi
 338 00c2 9BB2     		uxth	r3, r3
 339              		.loc 1 318 39
 340 00c4 1BB2     		sxth	r3, r3
 341              		.loc 1 318 6
 342 00c6 002B     		cmp	r3, #0
 343 00c8 0CDA     		bge	.L17
 319:./Lib/Src/stm32f4xx_usart.c ****   {
 320:./Lib/Src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 8 Samples */
 321:./Lib/Src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
ARM GAS  /tmp/cc9pQZm7.s 			page 13


 344              		.loc 1 321 27
 345 00ca 3A6A     		ldr	r2, [r7, #32]
 346 00cc 1346     		mov	r3, r2
 347 00ce 9B00     		lsls	r3, r3, #2
 348 00d0 1344     		add	r3, r3, r2
 349 00d2 9A00     		lsls	r2, r3, #2
 350 00d4 1A44     		add	r2, r2, r3
 351              		.loc 1 321 63
 352 00d6 3B68     		ldr	r3, [r7]
 353 00d8 1B68     		ldr	r3, [r3]
 354              		.loc 1 321 44
 355 00da 5B00     		lsls	r3, r3, #1
 356              		.loc 1 321 20
 357 00dc B2FBF3F3 		udiv	r3, r2, r3
 358 00e0 FB61     		str	r3, [r7, #28]
 359 00e2 0BE0     		b	.L18
 360              	.L17:
 322:./Lib/Src/stm32f4xx_usart.c ****   }
 323:./Lib/Src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 324:./Lib/Src/stm32f4xx_usart.c ****   {
 325:./Lib/Src/stm32f4xx_usart.c ****     /* Integer part computing in case Oversampling mode is 16 Samples */
 326:./Lib/Src/stm32f4xx_usart.c ****     integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 361              		.loc 1 326 27
 362 00e4 3A6A     		ldr	r2, [r7, #32]
 363 00e6 1346     		mov	r3, r2
 364 00e8 9B00     		lsls	r3, r3, #2
 365 00ea 1344     		add	r3, r3, r2
 366 00ec 9A00     		lsls	r2, r3, #2
 367 00ee 1A44     		add	r2, r2, r3
 368              		.loc 1 326 63
 369 00f0 3B68     		ldr	r3, [r7]
 370 00f2 1B68     		ldr	r3, [r3]
 371              		.loc 1 326 44
 372 00f4 9B00     		lsls	r3, r3, #2
 373              		.loc 1 326 20
 374 00f6 B2FBF3F3 		udiv	r3, r2, r3
 375 00fa FB61     		str	r3, [r7, #28]
 376              	.L18:
 327:./Lib/Src/stm32f4xx_usart.c ****   }
 328:./Lib/Src/stm32f4xx_usart.c ****   tmpreg = (integerdivider / 100) << 4;
 377              		.loc 1 328 28
 378 00fc FB69     		ldr	r3, [r7, #28]
 379 00fe 1D4A     		ldr	r2, .L21+12
 380 0100 A2FB0323 		umull	r2, r3, r2, r3
 381 0104 5B09     		lsrs	r3, r3, #5
 382              		.loc 1 328 10
 383 0106 1B01     		lsls	r3, r3, #4
 384 0108 7B62     		str	r3, [r7, #36]
 329:./Lib/Src/stm32f4xx_usart.c **** 
 330:./Lib/Src/stm32f4xx_usart.c ****   /* Determine the fractional part */
 331:./Lib/Src/stm32f4xx_usart.c ****   fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 385              		.loc 1 331 55
 386 010a 7B6A     		ldr	r3, [r7, #36]
 387 010c 1B09     		lsrs	r3, r3, #4
 388              		.loc 1 331 45
 389 010e 6422     		movs	r2, #100
 390 0110 02FB03F3 		mul	r3, r2, r3
ARM GAS  /tmp/cc9pQZm7.s 			page 14


 391              		.loc 1 331 21
 392 0114 FA69     		ldr	r2, [r7, #28]
 393 0116 D31A     		subs	r3, r2, r3
 394 0118 BB61     		str	r3, [r7, #24]
 332:./Lib/Src/stm32f4xx_usart.c **** 
 333:./Lib/Src/stm32f4xx_usart.c ****   /* Implement the fractional part in the register */
 334:./Lib/Src/stm32f4xx_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 395              		.loc 1 334 14
 396 011a 7B68     		ldr	r3, [r7, #4]
 397 011c 9B89     		ldrh	r3, [r3, #12]	@ movhi
 398 011e 9BB2     		uxth	r3, r3
 399              		.loc 1 334 39
 400 0120 1BB2     		sxth	r3, r3
 401              		.loc 1 334 6
 402 0122 002B     		cmp	r3, #0
 403 0124 0CDA     		bge	.L19
 335:./Lib/Src/stm32f4xx_usart.c ****   {
 336:./Lib/Src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 404              		.loc 1 336 37
 405 0126 BB69     		ldr	r3, [r7, #24]
 406 0128 DB00     		lsls	r3, r3, #3
 407              		.loc 1 336 42
 408 012a 3233     		adds	r3, r3, #50
 409              		.loc 1 336 48
 410 012c 114A     		ldr	r2, .L21+12
 411 012e A2FB0323 		umull	r2, r3, r2, r3
 412 0132 5B09     		lsrs	r3, r3, #5
 413              		.loc 1 336 56
 414 0134 03F00703 		and	r3, r3, #7
 415              		.loc 1 336 12
 416 0138 7A6A     		ldr	r2, [r7, #36]
 417 013a 1343     		orrs	r3, r3, r2
 418 013c 7B62     		str	r3, [r7, #36]
 419 013e 0BE0     		b	.L20
 420              	.L19:
 337:./Lib/Src/stm32f4xx_usart.c ****   }
 338:./Lib/Src/stm32f4xx_usart.c ****   else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
 339:./Lib/Src/stm32f4xx_usart.c ****   {
 340:./Lib/Src/stm32f4xx_usart.c ****     tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 421              		.loc 1 340 37
 422 0140 BB69     		ldr	r3, [r7, #24]
 423 0142 1B01     		lsls	r3, r3, #4
 424              		.loc 1 340 43
 425 0144 3233     		adds	r3, r3, #50
 426              		.loc 1 340 49
 427 0146 0B4A     		ldr	r2, .L21+12
 428 0148 A2FB0323 		umull	r2, r3, r2, r3
 429 014c 5B09     		lsrs	r3, r3, #5
 430              		.loc 1 340 57
 431 014e 03F00F03 		and	r3, r3, #15
 432              		.loc 1 340 12
 433 0152 7A6A     		ldr	r2, [r7, #36]
 434 0154 1343     		orrs	r3, r3, r2
 435 0156 7B62     		str	r3, [r7, #36]
 436              	.L20:
 341:./Lib/Src/stm32f4xx_usart.c ****   }
 342:./Lib/Src/stm32f4xx_usart.c ****   
ARM GAS  /tmp/cc9pQZm7.s 			page 15


 343:./Lib/Src/stm32f4xx_usart.c ****   /* Write to USART BRR register */
 344:./Lib/Src/stm32f4xx_usart.c ****   USARTx->BRR = (uint16_t)tmpreg;
 437              		.loc 1 344 17
 438 0158 7B6A     		ldr	r3, [r7, #36]
 439 015a 9AB2     		uxth	r2, r3
 440              		.loc 1 344 15
 441 015c 7B68     		ldr	r3, [r7, #4]
 442 015e 1A81     		strh	r2, [r3, #8]	@ movhi
 345:./Lib/Src/stm32f4xx_usart.c **** }
 443              		.loc 1 345 1
 444 0160 00BF     		nop
 445 0162 2837     		adds	r7, r7, #40
 446              		.cfi_def_cfa_offset 8
 447 0164 BD46     		mov	sp, r7
 448              		.cfi_def_cfa_register 13
 449              		@ sp needed
 450 0166 80BD     		pop	{r7, pc}
 451              	.L22:
 452              		.align	2
 453              	.L21:
 454 0168 00100140 		.word	1073811456
 455 016c 00140140 		.word	1073812480
 456 0170 0024F400 		.word	16000000
 457 0174 1F85EB51 		.word	1374389535
 458              		.cfi_endproc
 459              	.LFE124:
 461              		.section	.text.USART_StructInit,"ax",%progbits
 462              		.align	1
 463              		.global	USART_StructInit
 464              		.syntax unified
 465              		.thumb
 466              		.thumb_func
 468              	USART_StructInit:
 469              	.LFB125:
 346:./Lib/Src/stm32f4xx_usart.c **** 
 347:./Lib/Src/stm32f4xx_usart.c **** /**
 348:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 349:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
 350:./Lib/Src/stm32f4xx_usart.c ****   *         be initialized.
 351:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 352:./Lib/Src/stm32f4xx_usart.c ****   */
 353:./Lib/Src/stm32f4xx_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 354:./Lib/Src/stm32f4xx_usart.c **** {
 470              		.loc 1 354 1
 471              		.cfi_startproc
 472              		@ args = 0, pretend = 0, frame = 8
 473              		@ frame_needed = 1, uses_anonymous_args = 0
 474              		@ link register save eliminated.
 475 0000 80B4     		push	{r7}
 476              		.cfi_def_cfa_offset 4
 477              		.cfi_offset 7, -4
 478 0002 83B0     		sub	sp, sp, #12
 479              		.cfi_def_cfa_offset 16
 480 0004 00AF     		add	r7, sp, #0
 481              		.cfi_def_cfa_register 7
 482 0006 7860     		str	r0, [r7, #4]
 355:./Lib/Src/stm32f4xx_usart.c ****   /* USART_InitStruct members default value */
ARM GAS  /tmp/cc9pQZm7.s 			page 16


 356:./Lib/Src/stm32f4xx_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 483              		.loc 1 356 36
 484 0008 7B68     		ldr	r3, [r7, #4]
 485 000a 4FF41652 		mov	r2, #9600
 486 000e 1A60     		str	r2, [r3]
 357:./Lib/Src/stm32f4xx_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 487              		.loc 1 357 38
 488 0010 7B68     		ldr	r3, [r7, #4]
 489 0012 0022     		movs	r2, #0
 490 0014 9A80     		strh	r2, [r3, #4]	@ movhi
 358:./Lib/Src/stm32f4xx_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 491              		.loc 1 358 36
 492 0016 7B68     		ldr	r3, [r7, #4]
 493 0018 0022     		movs	r2, #0
 494 001a DA80     		strh	r2, [r3, #6]	@ movhi
 359:./Lib/Src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 495              		.loc 1 359 34
 496 001c 7B68     		ldr	r3, [r7, #4]
 497 001e 0022     		movs	r2, #0
 498 0020 1A81     		strh	r2, [r3, #8]	@ movhi
 360:./Lib/Src/stm32f4xx_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 499              		.loc 1 360 32
 500 0022 7B68     		ldr	r3, [r7, #4]
 501 0024 0C22     		movs	r2, #12
 502 0026 5A81     		strh	r2, [r3, #10]	@ movhi
 361:./Lib/Src/stm32f4xx_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 503              		.loc 1 361 47
 504 0028 7B68     		ldr	r3, [r7, #4]
 505 002a 0022     		movs	r2, #0
 506 002c 9A81     		strh	r2, [r3, #12]	@ movhi
 362:./Lib/Src/stm32f4xx_usart.c **** }
 507              		.loc 1 362 1
 508 002e 00BF     		nop
 509 0030 0C37     		adds	r7, r7, #12
 510              		.cfi_def_cfa_offset 4
 511 0032 BD46     		mov	sp, r7
 512              		.cfi_def_cfa_register 13
 513              		@ sp needed
 514 0034 5DF8047B 		ldr	r7, [sp], #4
 515              		.cfi_restore 7
 516              		.cfi_def_cfa_offset 0
 517 0038 7047     		bx	lr
 518              		.cfi_endproc
 519              	.LFE125:
 521              		.section	.text.USART_ClockInit,"ax",%progbits
 522              		.align	1
 523              		.global	USART_ClockInit
 524              		.syntax unified
 525              		.thumb
 526              		.thumb_func
 528              	USART_ClockInit:
 529              	.LFB126:
 363:./Lib/Src/stm32f4xx_usart.c **** 
 364:./Lib/Src/stm32f4xx_usart.c **** /**
 365:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the 
 366:./Lib/Src/stm32f4xx_usart.c ****   *         specified parameters in the USART_ClockInitStruct .
 367:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
ARM GAS  /tmp/cc9pQZm7.s 			page 17


 368:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
 369:./Lib/Src/stm32f4xx_usart.c ****   *         contains the configuration information for the specified  USART peripheral.
 370:./Lib/Src/stm32f4xx_usart.c ****   * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
 371:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 372:./Lib/Src/stm32f4xx_usart.c ****   */
 373:./Lib/Src/stm32f4xx_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 374:./Lib/Src/stm32f4xx_usart.c **** {
 530              		.loc 1 374 1
 531              		.cfi_startproc
 532              		@ args = 0, pretend = 0, frame = 16
 533              		@ frame_needed = 1, uses_anonymous_args = 0
 534              		@ link register save eliminated.
 535 0000 80B4     		push	{r7}
 536              		.cfi_def_cfa_offset 4
 537              		.cfi_offset 7, -4
 538 0002 85B0     		sub	sp, sp, #20
 539              		.cfi_def_cfa_offset 24
 540 0004 00AF     		add	r7, sp, #0
 541              		.cfi_def_cfa_register 7
 542 0006 7860     		str	r0, [r7, #4]
 543 0008 3960     		str	r1, [r7]
 375:./Lib/Src/stm32f4xx_usart.c ****   uint32_t tmpreg = 0x00;
 544              		.loc 1 375 12
 545 000a 0023     		movs	r3, #0
 546 000c FB60     		str	r3, [r7, #12]
 376:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 377:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 378:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 379:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 380:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 381:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 382:./Lib/Src/stm32f4xx_usart.c ****   
 383:./Lib/Src/stm32f4xx_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 384:./Lib/Src/stm32f4xx_usart.c ****   tmpreg = USARTx->CR2;
 547              		.loc 1 384 18
 548 000e 7B68     		ldr	r3, [r7, #4]
 549 0010 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 550 0012 9BB2     		uxth	r3, r3
 551              		.loc 1 384 10
 552 0014 FB60     		str	r3, [r7, #12]
 385:./Lib/Src/stm32f4xx_usart.c ****   /* Clear CLKEN, CPOL, CPHA and LBCL bits */
 386:./Lib/Src/stm32f4xx_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 553              		.loc 1 386 10
 554 0016 FB68     		ldr	r3, [r7, #12]
 555 0018 23F47063 		bic	r3, r3, #3840
 556 001c FB60     		str	r3, [r7, #12]
 387:./Lib/Src/stm32f4xx_usart.c ****   /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
 388:./Lib/Src/stm32f4xx_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 389:./Lib/Src/stm32f4xx_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 390:./Lib/Src/stm32f4xx_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 391:./Lib/Src/stm32f4xx_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 392:./Lib/Src/stm32f4xx_usart.c ****   tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 557              		.loc 1 392 44
 558 001e 3B68     		ldr	r3, [r7]
 559 0020 1A88     		ldrh	r2, [r3]
 560              		.loc 1 392 81
 561 0022 3B68     		ldr	r3, [r7]
ARM GAS  /tmp/cc9pQZm7.s 			page 18


 562 0024 5B88     		ldrh	r3, [r3, #2]
 393:./Lib/Src/stm32f4xx_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 563              		.loc 1 393 52
 564 0026 1343     		orrs	r3, r3, r2
 565 0028 9AB2     		uxth	r2, r3
 566              		.loc 1 393 39
 567 002a 3B68     		ldr	r3, [r7]
 568 002c 9B88     		ldrh	r3, [r3, #4]
 569              		.loc 1 393 52
 570 002e 1343     		orrs	r3, r3, r2
 571 0030 9AB2     		uxth	r2, r3
 572              		.loc 1 393 75
 573 0032 3B68     		ldr	r3, [r7]
 574 0034 DB88     		ldrh	r3, [r3, #6]
 575              		.loc 1 393 52
 576 0036 1343     		orrs	r3, r3, r2
 577 0038 9BB2     		uxth	r3, r3
 578 003a 1A46     		mov	r2, r3
 392:./Lib/Src/stm32f4xx_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 579              		.loc 1 392 10
 580 003c FB68     		ldr	r3, [r7, #12]
 581 003e 1343     		orrs	r3, r3, r2
 582 0040 FB60     		str	r3, [r7, #12]
 394:./Lib/Src/stm32f4xx_usart.c ****   /* Write to USART CR2 */
 395:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR2 = (uint16_t)tmpreg;
 583              		.loc 1 395 17
 584 0042 FB68     		ldr	r3, [r7, #12]
 585 0044 9AB2     		uxth	r2, r3
 586              		.loc 1 395 15
 587 0046 7B68     		ldr	r3, [r7, #4]
 588 0048 1A82     		strh	r2, [r3, #16]	@ movhi
 396:./Lib/Src/stm32f4xx_usart.c **** }
 589              		.loc 1 396 1
 590 004a 00BF     		nop
 591 004c 1437     		adds	r7, r7, #20
 592              		.cfi_def_cfa_offset 4
 593 004e BD46     		mov	sp, r7
 594              		.cfi_def_cfa_register 13
 595              		@ sp needed
 596 0050 5DF8047B 		ldr	r7, [sp], #4
 597              		.cfi_restore 7
 598              		.cfi_def_cfa_offset 0
 599 0054 7047     		bx	lr
 600              		.cfi_endproc
 601              	.LFE126:
 603              		.section	.text.USART_ClockStructInit,"ax",%progbits
 604              		.align	1
 605              		.global	USART_ClockStructInit
 606              		.syntax unified
 607              		.thumb
 608              		.thumb_func
 610              	USART_ClockStructInit:
 611              	.LFB127:
 397:./Lib/Src/stm32f4xx_usart.c **** 
 398:./Lib/Src/stm32f4xx_usart.c **** /**
 399:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 400:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
ARM GAS  /tmp/cc9pQZm7.s 			page 19


 401:./Lib/Src/stm32f4xx_usart.c ****   *         which will be initialized.
 402:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 403:./Lib/Src/stm32f4xx_usart.c ****   */
 404:./Lib/Src/stm32f4xx_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 405:./Lib/Src/stm32f4xx_usart.c **** {
 612              		.loc 1 405 1
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 8
 615              		@ frame_needed = 1, uses_anonymous_args = 0
 616              		@ link register save eliminated.
 617 0000 80B4     		push	{r7}
 618              		.cfi_def_cfa_offset 4
 619              		.cfi_offset 7, -4
 620 0002 83B0     		sub	sp, sp, #12
 621              		.cfi_def_cfa_offset 16
 622 0004 00AF     		add	r7, sp, #0
 623              		.cfi_def_cfa_register 7
 624 0006 7860     		str	r0, [r7, #4]
 406:./Lib/Src/stm32f4xx_usart.c ****   /* USART_ClockInitStruct members default value */
 407:./Lib/Src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 625              		.loc 1 407 38
 626 0008 7B68     		ldr	r3, [r7, #4]
 627 000a 0022     		movs	r2, #0
 628 000c 1A80     		strh	r2, [r3]	@ movhi
 408:./Lib/Src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 629              		.loc 1 408 37
 630 000e 7B68     		ldr	r3, [r7, #4]
 631 0010 0022     		movs	r2, #0
 632 0012 5A80     		strh	r2, [r3, #2]	@ movhi
 409:./Lib/Src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 633              		.loc 1 409 37
 634 0014 7B68     		ldr	r3, [r7, #4]
 635 0016 0022     		movs	r2, #0
 636 0018 9A80     		strh	r2, [r3, #4]	@ movhi
 410:./Lib/Src/stm32f4xx_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 637              		.loc 1 410 40
 638 001a 7B68     		ldr	r3, [r7, #4]
 639 001c 0022     		movs	r2, #0
 640 001e DA80     		strh	r2, [r3, #6]	@ movhi
 411:./Lib/Src/stm32f4xx_usart.c **** }
 641              		.loc 1 411 1
 642 0020 00BF     		nop
 643 0022 0C37     		adds	r7, r7, #12
 644              		.cfi_def_cfa_offset 4
 645 0024 BD46     		mov	sp, r7
 646              		.cfi_def_cfa_register 13
 647              		@ sp needed
 648 0026 5DF8047B 		ldr	r7, [sp], #4
 649              		.cfi_restore 7
 650              		.cfi_def_cfa_offset 0
 651 002a 7047     		bx	lr
 652              		.cfi_endproc
 653              	.LFE127:
 655              		.section	.text.USART_Cmd,"ax",%progbits
 656              		.align	1
 657              		.global	USART_Cmd
 658              		.syntax unified
ARM GAS  /tmp/cc9pQZm7.s 			page 20


 659              		.thumb
 660              		.thumb_func
 662              	USART_Cmd:
 663              	.LFB128:
 412:./Lib/Src/stm32f4xx_usart.c **** 
 413:./Lib/Src/stm32f4xx_usart.c **** /**
 414:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 415:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 416:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 417:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 418:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 419:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 420:./Lib/Src/stm32f4xx_usart.c ****   */
 421:./Lib/Src/stm32f4xx_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 422:./Lib/Src/stm32f4xx_usart.c **** {
 664              		.loc 1 422 1
 665              		.cfi_startproc
 666              		@ args = 0, pretend = 0, frame = 8
 667              		@ frame_needed = 1, uses_anonymous_args = 0
 668              		@ link register save eliminated.
 669 0000 80B4     		push	{r7}
 670              		.cfi_def_cfa_offset 4
 671              		.cfi_offset 7, -4
 672 0002 83B0     		sub	sp, sp, #12
 673              		.cfi_def_cfa_offset 16
 674 0004 00AF     		add	r7, sp, #0
 675              		.cfi_def_cfa_register 7
 676 0006 7860     		str	r0, [r7, #4]
 677 0008 0B46     		mov	r3, r1
 678 000a FB70     		strb	r3, [r7, #3]
 423:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 424:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 425:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 426:./Lib/Src/stm32f4xx_usart.c ****   
 427:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 679              		.loc 1 427 6
 680 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 681 000e 002B     		cmp	r3, #0
 682 0010 08D0     		beq	.L27
 428:./Lib/Src/stm32f4xx_usart.c ****   {
 429:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 430:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_UE;
 683              		.loc 1 430 11
 684 0012 7B68     		ldr	r3, [r7, #4]
 685 0014 9B89     		ldrh	r3, [r3, #12]	@ movhi
 686 0016 9BB2     		uxth	r3, r3
 687              		.loc 1 430 17
 688 0018 43F40053 		orr	r3, r3, #8192
 689 001c 9AB2     		uxth	r2, r3
 690 001e 7B68     		ldr	r3, [r7, #4]
 691 0020 9A81     		strh	r2, [r3, #12]	@ movhi
 431:./Lib/Src/stm32f4xx_usart.c ****   }
 432:./Lib/Src/stm32f4xx_usart.c ****   else
 433:./Lib/Src/stm32f4xx_usart.c ****   {
 434:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 435:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 436:./Lib/Src/stm32f4xx_usart.c ****   }
ARM GAS  /tmp/cc9pQZm7.s 			page 21


 437:./Lib/Src/stm32f4xx_usart.c **** }
 692              		.loc 1 437 1
 693 0022 07E0     		b	.L29
 694              	.L27:
 435:./Lib/Src/stm32f4xx_usart.c ****   }
 695              		.loc 1 435 11
 696 0024 7B68     		ldr	r3, [r7, #4]
 697 0026 9B89     		ldrh	r3, [r3, #12]	@ movhi
 698 0028 9BB2     		uxth	r3, r3
 435:./Lib/Src/stm32f4xx_usart.c ****   }
 699              		.loc 1 435 17
 700 002a 23F40053 		bic	r3, r3, #8192
 701 002e 9AB2     		uxth	r2, r3
 702 0030 7B68     		ldr	r3, [r7, #4]
 703 0032 9A81     		strh	r2, [r3, #12]	@ movhi
 704              	.L29:
 705              		.loc 1 437 1
 706 0034 00BF     		nop
 707 0036 0C37     		adds	r7, r7, #12
 708              		.cfi_def_cfa_offset 4
 709 0038 BD46     		mov	sp, r7
 710              		.cfi_def_cfa_register 13
 711              		@ sp needed
 712 003a 5DF8047B 		ldr	r7, [sp], #4
 713              		.cfi_restore 7
 714              		.cfi_def_cfa_offset 0
 715 003e 7047     		bx	lr
 716              		.cfi_endproc
 717              	.LFE128:
 719              		.section	.text.USART_SetPrescaler,"ax",%progbits
 720              		.align	1
 721              		.global	USART_SetPrescaler
 722              		.syntax unified
 723              		.thumb
 724              		.thumb_func
 726              	USART_SetPrescaler:
 727              	.LFB129:
 438:./Lib/Src/stm32f4xx_usart.c **** 
 439:./Lib/Src/stm32f4xx_usart.c **** /**
 440:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Sets the system clock prescaler.
 441:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 442:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 443:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock. 
 444:./Lib/Src/stm32f4xx_usart.c ****   * @note   The function is used for IrDA mode with UART4 and UART5.   
 445:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 446:./Lib/Src/stm32f4xx_usart.c ****   */
 447:./Lib/Src/stm32f4xx_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 448:./Lib/Src/stm32f4xx_usart.c **** { 
 728              		.loc 1 448 1
 729              		.cfi_startproc
 730              		@ args = 0, pretend = 0, frame = 8
 731              		@ frame_needed = 1, uses_anonymous_args = 0
 732              		@ link register save eliminated.
 733 0000 80B4     		push	{r7}
 734              		.cfi_def_cfa_offset 4
 735              		.cfi_offset 7, -4
 736 0002 83B0     		sub	sp, sp, #12
ARM GAS  /tmp/cc9pQZm7.s 			page 22


 737              		.cfi_def_cfa_offset 16
 738 0004 00AF     		add	r7, sp, #0
 739              		.cfi_def_cfa_register 7
 740 0006 7860     		str	r0, [r7, #4]
 741 0008 0B46     		mov	r3, r1
 742 000a FB70     		strb	r3, [r7, #3]
 449:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 450:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 451:./Lib/Src/stm32f4xx_usart.c ****   
 452:./Lib/Src/stm32f4xx_usart.c ****   /* Clear the USART prescaler */
 453:./Lib/Src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_GT;
 743              		.loc 1 453 9
 744 000c 7B68     		ldr	r3, [r7, #4]
 745 000e 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 746 0010 9BB2     		uxth	r3, r3
 747              		.loc 1 453 16
 748 0012 23F0FF03 		bic	r3, r3, #255
 749 0016 9AB2     		uxth	r2, r3
 750 0018 7B68     		ldr	r3, [r7, #4]
 751 001a 1A83     		strh	r2, [r3, #24]	@ movhi
 454:./Lib/Src/stm32f4xx_usart.c ****   /* Set the USART prescaler */
 455:./Lib/Src/stm32f4xx_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 752              		.loc 1 455 9
 753 001c 7B68     		ldr	r3, [r7, #4]
 754 001e 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 755 0020 9AB2     		uxth	r2, r3
 756              		.loc 1 455 16
 757 0022 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 758 0024 9BB2     		uxth	r3, r3
 759 0026 1343     		orrs	r3, r3, r2
 760 0028 9AB2     		uxth	r2, r3
 761 002a 7B68     		ldr	r3, [r7, #4]
 762 002c 1A83     		strh	r2, [r3, #24]	@ movhi
 456:./Lib/Src/stm32f4xx_usart.c **** }
 763              		.loc 1 456 1
 764 002e 00BF     		nop
 765 0030 0C37     		adds	r7, r7, #12
 766              		.cfi_def_cfa_offset 4
 767 0032 BD46     		mov	sp, r7
 768              		.cfi_def_cfa_register 13
 769              		@ sp needed
 770 0034 5DF8047B 		ldr	r7, [sp], #4
 771              		.cfi_restore 7
 772              		.cfi_def_cfa_offset 0
 773 0038 7047     		bx	lr
 774              		.cfi_endproc
 775              	.LFE129:
 777              		.section	.text.USART_OverSampling8Cmd,"ax",%progbits
 778              		.align	1
 779              		.global	USART_OverSampling8Cmd
 780              		.syntax unified
 781              		.thumb
 782              		.thumb_func
 784              	USART_OverSampling8Cmd:
 785              	.LFB130:
 457:./Lib/Src/stm32f4xx_usart.c **** 
 458:./Lib/Src/stm32f4xx_usart.c **** /**
ARM GAS  /tmp/cc9pQZm7.s 			page 23


 459:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 460:./Lib/Src/stm32f4xx_usart.c ****   * @note   This function has to be called before calling USART_Init() function
 461:./Lib/Src/stm32f4xx_usart.c ****   *         in order to have correct baudrate Divider value.
 462:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 463:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 464:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART 8x oversampling mode.
 465:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 466:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 467:./Lib/Src/stm32f4xx_usart.c ****   */
 468:./Lib/Src/stm32f4xx_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 469:./Lib/Src/stm32f4xx_usart.c **** {
 786              		.loc 1 469 1
 787              		.cfi_startproc
 788              		@ args = 0, pretend = 0, frame = 8
 789              		@ frame_needed = 1, uses_anonymous_args = 0
 790              		@ link register save eliminated.
 791 0000 80B4     		push	{r7}
 792              		.cfi_def_cfa_offset 4
 793              		.cfi_offset 7, -4
 794 0002 83B0     		sub	sp, sp, #12
 795              		.cfi_def_cfa_offset 16
 796 0004 00AF     		add	r7, sp, #0
 797              		.cfi_def_cfa_register 7
 798 0006 7860     		str	r0, [r7, #4]
 799 0008 0B46     		mov	r3, r1
 800 000a FB70     		strb	r3, [r7, #3]
 470:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 471:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 472:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 473:./Lib/Src/stm32f4xx_usart.c ****   
 474:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 801              		.loc 1 474 6
 802 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 803 000e 002B     		cmp	r3, #0
 804 0010 0AD0     		beq	.L32
 475:./Lib/Src/stm32f4xx_usart.c ****   {
 476:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 477:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_OVER8;
 805              		.loc 1 477 11
 806 0012 7B68     		ldr	r3, [r7, #4]
 807 0014 9B89     		ldrh	r3, [r3, #12]	@ movhi
 808 0016 9BB2     		uxth	r3, r3
 809              		.loc 1 477 17
 810 0018 6FEA4343 		mvn	r3, r3, lsl #17
 811 001c 6FEA5343 		mvn	r3, r3, lsr #17
 812 0020 9AB2     		uxth	r2, r3
 813 0022 7B68     		ldr	r3, [r7, #4]
 814 0024 9A81     		strh	r2, [r3, #12]	@ movhi
 478:./Lib/Src/stm32f4xx_usart.c ****   }
 479:./Lib/Src/stm32f4xx_usart.c ****   else
 480:./Lib/Src/stm32f4xx_usart.c ****   {
 481:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 482:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 483:./Lib/Src/stm32f4xx_usart.c ****   }
 484:./Lib/Src/stm32f4xx_usart.c **** }  
 815              		.loc 1 484 1
 816 0026 07E0     		b	.L34
ARM GAS  /tmp/cc9pQZm7.s 			page 24


 817              	.L32:
 482:./Lib/Src/stm32f4xx_usart.c ****   }
 818              		.loc 1 482 11
 819 0028 7B68     		ldr	r3, [r7, #4]
 820 002a 9B89     		ldrh	r3, [r3, #12]	@ movhi
 821 002c 9BB2     		uxth	r3, r3
 482:./Lib/Src/stm32f4xx_usart.c ****   }
 822              		.loc 1 482 17
 823 002e C3F30E03 		ubfx	r3, r3, #0, #15
 824 0032 9AB2     		uxth	r2, r3
 825 0034 7B68     		ldr	r3, [r7, #4]
 826 0036 9A81     		strh	r2, [r3, #12]	@ movhi
 827              	.L34:
 828              		.loc 1 484 1
 829 0038 00BF     		nop
 830 003a 0C37     		adds	r7, r7, #12
 831              		.cfi_def_cfa_offset 4
 832 003c BD46     		mov	sp, r7
 833              		.cfi_def_cfa_register 13
 834              		@ sp needed
 835 003e 5DF8047B 		ldr	r7, [sp], #4
 836              		.cfi_restore 7
 837              		.cfi_def_cfa_offset 0
 838 0042 7047     		bx	lr
 839              		.cfi_endproc
 840              	.LFE130:
 842              		.section	.text.USART_OneBitMethodCmd,"ax",%progbits
 843              		.align	1
 844              		.global	USART_OneBitMethodCmd
 845              		.syntax unified
 846              		.thumb
 847              		.thumb_func
 849              	USART_OneBitMethodCmd:
 850              	.LFB131:
 485:./Lib/Src/stm32f4xx_usart.c **** 
 486:./Lib/Src/stm32f4xx_usart.c **** /**
 487:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 488:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 489:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 490:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 491:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 492:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 493:./Lib/Src/stm32f4xx_usart.c ****   */
 494:./Lib/Src/stm32f4xx_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 495:./Lib/Src/stm32f4xx_usart.c **** {
 851              		.loc 1 495 1
 852              		.cfi_startproc
 853              		@ args = 0, pretend = 0, frame = 8
 854              		@ frame_needed = 1, uses_anonymous_args = 0
 855              		@ link register save eliminated.
 856 0000 80B4     		push	{r7}
 857              		.cfi_def_cfa_offset 4
 858              		.cfi_offset 7, -4
 859 0002 83B0     		sub	sp, sp, #12
 860              		.cfi_def_cfa_offset 16
 861 0004 00AF     		add	r7, sp, #0
 862              		.cfi_def_cfa_register 7
ARM GAS  /tmp/cc9pQZm7.s 			page 25


 863 0006 7860     		str	r0, [r7, #4]
 864 0008 0B46     		mov	r3, r1
 865 000a FB70     		strb	r3, [r7, #3]
 496:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 497:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 498:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 499:./Lib/Src/stm32f4xx_usart.c ****   
 500:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 866              		.loc 1 500 6
 867 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 868 000e 002B     		cmp	r3, #0
 869 0010 08D0     		beq	.L36
 501:./Lib/Src/stm32f4xx_usart.c ****   {
 502:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 503:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_ONEBIT;
 870              		.loc 1 503 11
 871 0012 7B68     		ldr	r3, [r7, #4]
 872 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 873 0016 9BB2     		uxth	r3, r3
 874              		.loc 1 503 17
 875 0018 43F40063 		orr	r3, r3, #2048
 876 001c 9AB2     		uxth	r2, r3
 877 001e 7B68     		ldr	r3, [r7, #4]
 878 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 504:./Lib/Src/stm32f4xx_usart.c ****   }
 505:./Lib/Src/stm32f4xx_usart.c ****   else
 506:./Lib/Src/stm32f4xx_usart.c ****   {
 507:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
 508:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 509:./Lib/Src/stm32f4xx_usart.c ****   }
 510:./Lib/Src/stm32f4xx_usart.c **** }
 879              		.loc 1 510 1
 880 0022 07E0     		b	.L38
 881              	.L36:
 508:./Lib/Src/stm32f4xx_usart.c ****   }
 882              		.loc 1 508 11
 883 0024 7B68     		ldr	r3, [r7, #4]
 884 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 885 0028 9BB2     		uxth	r3, r3
 508:./Lib/Src/stm32f4xx_usart.c ****   }
 886              		.loc 1 508 17
 887 002a 23F40063 		bic	r3, r3, #2048
 888 002e 9AB2     		uxth	r2, r3
 889 0030 7B68     		ldr	r3, [r7, #4]
 890 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 891              	.L38:
 892              		.loc 1 510 1
 893 0034 00BF     		nop
 894 0036 0C37     		adds	r7, r7, #12
 895              		.cfi_def_cfa_offset 4
 896 0038 BD46     		mov	sp, r7
 897              		.cfi_def_cfa_register 13
 898              		@ sp needed
 899 003a 5DF8047B 		ldr	r7, [sp], #4
 900              		.cfi_restore 7
 901              		.cfi_def_cfa_offset 0
 902 003e 7047     		bx	lr
ARM GAS  /tmp/cc9pQZm7.s 			page 26


 903              		.cfi_endproc
 904              	.LFE131:
 906              		.section	.text.USART_SendData,"ax",%progbits
 907              		.align	1
 908              		.global	USART_SendData
 909              		.syntax unified
 910              		.thumb
 911              		.thumb_func
 913              	USART_SendData:
 914              	.LFB132:
 511:./Lib/Src/stm32f4xx_usart.c **** 
 512:./Lib/Src/stm32f4xx_usart.c **** /**
 513:./Lib/Src/stm32f4xx_usart.c ****   * @}
 514:./Lib/Src/stm32f4xx_usart.c ****   */
 515:./Lib/Src/stm32f4xx_usart.c **** 
 516:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group2 Data transfers functions
 517:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   Data transfers functions 
 518:./Lib/Src/stm32f4xx_usart.c ****  *
 519:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
 520:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
 521:./Lib/Src/stm32f4xx_usart.c ****                       ##### Data transfers functions #####
 522:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
 523:./Lib/Src/stm32f4xx_usart.c ****     [..]
 524:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART data 
 525:./Lib/Src/stm32f4xx_usart.c ****     transfers.
 526:./Lib/Src/stm32f4xx_usart.c ****     [..]
 527:./Lib/Src/stm32f4xx_usart.c ****     During an USART reception, data shifts in least significant bit first through 
 528:./Lib/Src/stm32f4xx_usart.c ****     the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
 529:./Lib/Src/stm32f4xx_usart.c ****     between the internal bus and the received shift register.
 530:./Lib/Src/stm32f4xx_usart.c ****     [..]
 531:./Lib/Src/stm32f4xx_usart.c ****     When a transmission is taking place, a write instruction to the USART_DR register 
 532:./Lib/Src/stm32f4xx_usart.c ****     stores the data in the TDR register and which is copied in the shift register 
 533:./Lib/Src/stm32f4xx_usart.c ****     at the end of the current transmission.
 534:./Lib/Src/stm32f4xx_usart.c ****     [..]
 535:./Lib/Src/stm32f4xx_usart.c ****     The read access of the USART_DR register can be done using the USART_ReceiveData()
 536:./Lib/Src/stm32f4xx_usart.c ****     function and returns the RDR buffered value. Whereas a write access to the USART_DR 
 537:./Lib/Src/stm32f4xx_usart.c ****     can be done using USART_SendData() function and stores the written data into 
 538:./Lib/Src/stm32f4xx_usart.c ****     TDR buffer.
 539:./Lib/Src/stm32f4xx_usart.c **** 
 540:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
 541:./Lib/Src/stm32f4xx_usart.c ****   * @{
 542:./Lib/Src/stm32f4xx_usart.c ****   */
 543:./Lib/Src/stm32f4xx_usart.c **** 
 544:./Lib/Src/stm32f4xx_usart.c **** /**
 545:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 546:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 547:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 548:./Lib/Src/stm32f4xx_usart.c ****   * @param  Data: the data to transmit.
 549:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 550:./Lib/Src/stm32f4xx_usart.c ****   */
 551:./Lib/Src/stm32f4xx_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 552:./Lib/Src/stm32f4xx_usart.c **** {
 915              		.loc 1 552 1
 916              		.cfi_startproc
 917              		@ args = 0, pretend = 0, frame = 8
 918              		@ frame_needed = 1, uses_anonymous_args = 0
 919              		@ link register save eliminated.
ARM GAS  /tmp/cc9pQZm7.s 			page 27


 920 0000 80B4     		push	{r7}
 921              		.cfi_def_cfa_offset 4
 922              		.cfi_offset 7, -4
 923 0002 83B0     		sub	sp, sp, #12
 924              		.cfi_def_cfa_offset 16
 925 0004 00AF     		add	r7, sp, #0
 926              		.cfi_def_cfa_register 7
 927 0006 7860     		str	r0, [r7, #4]
 928 0008 0B46     		mov	r3, r1
 929 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 553:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 554:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 555:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 556:./Lib/Src/stm32f4xx_usart.c ****     
 557:./Lib/Src/stm32f4xx_usart.c ****   /* Transmit Data */
 558:./Lib/Src/stm32f4xx_usart.c ****   USARTx->DR = (Data & (uint16_t)0x01FF);
 930              		.loc 1 558 22
 931 000c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 932 000e C3F30803 		ubfx	r3, r3, #0, #9
 933 0012 9AB2     		uxth	r2, r3
 934              		.loc 1 558 14
 935 0014 7B68     		ldr	r3, [r7, #4]
 936 0016 9A80     		strh	r2, [r3, #4]	@ movhi
 559:./Lib/Src/stm32f4xx_usart.c **** }
 937              		.loc 1 559 1
 938 0018 00BF     		nop
 939 001a 0C37     		adds	r7, r7, #12
 940              		.cfi_def_cfa_offset 4
 941 001c BD46     		mov	sp, r7
 942              		.cfi_def_cfa_register 13
 943              		@ sp needed
 944 001e 5DF8047B 		ldr	r7, [sp], #4
 945              		.cfi_restore 7
 946              		.cfi_def_cfa_offset 0
 947 0022 7047     		bx	lr
 948              		.cfi_endproc
 949              	.LFE132:
 951              		.section	.text.USART_ReceiveData,"ax",%progbits
 952              		.align	1
 953              		.global	USART_ReceiveData
 954              		.syntax unified
 955              		.thumb
 956              		.thumb_func
 958              	USART_ReceiveData:
 959              	.LFB133:
 560:./Lib/Src/stm32f4xx_usart.c **** 
 561:./Lib/Src/stm32f4xx_usart.c **** /**
 562:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 563:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 564:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 565:./Lib/Src/stm32f4xx_usart.c ****   * @retval The received data.
 566:./Lib/Src/stm32f4xx_usart.c ****   */
 567:./Lib/Src/stm32f4xx_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 568:./Lib/Src/stm32f4xx_usart.c **** {
 960              		.loc 1 568 1
 961              		.cfi_startproc
 962              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/cc9pQZm7.s 			page 28


 963              		@ frame_needed = 1, uses_anonymous_args = 0
 964              		@ link register save eliminated.
 965 0000 80B4     		push	{r7}
 966              		.cfi_def_cfa_offset 4
 967              		.cfi_offset 7, -4
 968 0002 83B0     		sub	sp, sp, #12
 969              		.cfi_def_cfa_offset 16
 970 0004 00AF     		add	r7, sp, #0
 971              		.cfi_def_cfa_register 7
 972 0006 7860     		str	r0, [r7, #4]
 569:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 570:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 571:./Lib/Src/stm32f4xx_usart.c ****   
 572:./Lib/Src/stm32f4xx_usart.c ****   /* Receive Data */
 573:./Lib/Src/stm32f4xx_usart.c ****   return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 973              		.loc 1 573 27
 974 0008 7B68     		ldr	r3, [r7, #4]
 975 000a 9B88     		ldrh	r3, [r3, #4]	@ movhi
 976 000c 9BB2     		uxth	r3, r3
 977              		.loc 1 573 10
 978 000e C3F30803 		ubfx	r3, r3, #0, #9
 979 0012 9BB2     		uxth	r3, r3
 574:./Lib/Src/stm32f4xx_usart.c **** }
 980              		.loc 1 574 1
 981 0014 1846     		mov	r0, r3
 982 0016 0C37     		adds	r7, r7, #12
 983              		.cfi_def_cfa_offset 4
 984 0018 BD46     		mov	sp, r7
 985              		.cfi_def_cfa_register 13
 986              		@ sp needed
 987 001a 5DF8047B 		ldr	r7, [sp], #4
 988              		.cfi_restore 7
 989              		.cfi_def_cfa_offset 0
 990 001e 7047     		bx	lr
 991              		.cfi_endproc
 992              	.LFE133:
 994              		.section	.text.USART_SetAddress,"ax",%progbits
 995              		.align	1
 996              		.global	USART_SetAddress
 997              		.syntax unified
 998              		.thumb
 999              		.thumb_func
 1001              	USART_SetAddress:
 1002              	.LFB134:
 575:./Lib/Src/stm32f4xx_usart.c **** 
 576:./Lib/Src/stm32f4xx_usart.c **** /**
 577:./Lib/Src/stm32f4xx_usart.c ****   * @}
 578:./Lib/Src/stm32f4xx_usart.c ****   */
 579:./Lib/Src/stm32f4xx_usart.c **** 
 580:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group3 MultiProcessor Communication functions
 581:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   Multi-Processor Communication functions 
 582:./Lib/Src/stm32f4xx_usart.c ****  *
 583:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
 584:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
 585:./Lib/Src/stm32f4xx_usart.c ****               ##### Multi-Processor Communication functions #####
 586:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
 587:./Lib/Src/stm32f4xx_usart.c ****     [..]
ARM GAS  /tmp/cc9pQZm7.s 			page 29


 588:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 589:./Lib/Src/stm32f4xx_usart.c ****     multiprocessor communication.
 590:./Lib/Src/stm32f4xx_usart.c ****     [..]
 591:./Lib/Src/stm32f4xx_usart.c ****     For instance one of the USARTs can be the master, its TX output is connected 
 592:./Lib/Src/stm32f4xx_usart.c ****     to the RX input of the other USART. The others are slaves, their respective 
 593:./Lib/Src/stm32f4xx_usart.c ****     TX outputs are logically ANDed together and connected to the RX input of the 
 594:./Lib/Src/stm32f4xx_usart.c ****     master.
 595:./Lib/Src/stm32f4xx_usart.c ****     [..]
 596:./Lib/Src/stm32f4xx_usart.c ****     USART multiprocessor communication is possible through the following procedure:
 597:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode 
 598:./Lib/Src/stm32f4xx_usart.c ****           transmitter or Mode receiver and hardware flow control values using 
 599:./Lib/Src/stm32f4xx_usart.c ****           the USART_Init() function.
 600:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the USART address using the USART_SetAddress() function.
 601:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
 602:./Lib/Src/stm32f4xx_usart.c ****           using USART_WakeUpConfig() function only for the slaves.
 603:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 604:./Lib/Src/stm32f4xx_usart.c ****       (#) Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
 605:./Lib/Src/stm32f4xx_usart.c ****     [..]
 606:./Lib/Src/stm32f4xx_usart.c ****     The USART Slave exit from mute mode when receive the wake up condition.
 607:./Lib/Src/stm32f4xx_usart.c **** 
 608:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
 609:./Lib/Src/stm32f4xx_usart.c ****   * @{
 610:./Lib/Src/stm32f4xx_usart.c ****   */
 611:./Lib/Src/stm32f4xx_usart.c **** 
 612:./Lib/Src/stm32f4xx_usart.c **** /**
 613:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Sets the address of the USART node.
 614:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 615:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 616:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 617:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 618:./Lib/Src/stm32f4xx_usart.c ****   */
 619:./Lib/Src/stm32f4xx_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 620:./Lib/Src/stm32f4xx_usart.c **** {
 1003              		.loc 1 620 1
 1004              		.cfi_startproc
 1005              		@ args = 0, pretend = 0, frame = 8
 1006              		@ frame_needed = 1, uses_anonymous_args = 0
 1007              		@ link register save eliminated.
 1008 0000 80B4     		push	{r7}
 1009              		.cfi_def_cfa_offset 4
 1010              		.cfi_offset 7, -4
 1011 0002 83B0     		sub	sp, sp, #12
 1012              		.cfi_def_cfa_offset 16
 1013 0004 00AF     		add	r7, sp, #0
 1014              		.cfi_def_cfa_register 7
 1015 0006 7860     		str	r0, [r7, #4]
 1016 0008 0B46     		mov	r3, r1
 1017 000a FB70     		strb	r3, [r7, #3]
 621:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 622:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 623:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ADDRESS(USART_Address)); 
 624:./Lib/Src/stm32f4xx_usart.c ****     
 625:./Lib/Src/stm32f4xx_usart.c ****   /* Clear the USART address */
 626:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 1018              		.loc 1 626 9
 1019 000c 7B68     		ldr	r3, [r7, #4]
 1020 000e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
ARM GAS  /tmp/cc9pQZm7.s 			page 30


 1021 0010 9BB2     		uxth	r3, r3
 1022              		.loc 1 626 15
 1023 0012 23F00F03 		bic	r3, r3, #15
 1024 0016 9AB2     		uxth	r2, r3
 1025 0018 7B68     		ldr	r3, [r7, #4]
 1026 001a 1A82     		strh	r2, [r3, #16]	@ movhi
 627:./Lib/Src/stm32f4xx_usart.c ****   /* Set the USART address node */
 628:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_Address;
 1027              		.loc 1 628 9
 1028 001c 7B68     		ldr	r3, [r7, #4]
 1029 001e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1030 0020 9AB2     		uxth	r2, r3
 1031              		.loc 1 628 15
 1032 0022 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1033 0024 9BB2     		uxth	r3, r3
 1034 0026 1343     		orrs	r3, r3, r2
 1035 0028 9AB2     		uxth	r2, r3
 1036 002a 7B68     		ldr	r3, [r7, #4]
 1037 002c 1A82     		strh	r2, [r3, #16]	@ movhi
 629:./Lib/Src/stm32f4xx_usart.c **** }
 1038              		.loc 1 629 1
 1039 002e 00BF     		nop
 1040 0030 0C37     		adds	r7, r7, #12
 1041              		.cfi_def_cfa_offset 4
 1042 0032 BD46     		mov	sp, r7
 1043              		.cfi_def_cfa_register 13
 1044              		@ sp needed
 1045 0034 5DF8047B 		ldr	r7, [sp], #4
 1046              		.cfi_restore 7
 1047              		.cfi_def_cfa_offset 0
 1048 0038 7047     		bx	lr
 1049              		.cfi_endproc
 1050              	.LFE134:
 1052              		.section	.text.USART_ReceiverWakeUpCmd,"ax",%progbits
 1053              		.align	1
 1054              		.global	USART_ReceiverWakeUpCmd
 1055              		.syntax unified
 1056              		.thumb
 1057              		.thumb_func
 1059              	USART_ReceiverWakeUpCmd:
 1060              	.LFB135:
 630:./Lib/Src/stm32f4xx_usart.c **** 
 631:./Lib/Src/stm32f4xx_usart.c **** /**
 632:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Determines if the USART is in mute mode or not.
 633:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 634:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 635:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART mute mode.
 636:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 637:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 638:./Lib/Src/stm32f4xx_usart.c ****   */
 639:./Lib/Src/stm32f4xx_usart.c **** void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 640:./Lib/Src/stm32f4xx_usart.c **** {
 1061              		.loc 1 640 1
 1062              		.cfi_startproc
 1063              		@ args = 0, pretend = 0, frame = 8
 1064              		@ frame_needed = 1, uses_anonymous_args = 0
 1065              		@ link register save eliminated.
ARM GAS  /tmp/cc9pQZm7.s 			page 31


 1066 0000 80B4     		push	{r7}
 1067              		.cfi_def_cfa_offset 4
 1068              		.cfi_offset 7, -4
 1069 0002 83B0     		sub	sp, sp, #12
 1070              		.cfi_def_cfa_offset 16
 1071 0004 00AF     		add	r7, sp, #0
 1072              		.cfi_def_cfa_register 7
 1073 0006 7860     		str	r0, [r7, #4]
 1074 0008 0B46     		mov	r3, r1
 1075 000a FB70     		strb	r3, [r7, #3]
 641:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 642:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 643:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 644:./Lib/Src/stm32f4xx_usart.c ****   
 645:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1076              		.loc 1 645 6
 1077 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1078 000e 002B     		cmp	r3, #0
 1079 0010 08D0     		beq	.L44
 646:./Lib/Src/stm32f4xx_usart.c ****   {
 647:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
 648:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR1 |= USART_CR1_RWU;
 1080              		.loc 1 648 11
 1081 0012 7B68     		ldr	r3, [r7, #4]
 1082 0014 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1083 0016 9BB2     		uxth	r3, r3
 1084              		.loc 1 648 17
 1085 0018 43F00203 		orr	r3, r3, #2
 1086 001c 9AB2     		uxth	r2, r3
 1087 001e 7B68     		ldr	r3, [r7, #4]
 1088 0020 9A81     		strh	r2, [r3, #12]	@ movhi
 649:./Lib/Src/stm32f4xx_usart.c ****   }
 650:./Lib/Src/stm32f4xx_usart.c ****   else
 651:./Lib/Src/stm32f4xx_usart.c ****   {
 652:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
 653:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 654:./Lib/Src/stm32f4xx_usart.c ****   }
 655:./Lib/Src/stm32f4xx_usart.c **** }
 1089              		.loc 1 655 1
 1090 0022 07E0     		b	.L46
 1091              	.L44:
 653:./Lib/Src/stm32f4xx_usart.c ****   }
 1092              		.loc 1 653 11
 1093 0024 7B68     		ldr	r3, [r7, #4]
 1094 0026 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1095 0028 9BB2     		uxth	r3, r3
 653:./Lib/Src/stm32f4xx_usart.c ****   }
 1096              		.loc 1 653 17
 1097 002a 23F00203 		bic	r3, r3, #2
 1098 002e 9AB2     		uxth	r2, r3
 1099 0030 7B68     		ldr	r3, [r7, #4]
 1100 0032 9A81     		strh	r2, [r3, #12]	@ movhi
 1101              	.L46:
 1102              		.loc 1 655 1
 1103 0034 00BF     		nop
 1104 0036 0C37     		adds	r7, r7, #12
 1105              		.cfi_def_cfa_offset 4
ARM GAS  /tmp/cc9pQZm7.s 			page 32


 1106 0038 BD46     		mov	sp, r7
 1107              		.cfi_def_cfa_register 13
 1108              		@ sp needed
 1109 003a 5DF8047B 		ldr	r7, [sp], #4
 1110              		.cfi_restore 7
 1111              		.cfi_def_cfa_offset 0
 1112 003e 7047     		bx	lr
 1113              		.cfi_endproc
 1114              	.LFE135:
 1116              		.section	.text.USART_WakeUpConfig,"ax",%progbits
 1117              		.align	1
 1118              		.global	USART_WakeUpConfig
 1119              		.syntax unified
 1120              		.thumb
 1121              		.thumb_func
 1123              	USART_WakeUpConfig:
 1124              	.LFB136:
 656:./Lib/Src/stm32f4xx_usart.c **** /**
 657:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Selects the USART WakeUp method.
 658:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 659:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 660:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
 661:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
 662:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
 663:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
 664:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 665:./Lib/Src/stm32f4xx_usart.c ****   */
 666:./Lib/Src/stm32f4xx_usart.c **** void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
 667:./Lib/Src/stm32f4xx_usart.c **** {
 1125              		.loc 1 667 1
 1126              		.cfi_startproc
 1127              		@ args = 0, pretend = 0, frame = 8
 1128              		@ frame_needed = 1, uses_anonymous_args = 0
 1129              		@ link register save eliminated.
 1130 0000 80B4     		push	{r7}
 1131              		.cfi_def_cfa_offset 4
 1132              		.cfi_offset 7, -4
 1133 0002 83B0     		sub	sp, sp, #12
 1134              		.cfi_def_cfa_offset 16
 1135 0004 00AF     		add	r7, sp, #0
 1136              		.cfi_def_cfa_register 7
 1137 0006 7860     		str	r0, [r7, #4]
 1138 0008 0B46     		mov	r3, r1
 1139 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 668:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 669:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 670:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_WAKEUP(USART_WakeUp));
 671:./Lib/Src/stm32f4xx_usart.c ****   
 672:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 1140              		.loc 1 672 9
 1141 000c 7B68     		ldr	r3, [r7, #4]
 1142 000e 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1143 0010 9BB2     		uxth	r3, r3
 1144              		.loc 1 672 15
 1145 0012 23F40063 		bic	r3, r3, #2048
 1146 0016 9AB2     		uxth	r2, r3
 1147 0018 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/cc9pQZm7.s 			page 33


 1148 001a 9A81     		strh	r2, [r3, #12]	@ movhi
 673:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 1149              		.loc 1 673 9
 1150 001c 7B68     		ldr	r3, [r7, #4]
 1151 001e 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1152 0020 9AB2     		uxth	r2, r3
 1153              		.loc 1 673 15
 1154 0022 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1155 0024 1343     		orrs	r3, r3, r2
 1156 0026 9AB2     		uxth	r2, r3
 1157 0028 7B68     		ldr	r3, [r7, #4]
 1158 002a 9A81     		strh	r2, [r3, #12]	@ movhi
 674:./Lib/Src/stm32f4xx_usart.c **** }
 1159              		.loc 1 674 1
 1160 002c 00BF     		nop
 1161 002e 0C37     		adds	r7, r7, #12
 1162              		.cfi_def_cfa_offset 4
 1163 0030 BD46     		mov	sp, r7
 1164              		.cfi_def_cfa_register 13
 1165              		@ sp needed
 1166 0032 5DF8047B 		ldr	r7, [sp], #4
 1167              		.cfi_restore 7
 1168              		.cfi_def_cfa_offset 0
 1169 0036 7047     		bx	lr
 1170              		.cfi_endproc
 1171              	.LFE136:
 1173              		.section	.text.USART_LINBreakDetectLengthConfig,"ax",%progbits
 1174              		.align	1
 1175              		.global	USART_LINBreakDetectLengthConfig
 1176              		.syntax unified
 1177              		.thumb
 1178              		.thumb_func
 1180              	USART_LINBreakDetectLengthConfig:
 1181              	.LFB137:
 675:./Lib/Src/stm32f4xx_usart.c **** 
 676:./Lib/Src/stm32f4xx_usart.c **** /**
 677:./Lib/Src/stm32f4xx_usart.c ****   * @}
 678:./Lib/Src/stm32f4xx_usart.c ****   */
 679:./Lib/Src/stm32f4xx_usart.c **** 
 680:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group4 LIN mode functions
 681:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   LIN mode functions 
 682:./Lib/Src/stm32f4xx_usart.c ****  *
 683:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
 684:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
 685:./Lib/Src/stm32f4xx_usart.c ****                         ##### LIN mode functions #####
 686:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
 687:./Lib/Src/stm32f4xx_usart.c ****     [..]
 688:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART LIN 
 689:./Lib/Src/stm32f4xx_usart.c ****     Mode communication.
 690:./Lib/Src/stm32f4xx_usart.c ****     [..]
 691:./Lib/Src/stm32f4xx_usart.c ****     In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
 692:./Lib/Src/stm32f4xx_usart.c ****     the LIN standard.
 693:./Lib/Src/stm32f4xx_usart.c ****     [..]
 694:./Lib/Src/stm32f4xx_usart.c ****     Only this LIN Feature is supported by the USART IP:
 695:./Lib/Src/stm32f4xx_usart.c ****       (+) LIN Master Synchronous Break send capability and LIN slave break detection
 696:./Lib/Src/stm32f4xx_usart.c ****           capability :  13-bit break generation and 10/11 bit break detection
 697:./Lib/Src/stm32f4xx_usart.c **** 
ARM GAS  /tmp/cc9pQZm7.s 			page 34


 698:./Lib/Src/stm32f4xx_usart.c ****     [..]
 699:./Lib/Src/stm32f4xx_usart.c ****     USART LIN Master transmitter communication is possible through the following 
 700:./Lib/Src/stm32f4xx_usart.c ****     procedure:
 701:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 702:./Lib/Src/stm32f4xx_usart.c ****         Mode transmitter or Mode receiver and hardware flow control values using 
 703:./Lib/Src/stm32f4xx_usart.c ****         the USART_Init() function.
 704:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 705:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the LIN mode using the USART_LINCmd() function.
 706:./Lib/Src/stm32f4xx_usart.c ****       (#) Send the break character using USART_SendBreak() function.
 707:./Lib/Src/stm32f4xx_usart.c ****     [..]
 708:./Lib/Src/stm32f4xx_usart.c ****     USART LIN Master receiver communication is possible through the following procedure:
 709:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
 710:./Lib/Src/stm32f4xx_usart.c ****           Mode transmitter or Mode receiver and hardware flow control values using 
 711:./Lib/Src/stm32f4xx_usart.c ****           the USART_Init() function.
 712:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 713:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the break detection length using the USART_LINBreakDetectLengthConfig()
 714:./Lib/Src/stm32f4xx_usart.c ****           function.
 715:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the LIN mode using the USART_LINCmd() function.
 716:./Lib/Src/stm32f4xx_usart.c **** 
 717:./Lib/Src/stm32f4xx_usart.c ****       -@- In LIN mode, the following bits must be kept cleared:
 718:./Lib/Src/stm32f4xx_usart.c ****        (+@) CLKEN in the USART_CR2 register,
 719:./Lib/Src/stm32f4xx_usart.c ****        (+@) STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
 720:./Lib/Src/stm32f4xx_usart.c **** 
 721:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
 722:./Lib/Src/stm32f4xx_usart.c ****   * @{
 723:./Lib/Src/stm32f4xx_usart.c ****   */
 724:./Lib/Src/stm32f4xx_usart.c **** 
 725:./Lib/Src/stm32f4xx_usart.c **** /**
 726:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Sets the USART LIN Break detection length.
 727:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 728:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 729:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
 730:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
 731:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
 732:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
 733:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 734:./Lib/Src/stm32f4xx_usart.c ****   */
 735:./Lib/Src/stm32f4xx_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
 736:./Lib/Src/stm32f4xx_usart.c **** {
 1182              		.loc 1 736 1
 1183              		.cfi_startproc
 1184              		@ args = 0, pretend = 0, frame = 8
 1185              		@ frame_needed = 1, uses_anonymous_args = 0
 1186              		@ link register save eliminated.
 1187 0000 80B4     		push	{r7}
 1188              		.cfi_def_cfa_offset 4
 1189              		.cfi_offset 7, -4
 1190 0002 83B0     		sub	sp, sp, #12
 1191              		.cfi_def_cfa_offset 16
 1192 0004 00AF     		add	r7, sp, #0
 1193              		.cfi_def_cfa_register 7
 1194 0006 7860     		str	r0, [r7, #4]
 1195 0008 0B46     		mov	r3, r1
 1196 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 737:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 738:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 739:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
ARM GAS  /tmp/cc9pQZm7.s 			page 35


 740:./Lib/Src/stm32f4xx_usart.c ****   
 741:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 1197              		.loc 1 741 9
 1198 000c 7B68     		ldr	r3, [r7, #4]
 1199 000e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1200 0010 9BB2     		uxth	r3, r3
 1201              		.loc 1 741 15
 1202 0012 23F02003 		bic	r3, r3, #32
 1203 0016 9AB2     		uxth	r2, r3
 1204 0018 7B68     		ldr	r3, [r7, #4]
 1205 001a 1A82     		strh	r2, [r3, #16]	@ movhi
 742:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 1206              		.loc 1 742 9
 1207 001c 7B68     		ldr	r3, [r7, #4]
 1208 001e 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1209 0020 9AB2     		uxth	r2, r3
 1210              		.loc 1 742 15
 1211 0022 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1212 0024 1343     		orrs	r3, r3, r2
 1213 0026 9AB2     		uxth	r2, r3
 1214 0028 7B68     		ldr	r3, [r7, #4]
 1215 002a 1A82     		strh	r2, [r3, #16]	@ movhi
 743:./Lib/Src/stm32f4xx_usart.c **** }
 1216              		.loc 1 743 1
 1217 002c 00BF     		nop
 1218 002e 0C37     		adds	r7, r7, #12
 1219              		.cfi_def_cfa_offset 4
 1220 0030 BD46     		mov	sp, r7
 1221              		.cfi_def_cfa_register 13
 1222              		@ sp needed
 1223 0032 5DF8047B 		ldr	r7, [sp], #4
 1224              		.cfi_restore 7
 1225              		.cfi_def_cfa_offset 0
 1226 0036 7047     		bx	lr
 1227              		.cfi_endproc
 1228              	.LFE137:
 1230              		.section	.text.USART_LINCmd,"ax",%progbits
 1231              		.align	1
 1232              		.global	USART_LINCmd
 1233              		.syntax unified
 1234              		.thumb
 1235              		.thumb_func
 1237              	USART_LINCmd:
 1238              	.LFB138:
 744:./Lib/Src/stm32f4xx_usart.c **** 
 745:./Lib/Src/stm32f4xx_usart.c **** /**
 746:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's LIN mode.
 747:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 748:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 749:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART LIN mode.
 750:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 751:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 752:./Lib/Src/stm32f4xx_usart.c ****   */
 753:./Lib/Src/stm32f4xx_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 754:./Lib/Src/stm32f4xx_usart.c **** {
 1239              		.loc 1 754 1
 1240              		.cfi_startproc
ARM GAS  /tmp/cc9pQZm7.s 			page 36


 1241              		@ args = 0, pretend = 0, frame = 8
 1242              		@ frame_needed = 1, uses_anonymous_args = 0
 1243              		@ link register save eliminated.
 1244 0000 80B4     		push	{r7}
 1245              		.cfi_def_cfa_offset 4
 1246              		.cfi_offset 7, -4
 1247 0002 83B0     		sub	sp, sp, #12
 1248              		.cfi_def_cfa_offset 16
 1249 0004 00AF     		add	r7, sp, #0
 1250              		.cfi_def_cfa_register 7
 1251 0006 7860     		str	r0, [r7, #4]
 1252 0008 0B46     		mov	r3, r1
 1253 000a FB70     		strb	r3, [r7, #3]
 755:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 756:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 757:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 758:./Lib/Src/stm32f4xx_usart.c ****   
 759:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1254              		.loc 1 759 6
 1255 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1256 000e 002B     		cmp	r3, #0
 1257 0010 08D0     		beq	.L50
 760:./Lib/Src/stm32f4xx_usart.c ****   {
 761:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 762:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR2 |= USART_CR2_LINEN;
 1258              		.loc 1 762 11
 1259 0012 7B68     		ldr	r3, [r7, #4]
 1260 0014 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1261 0016 9BB2     		uxth	r3, r3
 1262              		.loc 1 762 17
 1263 0018 43F48043 		orr	r3, r3, #16384
 1264 001c 9AB2     		uxth	r2, r3
 1265 001e 7B68     		ldr	r3, [r7, #4]
 1266 0020 1A82     		strh	r2, [r3, #16]	@ movhi
 763:./Lib/Src/stm32f4xx_usart.c ****   }
 764:./Lib/Src/stm32f4xx_usart.c ****   else
 765:./Lib/Src/stm32f4xx_usart.c ****   {
 766:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
 767:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 768:./Lib/Src/stm32f4xx_usart.c ****   }
 769:./Lib/Src/stm32f4xx_usart.c **** }
 1267              		.loc 1 769 1
 1268 0022 07E0     		b	.L52
 1269              	.L50:
 767:./Lib/Src/stm32f4xx_usart.c ****   }
 1270              		.loc 1 767 11
 1271 0024 7B68     		ldr	r3, [r7, #4]
 1272 0026 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1273 0028 9BB2     		uxth	r3, r3
 767:./Lib/Src/stm32f4xx_usart.c ****   }
 1274              		.loc 1 767 17
 1275 002a 23F48043 		bic	r3, r3, #16384
 1276 002e 9AB2     		uxth	r2, r3
 1277 0030 7B68     		ldr	r3, [r7, #4]
 1278 0032 1A82     		strh	r2, [r3, #16]	@ movhi
 1279              	.L52:
 1280              		.loc 1 769 1
ARM GAS  /tmp/cc9pQZm7.s 			page 37


 1281 0034 00BF     		nop
 1282 0036 0C37     		adds	r7, r7, #12
 1283              		.cfi_def_cfa_offset 4
 1284 0038 BD46     		mov	sp, r7
 1285              		.cfi_def_cfa_register 13
 1286              		@ sp needed
 1287 003a 5DF8047B 		ldr	r7, [sp], #4
 1288              		.cfi_restore 7
 1289              		.cfi_def_cfa_offset 0
 1290 003e 7047     		bx	lr
 1291              		.cfi_endproc
 1292              	.LFE138:
 1294              		.section	.text.USART_SendBreak,"ax",%progbits
 1295              		.align	1
 1296              		.global	USART_SendBreak
 1297              		.syntax unified
 1298              		.thumb
 1299              		.thumb_func
 1301              	USART_SendBreak:
 1302              	.LFB139:
 770:./Lib/Src/stm32f4xx_usart.c **** 
 771:./Lib/Src/stm32f4xx_usart.c **** /**
 772:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Transmits break characters.
 773:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 774:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 775:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 776:./Lib/Src/stm32f4xx_usart.c ****   */
 777:./Lib/Src/stm32f4xx_usart.c **** void USART_SendBreak(USART_TypeDef* USARTx)
 778:./Lib/Src/stm32f4xx_usart.c **** {
 1303              		.loc 1 778 1
 1304              		.cfi_startproc
 1305              		@ args = 0, pretend = 0, frame = 8
 1306              		@ frame_needed = 1, uses_anonymous_args = 0
 1307              		@ link register save eliminated.
 1308 0000 80B4     		push	{r7}
 1309              		.cfi_def_cfa_offset 4
 1310              		.cfi_offset 7, -4
 1311 0002 83B0     		sub	sp, sp, #12
 1312              		.cfi_def_cfa_offset 16
 1313 0004 00AF     		add	r7, sp, #0
 1314              		.cfi_def_cfa_register 7
 1315 0006 7860     		str	r0, [r7, #4]
 779:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 780:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 781:./Lib/Src/stm32f4xx_usart.c ****   
 782:./Lib/Src/stm32f4xx_usart.c ****   /* Send break characters */
 783:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR1 |= USART_CR1_SBK;
 1316              		.loc 1 783 9
 1317 0008 7B68     		ldr	r3, [r7, #4]
 1318 000a 9B89     		ldrh	r3, [r3, #12]	@ movhi
 1319 000c 9BB2     		uxth	r3, r3
 1320              		.loc 1 783 15
 1321 000e 43F00103 		orr	r3, r3, #1
 1322 0012 9AB2     		uxth	r2, r3
 1323 0014 7B68     		ldr	r3, [r7, #4]
 1324 0016 9A81     		strh	r2, [r3, #12]	@ movhi
 784:./Lib/Src/stm32f4xx_usart.c **** }
ARM GAS  /tmp/cc9pQZm7.s 			page 38


 1325              		.loc 1 784 1
 1326 0018 00BF     		nop
 1327 001a 0C37     		adds	r7, r7, #12
 1328              		.cfi_def_cfa_offset 4
 1329 001c BD46     		mov	sp, r7
 1330              		.cfi_def_cfa_register 13
 1331              		@ sp needed
 1332 001e 5DF8047B 		ldr	r7, [sp], #4
 1333              		.cfi_restore 7
 1334              		.cfi_def_cfa_offset 0
 1335 0022 7047     		bx	lr
 1336              		.cfi_endproc
 1337              	.LFE139:
 1339              		.section	.text.USART_HalfDuplexCmd,"ax",%progbits
 1340              		.align	1
 1341              		.global	USART_HalfDuplexCmd
 1342              		.syntax unified
 1343              		.thumb
 1344              		.thumb_func
 1346              	USART_HalfDuplexCmd:
 1347              	.LFB140:
 785:./Lib/Src/stm32f4xx_usart.c **** 
 786:./Lib/Src/stm32f4xx_usart.c **** /**
 787:./Lib/Src/stm32f4xx_usart.c ****   * @}
 788:./Lib/Src/stm32f4xx_usart.c ****   */
 789:./Lib/Src/stm32f4xx_usart.c **** 
 790:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group5 Halfduplex mode function
 791:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   Half-duplex mode function 
 792:./Lib/Src/stm32f4xx_usart.c ****  *
 793:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
 794:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
 795:./Lib/Src/stm32f4xx_usart.c ****                     ##### Half-duplex mode function #####
 796:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
 797:./Lib/Src/stm32f4xx_usart.c ****     [..]
 798:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 799:./Lib/Src/stm32f4xx_usart.c ****     Half-duplex communication.
 800:./Lib/Src/stm32f4xx_usart.c ****     [..]
 801:./Lib/Src/stm32f4xx_usart.c ****     The USART can be configured to follow a single-wire half-duplex protocol where 
 802:./Lib/Src/stm32f4xx_usart.c ****     the TX and RX lines are internally connected.
 803:./Lib/Src/stm32f4xx_usart.c ****     [..]
 804:./Lib/Src/stm32f4xx_usart.c ****     USART Half duplex communication is possible through the following procedure:
 805:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
 806:./Lib/Src/stm32f4xx_usart.c ****           or Mode receiver and hardware flow control values using the USART_Init()
 807:./Lib/Src/stm32f4xx_usart.c ****           function.
 808:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the USART address using the USART_SetAddress() function.
 809:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
 810:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the half duplex mode using USART_HalfDuplexCmd() function.
 811:./Lib/Src/stm32f4xx_usart.c **** 
 812:./Lib/Src/stm32f4xx_usart.c **** 
 813:./Lib/Src/stm32f4xx_usart.c ****     -@- The RX pin is no longer used
 814:./Lib/Src/stm32f4xx_usart.c ****     -@- In Half-duplex mode the following bits must be kept cleared:
 815:./Lib/Src/stm32f4xx_usart.c ****       (+@) LINEN and CLKEN bits in the USART_CR2 register.
 816:./Lib/Src/stm32f4xx_usart.c ****       (+@) SCEN and IREN bits in the USART_CR3 register.
 817:./Lib/Src/stm32f4xx_usart.c **** 
 818:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
 819:./Lib/Src/stm32f4xx_usart.c ****   * @{
 820:./Lib/Src/stm32f4xx_usart.c ****   */
ARM GAS  /tmp/cc9pQZm7.s 			page 39


 821:./Lib/Src/stm32f4xx_usart.c **** 
 822:./Lib/Src/stm32f4xx_usart.c **** /**
 823:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Half Duplex communication.
 824:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
 825:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 826:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the USART Communication.
 827:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
 828:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 829:./Lib/Src/stm32f4xx_usart.c ****   */
 830:./Lib/Src/stm32f4xx_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 831:./Lib/Src/stm32f4xx_usart.c **** {
 1348              		.loc 1 831 1
 1349              		.cfi_startproc
 1350              		@ args = 0, pretend = 0, frame = 8
 1351              		@ frame_needed = 1, uses_anonymous_args = 0
 1352              		@ link register save eliminated.
 1353 0000 80B4     		push	{r7}
 1354              		.cfi_def_cfa_offset 4
 1355              		.cfi_offset 7, -4
 1356 0002 83B0     		sub	sp, sp, #12
 1357              		.cfi_def_cfa_offset 16
 1358 0004 00AF     		add	r7, sp, #0
 1359              		.cfi_def_cfa_register 7
 1360 0006 7860     		str	r0, [r7, #4]
 1361 0008 0B46     		mov	r3, r1
 1362 000a FB70     		strb	r3, [r7, #3]
 832:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 833:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 834:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 835:./Lib/Src/stm32f4xx_usart.c ****   
 836:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1363              		.loc 1 836 6
 1364 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1365 000e 002B     		cmp	r3, #0
 1366 0010 08D0     		beq	.L55
 837:./Lib/Src/stm32f4xx_usart.c ****   {
 838:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 839:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_HDSEL;
 1367              		.loc 1 839 11
 1368 0012 7B68     		ldr	r3, [r7, #4]
 1369 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1370 0016 9BB2     		uxth	r3, r3
 1371              		.loc 1 839 17
 1372 0018 43F00803 		orr	r3, r3, #8
 1373 001c 9AB2     		uxth	r2, r3
 1374 001e 7B68     		ldr	r3, [r7, #4]
 1375 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 840:./Lib/Src/stm32f4xx_usart.c ****   }
 841:./Lib/Src/stm32f4xx_usart.c ****   else
 842:./Lib/Src/stm32f4xx_usart.c ****   {
 843:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
 844:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 845:./Lib/Src/stm32f4xx_usart.c ****   }
 846:./Lib/Src/stm32f4xx_usart.c **** }
 1376              		.loc 1 846 1
 1377 0022 07E0     		b	.L57
 1378              	.L55:
ARM GAS  /tmp/cc9pQZm7.s 			page 40


 844:./Lib/Src/stm32f4xx_usart.c ****   }
 1379              		.loc 1 844 11
 1380 0024 7B68     		ldr	r3, [r7, #4]
 1381 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1382 0028 9BB2     		uxth	r3, r3
 844:./Lib/Src/stm32f4xx_usart.c ****   }
 1383              		.loc 1 844 17
 1384 002a 23F00803 		bic	r3, r3, #8
 1385 002e 9AB2     		uxth	r2, r3
 1386 0030 7B68     		ldr	r3, [r7, #4]
 1387 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1388              	.L57:
 1389              		.loc 1 846 1
 1390 0034 00BF     		nop
 1391 0036 0C37     		adds	r7, r7, #12
 1392              		.cfi_def_cfa_offset 4
 1393 0038 BD46     		mov	sp, r7
 1394              		.cfi_def_cfa_register 13
 1395              		@ sp needed
 1396 003a 5DF8047B 		ldr	r7, [sp], #4
 1397              		.cfi_restore 7
 1398              		.cfi_def_cfa_offset 0
 1399 003e 7047     		bx	lr
 1400              		.cfi_endproc
 1401              	.LFE140:
 1403              		.section	.text.USART_SetGuardTime,"ax",%progbits
 1404              		.align	1
 1405              		.global	USART_SetGuardTime
 1406              		.syntax unified
 1407              		.thumb
 1408              		.thumb_func
 1410              	USART_SetGuardTime:
 1411              	.LFB141:
 847:./Lib/Src/stm32f4xx_usart.c **** 
 848:./Lib/Src/stm32f4xx_usart.c **** /**
 849:./Lib/Src/stm32f4xx_usart.c ****   * @}
 850:./Lib/Src/stm32f4xx_usart.c ****   */
 851:./Lib/Src/stm32f4xx_usart.c **** 
 852:./Lib/Src/stm32f4xx_usart.c **** 
 853:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group6 Smartcard mode functions
 854:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   Smartcard mode functions 
 855:./Lib/Src/stm32f4xx_usart.c ****  *
 856:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
 857:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
 858:./Lib/Src/stm32f4xx_usart.c ****                               ##### Smartcard mode functions #####
 859:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
 860:./Lib/Src/stm32f4xx_usart.c ****     [..]
 861:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 862:./Lib/Src/stm32f4xx_usart.c ****     Smartcard communication.
 863:./Lib/Src/stm32f4xx_usart.c ****     [..]
 864:./Lib/Src/stm32f4xx_usart.c ****     The Smartcard interface is designed to support asynchronous protocol Smartcards as
 865:./Lib/Src/stm32f4xx_usart.c ****     defined in the ISO 7816-3 standard.
 866:./Lib/Src/stm32f4xx_usart.c ****     [..]
 867:./Lib/Src/stm32f4xx_usart.c ****     The USART can provide a clock to the smartcard through the SCLK output.
 868:./Lib/Src/stm32f4xx_usart.c ****     In smartcard mode, SCLK is not associated to the communication but is simply derived 
 869:./Lib/Src/stm32f4xx_usart.c ****     from the internal peripheral input clock through a 5-bit prescaler.
 870:./Lib/Src/stm32f4xx_usart.c ****     [..]
ARM GAS  /tmp/cc9pQZm7.s 			page 41


 871:./Lib/Src/stm32f4xx_usart.c ****     Smartcard communication is possible through the following procedure:
 872:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
 873:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
 874:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the USART clock using the USART_ClockInit() function as following:
 875:./Lib/Src/stm32f4xx_usart.c ****         (++) USART Clock enabled
 876:./Lib/Src/stm32f4xx_usart.c ****         (++) USART CPOL Low
 877:./Lib/Src/stm32f4xx_usart.c ****         (++) USART CPHA on first edge
 878:./Lib/Src/stm32f4xx_usart.c ****         (++) USART Last Bit Clock Enabled
 879:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the Smartcard interface using the USART_Init() function as following:
 880:./Lib/Src/stm32f4xx_usart.c ****         (++) Word Length = 9 Bits
 881:./Lib/Src/stm32f4xx_usart.c ****         (++) 1.5 Stop Bit
 882:./Lib/Src/stm32f4xx_usart.c ****         (++) Even parity
 883:./Lib/Src/stm32f4xx_usart.c ****         (++) BaudRate = 12096 baud
 884:./Lib/Src/stm32f4xx_usart.c ****         (++) Hardware flow control disabled (RTS and CTS signals)
 885:./Lib/Src/stm32f4xx_usart.c ****         (++) Tx and Rx enabled
 886:./Lib/Src/stm32f4xx_usart.c ****       (#) POptionally you can enable the parity error interrupt using the USART_ITConfig()
 887:./Lib/Src/stm32f4xx_usart.c ****           function
 888:./Lib/Src/stm32f4xx_usart.c ****       (#) PEnable the USART using the USART_Cmd() function.
 889:./Lib/Src/stm32f4xx_usart.c ****       (#) PEnable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
 890:./Lib/Src/stm32f4xx_usart.c ****       (#) PEnable the Smartcard interface using the USART_SmartCardCmd() function.
 891:./Lib/Src/stm32f4xx_usart.c **** 
 892:./Lib/Src/stm32f4xx_usart.c ****     Please refer to the ISO 7816-3 specification for more details.
 893:./Lib/Src/stm32f4xx_usart.c **** 
 894:./Lib/Src/stm32f4xx_usart.c ****       -@- It is also possible to choose 0.5 stop bit for receiving but it is recommended 
 895:./Lib/Src/stm32f4xx_usart.c ****           to use 1.5 stop bits for both transmitting and receiving to avoid switching 
 896:./Lib/Src/stm32f4xx_usart.c ****           between the two configurations.
 897:./Lib/Src/stm32f4xx_usart.c ****       -@- In smartcard mode, the following bits must be kept cleared:
 898:./Lib/Src/stm32f4xx_usart.c ****         (+@) LINEN bit in the USART_CR2 register.
 899:./Lib/Src/stm32f4xx_usart.c ****         (+@) HDSEL and IREN bits in the USART_CR3 register.
 900:./Lib/Src/stm32f4xx_usart.c ****       -@- Smartcard mode is available on USART peripherals only (not available on UART4 
 901:./Lib/Src/stm32f4xx_usart.c ****           and UART5 peripherals).
 902:./Lib/Src/stm32f4xx_usart.c **** 
 903:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
 904:./Lib/Src/stm32f4xx_usart.c ****   * @{
 905:./Lib/Src/stm32f4xx_usart.c ****   */
 906:./Lib/Src/stm32f4xx_usart.c **** 
 907:./Lib/Src/stm32f4xx_usart.c **** /**
 908:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Sets the specified USART guard time.
 909:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 910:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 911:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_GuardTime: specifies the guard time.   
 912:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 913:./Lib/Src/stm32f4xx_usart.c ****   */
 914:./Lib/Src/stm32f4xx_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
 915:./Lib/Src/stm32f4xx_usart.c **** {    
 1412              		.loc 1 915 1
 1413              		.cfi_startproc
 1414              		@ args = 0, pretend = 0, frame = 8
 1415              		@ frame_needed = 1, uses_anonymous_args = 0
 1416              		@ link register save eliminated.
 1417 0000 80B4     		push	{r7}
 1418              		.cfi_def_cfa_offset 4
 1419              		.cfi_offset 7, -4
 1420 0002 83B0     		sub	sp, sp, #12
 1421              		.cfi_def_cfa_offset 16
 1422 0004 00AF     		add	r7, sp, #0
 1423              		.cfi_def_cfa_register 7
ARM GAS  /tmp/cc9pQZm7.s 			page 42


 1424 0006 7860     		str	r0, [r7, #4]
 1425 0008 0B46     		mov	r3, r1
 1426 000a FB70     		strb	r3, [r7, #3]
 916:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 917:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 918:./Lib/Src/stm32f4xx_usart.c ****   
 919:./Lib/Src/stm32f4xx_usart.c ****   /* Clear the USART Guard time */
 920:./Lib/Src/stm32f4xx_usart.c ****   USARTx->GTPR &= USART_GTPR_PSC;
 1427              		.loc 1 920 9
 1428 000c 7B68     		ldr	r3, [r7, #4]
 1429 000e 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 1430 0010 9BB2     		uxth	r3, r3
 1431              		.loc 1 920 16
 1432 0012 DBB2     		uxtb	r3, r3
 1433 0014 9AB2     		uxth	r2, r3
 1434 0016 7B68     		ldr	r3, [r7, #4]
 1435 0018 1A83     		strh	r2, [r3, #24]	@ movhi
 921:./Lib/Src/stm32f4xx_usart.c ****   /* Set the USART guard time */
 922:./Lib/Src/stm32f4xx_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 1436              		.loc 1 922 9
 1437 001a 7B68     		ldr	r3, [r7, #4]
 1438 001c 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 1439 001e 9AB2     		uxth	r2, r3
 1440              		.loc 1 922 19
 1441 0020 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1442 0022 9BB2     		uxth	r3, r3
 1443 0024 1B02     		lsls	r3, r3, #8
 1444 0026 9BB2     		uxth	r3, r3
 1445              		.loc 1 922 16
 1446 0028 1343     		orrs	r3, r3, r2
 1447 002a 9AB2     		uxth	r2, r3
 1448 002c 7B68     		ldr	r3, [r7, #4]
 1449 002e 1A83     		strh	r2, [r3, #24]	@ movhi
 923:./Lib/Src/stm32f4xx_usart.c **** }
 1450              		.loc 1 923 1
 1451 0030 00BF     		nop
 1452 0032 0C37     		adds	r7, r7, #12
 1453              		.cfi_def_cfa_offset 4
 1454 0034 BD46     		mov	sp, r7
 1455              		.cfi_def_cfa_register 13
 1456              		@ sp needed
 1457 0036 5DF8047B 		ldr	r7, [sp], #4
 1458              		.cfi_restore 7
 1459              		.cfi_def_cfa_offset 0
 1460 003a 7047     		bx	lr
 1461              		.cfi_endproc
 1462              	.LFE141:
 1464              		.section	.text.USART_SmartCardCmd,"ax",%progbits
 1465              		.align	1
 1466              		.global	USART_SmartCardCmd
 1467              		.syntax unified
 1468              		.thumb
 1469              		.thumb_func
 1471              	USART_SmartCardCmd:
 1472              	.LFB142:
 924:./Lib/Src/stm32f4xx_usart.c **** 
 925:./Lib/Src/stm32f4xx_usart.c **** /**
ARM GAS  /tmp/cc9pQZm7.s 			page 43


 926:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's Smart Card mode.
 927:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 928:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 929:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the Smart Card mode.
 930:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.      
 931:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 932:./Lib/Src/stm32f4xx_usart.c ****   */
 933:./Lib/Src/stm32f4xx_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 934:./Lib/Src/stm32f4xx_usart.c **** {
 1473              		.loc 1 934 1
 1474              		.cfi_startproc
 1475              		@ args = 0, pretend = 0, frame = 8
 1476              		@ frame_needed = 1, uses_anonymous_args = 0
 1477              		@ link register save eliminated.
 1478 0000 80B4     		push	{r7}
 1479              		.cfi_def_cfa_offset 4
 1480              		.cfi_offset 7, -4
 1481 0002 83B0     		sub	sp, sp, #12
 1482              		.cfi_def_cfa_offset 16
 1483 0004 00AF     		add	r7, sp, #0
 1484              		.cfi_def_cfa_register 7
 1485 0006 7860     		str	r0, [r7, #4]
 1486 0008 0B46     		mov	r3, r1
 1487 000a FB70     		strb	r3, [r7, #3]
 935:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
 936:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx));
 937:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 938:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1488              		.loc 1 938 6
 1489 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1490 000e 002B     		cmp	r3, #0
 1491 0010 08D0     		beq	.L60
 939:./Lib/Src/stm32f4xx_usart.c ****   {
 940:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
 941:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_SCEN;
 1492              		.loc 1 941 11
 1493 0012 7B68     		ldr	r3, [r7, #4]
 1494 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1495 0016 9BB2     		uxth	r3, r3
 1496              		.loc 1 941 17
 1497 0018 43F02003 		orr	r3, r3, #32
 1498 001c 9AB2     		uxth	r2, r3
 1499 001e 7B68     		ldr	r3, [r7, #4]
 1500 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 942:./Lib/Src/stm32f4xx_usart.c ****   }
 943:./Lib/Src/stm32f4xx_usart.c ****   else
 944:./Lib/Src/stm32f4xx_usart.c ****   {
 945:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
 946:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 947:./Lib/Src/stm32f4xx_usart.c ****   }
 948:./Lib/Src/stm32f4xx_usart.c **** }
 1501              		.loc 1 948 1
 1502 0022 07E0     		b	.L62
 1503              	.L60:
 946:./Lib/Src/stm32f4xx_usart.c ****   }
 1504              		.loc 1 946 11
 1505 0024 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/cc9pQZm7.s 			page 44


 1506 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1507 0028 9BB2     		uxth	r3, r3
 946:./Lib/Src/stm32f4xx_usart.c ****   }
 1508              		.loc 1 946 17
 1509 002a 23F02003 		bic	r3, r3, #32
 1510 002e 9AB2     		uxth	r2, r3
 1511 0030 7B68     		ldr	r3, [r7, #4]
 1512 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1513              	.L62:
 1514              		.loc 1 948 1
 1515 0034 00BF     		nop
 1516 0036 0C37     		adds	r7, r7, #12
 1517              		.cfi_def_cfa_offset 4
 1518 0038 BD46     		mov	sp, r7
 1519              		.cfi_def_cfa_register 13
 1520              		@ sp needed
 1521 003a 5DF8047B 		ldr	r7, [sp], #4
 1522              		.cfi_restore 7
 1523              		.cfi_def_cfa_offset 0
 1524 003e 7047     		bx	lr
 1525              		.cfi_endproc
 1526              	.LFE142:
 1528              		.section	.text.USART_SmartCardNACKCmd,"ax",%progbits
 1529              		.align	1
 1530              		.global	USART_SmartCardNACKCmd
 1531              		.syntax unified
 1532              		.thumb
 1533              		.thumb_func
 1535              	USART_SmartCardNACKCmd:
 1536              	.LFB143:
 949:./Lib/Src/stm32f4xx_usart.c **** 
 950:./Lib/Src/stm32f4xx_usart.c **** /**
 951:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables NACK transmission.
 952:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
 953:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
 954:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the NACK transmission.
 955:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.  
 956:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
 957:./Lib/Src/stm32f4xx_usart.c ****   */
 958:./Lib/Src/stm32f4xx_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 959:./Lib/Src/stm32f4xx_usart.c **** {
 1537              		.loc 1 959 1
 1538              		.cfi_startproc
 1539              		@ args = 0, pretend = 0, frame = 8
 1540              		@ frame_needed = 1, uses_anonymous_args = 0
 1541              		@ link register save eliminated.
 1542 0000 80B4     		push	{r7}
 1543              		.cfi_def_cfa_offset 4
 1544              		.cfi_offset 7, -4
 1545 0002 83B0     		sub	sp, sp, #12
 1546              		.cfi_def_cfa_offset 16
 1547 0004 00AF     		add	r7, sp, #0
 1548              		.cfi_def_cfa_register 7
 1549 0006 7860     		str	r0, [r7, #4]
 1550 0008 0B46     		mov	r3, r1
 1551 000a FB70     		strb	r3, [r7, #3]
 960:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
ARM GAS  /tmp/cc9pQZm7.s 			page 45


 961:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_1236_PERIPH(USARTx)); 
 962:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 963:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1552              		.loc 1 963 6
 1553 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1554 000e 002B     		cmp	r3, #0
 1555 0010 08D0     		beq	.L64
 964:./Lib/Src/stm32f4xx_usart.c ****   {
 965:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
 966:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_NACK;
 1556              		.loc 1 966 11
 1557 0012 7B68     		ldr	r3, [r7, #4]
 1558 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1559 0016 9BB2     		uxth	r3, r3
 1560              		.loc 1 966 17
 1561 0018 43F01003 		orr	r3, r3, #16
 1562 001c 9AB2     		uxth	r2, r3
 1563 001e 7B68     		ldr	r3, [r7, #4]
 1564 0020 9A82     		strh	r2, [r3, #20]	@ movhi
 967:./Lib/Src/stm32f4xx_usart.c ****   }
 968:./Lib/Src/stm32f4xx_usart.c ****   else
 969:./Lib/Src/stm32f4xx_usart.c ****   {
 970:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
 971:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 972:./Lib/Src/stm32f4xx_usart.c ****   }
 973:./Lib/Src/stm32f4xx_usart.c **** }
 1565              		.loc 1 973 1
 1566 0022 07E0     		b	.L66
 1567              	.L64:
 971:./Lib/Src/stm32f4xx_usart.c ****   }
 1568              		.loc 1 971 11
 1569 0024 7B68     		ldr	r3, [r7, #4]
 1570 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1571 0028 9BB2     		uxth	r3, r3
 971:./Lib/Src/stm32f4xx_usart.c ****   }
 1572              		.loc 1 971 17
 1573 002a 23F01003 		bic	r3, r3, #16
 1574 002e 9AB2     		uxth	r2, r3
 1575 0030 7B68     		ldr	r3, [r7, #4]
 1576 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1577              	.L66:
 1578              		.loc 1 973 1
 1579 0034 00BF     		nop
 1580 0036 0C37     		adds	r7, r7, #12
 1581              		.cfi_def_cfa_offset 4
 1582 0038 BD46     		mov	sp, r7
 1583              		.cfi_def_cfa_register 13
 1584              		@ sp needed
 1585 003a 5DF8047B 		ldr	r7, [sp], #4
 1586              		.cfi_restore 7
 1587              		.cfi_def_cfa_offset 0
 1588 003e 7047     		bx	lr
 1589              		.cfi_endproc
 1590              	.LFE143:
 1592              		.section	.text.USART_IrDAConfig,"ax",%progbits
 1593              		.align	1
 1594              		.global	USART_IrDAConfig
ARM GAS  /tmp/cc9pQZm7.s 			page 46


 1595              		.syntax unified
 1596              		.thumb
 1597              		.thumb_func
 1599              	USART_IrDAConfig:
 1600              	.LFB144:
 974:./Lib/Src/stm32f4xx_usart.c **** 
 975:./Lib/Src/stm32f4xx_usart.c **** /**
 976:./Lib/Src/stm32f4xx_usart.c ****   * @}
 977:./Lib/Src/stm32f4xx_usart.c ****   */
 978:./Lib/Src/stm32f4xx_usart.c **** 
 979:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group7 IrDA mode functions
 980:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   IrDA mode functions 
 981:./Lib/Src/stm32f4xx_usart.c ****  *
 982:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
 983:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
 984:./Lib/Src/stm32f4xx_usart.c ****                         ##### IrDA mode functions #####
 985:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
 986:./Lib/Src/stm32f4xx_usart.c ****     [..]
 987:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to manage the USART 
 988:./Lib/Src/stm32f4xx_usart.c ****     IrDA communication.
 989:./Lib/Src/stm32f4xx_usart.c ****     [..]
 990:./Lib/Src/stm32f4xx_usart.c ****     IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
 991:./Lib/Src/stm32f4xx_usart.c ****     on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
 992:./Lib/Src/stm32f4xx_usart.c ****     is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
 993:./Lib/Src/stm32f4xx_usart.c ****     While receiving data, transmission should be avoided as the data to be transmitted
 994:./Lib/Src/stm32f4xx_usart.c ****     could be corrupted.
 995:./Lib/Src/stm32f4xx_usart.c ****     [..]
 996:./Lib/Src/stm32f4xx_usart.c ****     IrDA communication is possible through the following procedure:
 997:./Lib/Src/stm32f4xx_usart.c ****       (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
 998:./Lib/Src/stm32f4xx_usart.c ****           modes and hardware flow control values using the USART_Init() function.
 999:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the USART using the USART_Cmd() function.
1000:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the IrDA pulse width by configuring the prescaler using  
1001:./Lib/Src/stm32f4xx_usart.c ****           the USART_SetPrescaler() function.
1002:./Lib/Src/stm32f4xx_usart.c ****       (#) Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
1003:./Lib/Src/stm32f4xx_usart.c ****           using the USART_IrDAConfig() function.
1004:./Lib/Src/stm32f4xx_usart.c ****       (#) Enable the IrDA using the USART_IrDACmd() function.
1005:./Lib/Src/stm32f4xx_usart.c **** 
1006:./Lib/Src/stm32f4xx_usart.c ****       -@- A pulse of width less than two and greater than one PSC period(s) may or may
1007:./Lib/Src/stm32f4xx_usart.c ****           not be rejected.
1008:./Lib/Src/stm32f4xx_usart.c ****       -@- The receiver set up time should be managed by software. The IrDA physical layer
1009:./Lib/Src/stm32f4xx_usart.c ****           specification specifies a minimum of 10 ms delay between transmission and 
1010:./Lib/Src/stm32f4xx_usart.c ****           reception (IrDA is a half duplex protocol).
1011:./Lib/Src/stm32f4xx_usart.c ****       -@- In IrDA mode, the following bits must be kept cleared:
1012:./Lib/Src/stm32f4xx_usart.c ****         (+@) LINEN, STOP and CLKEN bits in the USART_CR2 register.
1013:./Lib/Src/stm32f4xx_usart.c ****         (+@) SCEN and HDSEL bits in the USART_CR3 register.
1014:./Lib/Src/stm32f4xx_usart.c **** 
1015:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
1016:./Lib/Src/stm32f4xx_usart.c ****   * @{
1017:./Lib/Src/stm32f4xx_usart.c ****   */
1018:./Lib/Src/stm32f4xx_usart.c **** 
1019:./Lib/Src/stm32f4xx_usart.c **** /**
1020:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Configures the USART's IrDA interface.
1021:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1022:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1023:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
1024:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1025:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_LowPower
ARM GAS  /tmp/cc9pQZm7.s 			page 47


1026:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IrDAMode_Normal
1027:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
1028:./Lib/Src/stm32f4xx_usart.c ****   */
1029:./Lib/Src/stm32f4xx_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
1030:./Lib/Src/stm32f4xx_usart.c **** {
 1601              		.loc 1 1030 1
 1602              		.cfi_startproc
 1603              		@ args = 0, pretend = 0, frame = 8
 1604              		@ frame_needed = 1, uses_anonymous_args = 0
 1605              		@ link register save eliminated.
 1606 0000 80B4     		push	{r7}
 1607              		.cfi_def_cfa_offset 4
 1608              		.cfi_offset 7, -4
 1609 0002 83B0     		sub	sp, sp, #12
 1610              		.cfi_def_cfa_offset 16
 1611 0004 00AF     		add	r7, sp, #0
 1612              		.cfi_def_cfa_register 7
 1613 0006 7860     		str	r0, [r7, #4]
 1614 0008 0B46     		mov	r3, r1
 1615 000a 7B80     		strh	r3, [r7, #2]	@ movhi
1031:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1032:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1033:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
1034:./Lib/Src/stm32f4xx_usart.c ****     
1035:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
 1616              		.loc 1 1035 9
 1617 000c 7B68     		ldr	r3, [r7, #4]
 1618 000e 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1619 0010 9BB2     		uxth	r3, r3
 1620              		.loc 1 1035 15
 1621 0012 23F00403 		bic	r3, r3, #4
 1622 0016 9AB2     		uxth	r2, r3
 1623 0018 7B68     		ldr	r3, [r7, #4]
 1624 001a 9A82     		strh	r2, [r3, #20]	@ movhi
1036:./Lib/Src/stm32f4xx_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 1625              		.loc 1 1036 9
 1626 001c 7B68     		ldr	r3, [r7, #4]
 1627 001e 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1628 0020 9AB2     		uxth	r2, r3
 1629              		.loc 1 1036 15
 1630 0022 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1631 0024 1343     		orrs	r3, r3, r2
 1632 0026 9AB2     		uxth	r2, r3
 1633 0028 7B68     		ldr	r3, [r7, #4]
 1634 002a 9A82     		strh	r2, [r3, #20]	@ movhi
1037:./Lib/Src/stm32f4xx_usart.c **** }
 1635              		.loc 1 1037 1
 1636 002c 00BF     		nop
 1637 002e 0C37     		adds	r7, r7, #12
 1638              		.cfi_def_cfa_offset 4
 1639 0030 BD46     		mov	sp, r7
 1640              		.cfi_def_cfa_register 13
 1641              		@ sp needed
 1642 0032 5DF8047B 		ldr	r7, [sp], #4
 1643              		.cfi_restore 7
 1644              		.cfi_def_cfa_offset 0
 1645 0036 7047     		bx	lr
ARM GAS  /tmp/cc9pQZm7.s 			page 48


 1646              		.cfi_endproc
 1647              	.LFE144:
 1649              		.section	.text.USART_IrDACmd,"ax",%progbits
 1650              		.align	1
 1651              		.global	USART_IrDACmd
 1652              		.syntax unified
 1653              		.thumb
 1654              		.thumb_func
 1656              	USART_IrDACmd:
 1657              	.LFB145:
1038:./Lib/Src/stm32f4xx_usart.c **** 
1039:./Lib/Src/stm32f4xx_usart.c **** /**
1040:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's IrDA interface.
1041:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1042:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1043:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the IrDA mode.
1044:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1045:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
1046:./Lib/Src/stm32f4xx_usart.c ****   */
1047:./Lib/Src/stm32f4xx_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
1048:./Lib/Src/stm32f4xx_usart.c **** {
 1658              		.loc 1 1048 1
 1659              		.cfi_startproc
 1660              		@ args = 0, pretend = 0, frame = 8
 1661              		@ frame_needed = 1, uses_anonymous_args = 0
 1662              		@ link register save eliminated.
 1663 0000 80B4     		push	{r7}
 1664              		.cfi_def_cfa_offset 4
 1665              		.cfi_offset 7, -4
 1666 0002 83B0     		sub	sp, sp, #12
 1667              		.cfi_def_cfa_offset 16
 1668 0004 00AF     		add	r7, sp, #0
 1669              		.cfi_def_cfa_register 7
 1670 0006 7860     		str	r0, [r7, #4]
 1671 0008 0B46     		mov	r3, r1
 1672 000a FB70     		strb	r3, [r7, #3]
1049:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1050:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1051:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1052:./Lib/Src/stm32f4xx_usart.c ****     
1053:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1673              		.loc 1 1053 6
 1674 000c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1675 000e 002B     		cmp	r3, #0
 1676 0010 08D0     		beq	.L69
1054:./Lib/Src/stm32f4xx_usart.c ****   {
1055:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
1056:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_CR3_IREN;
 1677              		.loc 1 1056 11
 1678 0012 7B68     		ldr	r3, [r7, #4]
 1679 0014 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1680 0016 9BB2     		uxth	r3, r3
 1681              		.loc 1 1056 17
 1682 0018 43F00203 		orr	r3, r3, #2
 1683 001c 9AB2     		uxth	r2, r3
 1684 001e 7B68     		ldr	r3, [r7, #4]
 1685 0020 9A82     		strh	r2, [r3, #20]	@ movhi
ARM GAS  /tmp/cc9pQZm7.s 			page 49


1057:./Lib/Src/stm32f4xx_usart.c ****   }
1058:./Lib/Src/stm32f4xx_usart.c ****   else
1059:./Lib/Src/stm32f4xx_usart.c ****   {
1060:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
1061:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
1062:./Lib/Src/stm32f4xx_usart.c ****   }
1063:./Lib/Src/stm32f4xx_usart.c **** }
 1686              		.loc 1 1063 1
 1687 0022 07E0     		b	.L71
 1688              	.L69:
1061:./Lib/Src/stm32f4xx_usart.c ****   }
 1689              		.loc 1 1061 11
 1690 0024 7B68     		ldr	r3, [r7, #4]
 1691 0026 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1692 0028 9BB2     		uxth	r3, r3
1061:./Lib/Src/stm32f4xx_usart.c ****   }
 1693              		.loc 1 1061 17
 1694 002a 23F00203 		bic	r3, r3, #2
 1695 002e 9AB2     		uxth	r2, r3
 1696 0030 7B68     		ldr	r3, [r7, #4]
 1697 0032 9A82     		strh	r2, [r3, #20]	@ movhi
 1698              	.L71:
 1699              		.loc 1 1063 1
 1700 0034 00BF     		nop
 1701 0036 0C37     		adds	r7, r7, #12
 1702              		.cfi_def_cfa_offset 4
 1703 0038 BD46     		mov	sp, r7
 1704              		.cfi_def_cfa_register 13
 1705              		@ sp needed
 1706 003a 5DF8047B 		ldr	r7, [sp], #4
 1707              		.cfi_restore 7
 1708              		.cfi_def_cfa_offset 0
 1709 003e 7047     		bx	lr
 1710              		.cfi_endproc
 1711              	.LFE145:
 1713              		.section	.text.USART_DMACmd,"ax",%progbits
 1714              		.align	1
 1715              		.global	USART_DMACmd
 1716              		.syntax unified
 1717              		.thumb
 1718              		.thumb_func
 1720              	USART_DMACmd:
 1721              	.LFB146:
1064:./Lib/Src/stm32f4xx_usart.c **** 
1065:./Lib/Src/stm32f4xx_usart.c **** /**
1066:./Lib/Src/stm32f4xx_usart.c ****   * @}
1067:./Lib/Src/stm32f4xx_usart.c ****   */
1068:./Lib/Src/stm32f4xx_usart.c **** 
1069:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group8 DMA transfers management functions
1070:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   DMA transfers management functions
1071:./Lib/Src/stm32f4xx_usart.c ****  *
1072:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
1073:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
1074:./Lib/Src/stm32f4xx_usart.c ****               ##### DMA transfers management functions #####
1075:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
1076:./Lib/Src/stm32f4xx_usart.c **** 
1077:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
ARM GAS  /tmp/cc9pQZm7.s 			page 50


1078:./Lib/Src/stm32f4xx_usart.c ****   * @{
1079:./Lib/Src/stm32f4xx_usart.c ****   */
1080:./Lib/Src/stm32f4xx_usart.c ****   
1081:./Lib/Src/stm32f4xx_usart.c **** /**
1082:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the USART's DMA interface.
1083:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1084:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1085:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
1086:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1087:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Tx: USART DMA transmit request
1088:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_DMAReq_Rx: USART DMA receive request
1089:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the DMA Request sources.
1090:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.   
1091:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
1092:./Lib/Src/stm32f4xx_usart.c ****   */
1093:./Lib/Src/stm32f4xx_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
1094:./Lib/Src/stm32f4xx_usart.c **** {
 1722              		.loc 1 1094 1
 1723              		.cfi_startproc
 1724              		@ args = 0, pretend = 0, frame = 8
 1725              		@ frame_needed = 1, uses_anonymous_args = 0
 1726              		@ link register save eliminated.
 1727 0000 80B4     		push	{r7}
 1728              		.cfi_def_cfa_offset 4
 1729              		.cfi_offset 7, -4
 1730 0002 83B0     		sub	sp, sp, #12
 1731              		.cfi_def_cfa_offset 16
 1732 0004 00AF     		add	r7, sp, #0
 1733              		.cfi_def_cfa_register 7
 1734 0006 7860     		str	r0, [r7, #4]
 1735 0008 0B46     		mov	r3, r1
 1736 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 1737 000c 1346     		mov	r3, r2
 1738 000e 7B70     		strb	r3, [r7, #1]
1095:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1096:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1097:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
1098:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1099:./Lib/Src/stm32f4xx_usart.c **** 
1100:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1739              		.loc 1 1100 6
 1740 0010 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1741 0012 002B     		cmp	r3, #0
 1742 0014 08D0     		beq	.L73
1101:./Lib/Src/stm32f4xx_usart.c ****   {
1102:./Lib/Src/stm32f4xx_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
1103:./Lib/Src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1104:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 1743              		.loc 1 1104 11
 1744 0016 7B68     		ldr	r3, [r7, #4]
 1745 0018 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1746 001a 9AB2     		uxth	r2, r3
 1747              		.loc 1 1104 17
 1748 001c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1749 001e 1343     		orrs	r3, r3, r2
 1750 0020 9AB2     		uxth	r2, r3
 1751 0022 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/cc9pQZm7.s 			page 51


 1752 0024 9A82     		strh	r2, [r3, #20]	@ movhi
1105:./Lib/Src/stm32f4xx_usart.c ****   }
1106:./Lib/Src/stm32f4xx_usart.c ****   else
1107:./Lib/Src/stm32f4xx_usart.c ****   {
1108:./Lib/Src/stm32f4xx_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
1109:./Lib/Src/stm32f4xx_usart.c ****        DMAR bits in the USART CR3 register */
1110:./Lib/Src/stm32f4xx_usart.c ****     USARTx->CR3 &= (uint16_t)~USART_DMAReq;
1111:./Lib/Src/stm32f4xx_usart.c ****   }
1112:./Lib/Src/stm32f4xx_usart.c **** }
 1753              		.loc 1 1112 1
 1754 0026 09E0     		b	.L75
 1755              	.L73:
1110:./Lib/Src/stm32f4xx_usart.c ****   }
 1756              		.loc 1 1110 11
 1757 0028 7B68     		ldr	r3, [r7, #4]
 1758 002a 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 1759 002c 9AB2     		uxth	r2, r3
1110:./Lib/Src/stm32f4xx_usart.c ****   }
 1760              		.loc 1 1110 20
 1761 002e 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1762 0030 DB43     		mvns	r3, r3
 1763 0032 9BB2     		uxth	r3, r3
1110:./Lib/Src/stm32f4xx_usart.c ****   }
 1764              		.loc 1 1110 17
 1765 0034 1340     		ands	r3, r3, r2
 1766 0036 9AB2     		uxth	r2, r3
 1767 0038 7B68     		ldr	r3, [r7, #4]
 1768 003a 9A82     		strh	r2, [r3, #20]	@ movhi
 1769              	.L75:
 1770              		.loc 1 1112 1
 1771 003c 00BF     		nop
 1772 003e 0C37     		adds	r7, r7, #12
 1773              		.cfi_def_cfa_offset 4
 1774 0040 BD46     		mov	sp, r7
 1775              		.cfi_def_cfa_register 13
 1776              		@ sp needed
 1777 0042 5DF8047B 		ldr	r7, [sp], #4
 1778              		.cfi_restore 7
 1779              		.cfi_def_cfa_offset 0
 1780 0046 7047     		bx	lr
 1781              		.cfi_endproc
 1782              	.LFE146:
 1784              		.section	.text.USART_ITConfig,"ax",%progbits
 1785              		.align	1
 1786              		.global	USART_ITConfig
 1787              		.syntax unified
 1788              		.thumb
 1789              		.thumb_func
 1791              	USART_ITConfig:
 1792              	.LFB147:
1113:./Lib/Src/stm32f4xx_usart.c **** 
1114:./Lib/Src/stm32f4xx_usart.c **** /**
1115:./Lib/Src/stm32f4xx_usart.c ****   * @}
1116:./Lib/Src/stm32f4xx_usart.c ****   */
1117:./Lib/Src/stm32f4xx_usart.c ****   
1118:./Lib/Src/stm32f4xx_usart.c **** /** @defgroup USART_Group9 Interrupts and flags management functions
1119:./Lib/Src/stm32f4xx_usart.c ****  *  @brief   Interrupts and flags management functions 
ARM GAS  /tmp/cc9pQZm7.s 			page 52


1120:./Lib/Src/stm32f4xx_usart.c ****  *
1121:./Lib/Src/stm32f4xx_usart.c **** @verbatim   
1122:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================
1123:./Lib/Src/stm32f4xx_usart.c ****             ##### Interrupts and flags management functions #####
1124:./Lib/Src/stm32f4xx_usart.c ****  ===============================================================================  
1125:./Lib/Src/stm32f4xx_usart.c ****     [..]
1126:./Lib/Src/stm32f4xx_usart.c ****     This subsection provides a set of functions allowing to configure the USART 
1127:./Lib/Src/stm32f4xx_usart.c ****     Interrupts sources, DMA channels requests and check or clear the flags or 
1128:./Lib/Src/stm32f4xx_usart.c ****     pending bits status.
1129:./Lib/Src/stm32f4xx_usart.c ****     The user should identify which mode will be used in his application to manage 
1130:./Lib/Src/stm32f4xx_usart.c ****     the communication: Polling mode, Interrupt mode or DMA mode. 
1131:./Lib/Src/stm32f4xx_usart.c ****     
1132:./Lib/Src/stm32f4xx_usart.c ****     *** Polling Mode ***
1133:./Lib/Src/stm32f4xx_usart.c ****     ====================
1134:./Lib/Src/stm32f4xx_usart.c ****     [..]
1135:./Lib/Src/stm32f4xx_usart.c ****     In Polling Mode, the SPI communication can be managed by 10 flags:
1136:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_TXE : to indicate the status of the transmit buffer register
1137:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_RXNE : to indicate the status of the receive buffer register
1138:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_TC : to indicate the status of the transmit operation
1139:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_IDLE : to indicate the status of the Idle Line             
1140:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_CTS : to indicate the status of the nCTS input
1141:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_LBD : to indicate the status of the LIN break detection
1142:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_NE : to indicate if a noise error occur
1143:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_FE : to indicate if a frame error occur
1144:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_PE : to indicate if a parity error occur
1145:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_FLAG_ORE : to indicate if an Overrun error occur
1146:./Lib/Src/stm32f4xx_usart.c ****     [..]
1147:./Lib/Src/stm32f4xx_usart.c ****     In this Mode it is advised to use the following functions:
1148:./Lib/Src/stm32f4xx_usart.c ****       (+) FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1149:./Lib/Src/stm32f4xx_usart.c ****       (+) void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
1150:./Lib/Src/stm32f4xx_usart.c **** 
1151:./Lib/Src/stm32f4xx_usart.c ****     *** Interrupt Mode ***
1152:./Lib/Src/stm32f4xx_usart.c ****     ======================
1153:./Lib/Src/stm32f4xx_usart.c ****     [..]
1154:./Lib/Src/stm32f4xx_usart.c ****     In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
1155:./Lib/Src/stm32f4xx_usart.c ****     and 10 pending bits: 
1156:./Lib/Src/stm32f4xx_usart.c **** 
1157:./Lib/Src/stm32f4xx_usart.c ****       (#) Pending Bits:
1158:./Lib/Src/stm32f4xx_usart.c **** 
1159:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_TXE : to indicate the status of the transmit buffer register
1160:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_RXNE : to indicate the status of the receive buffer register
1161:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_TC : to indicate the status of the transmit operation
1162:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_IDLE : to indicate the status of the Idle Line             
1163:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_CTS : to indicate the status of the nCTS input
1164:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_LBD : to indicate the status of the LIN break detection
1165:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_NE : to indicate if a noise error occur
1166:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_FE : to indicate if a frame error occur
1167:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_PE : to indicate if a parity error occur
1168:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_ORE : to indicate if an Overrun error occur
1169:./Lib/Src/stm32f4xx_usart.c **** 
1170:./Lib/Src/stm32f4xx_usart.c ****       (#) Interrupt Source:
1171:./Lib/Src/stm32f4xx_usart.c **** 
1172:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
1173:./Lib/Src/stm32f4xx_usart.c ****                             interrupt. 
1174:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
1175:./Lib/Src/stm32f4xx_usart.c ****                              empty interrupt.
1176:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_TC : specifies the interrupt source for the Transmit complete 
ARM GAS  /tmp/cc9pQZm7.s 			page 53


1177:./Lib/Src/stm32f4xx_usart.c ****                            interrupt. 
1178:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.           
1179:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
1180:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_LBD : specifies the interrupt source for the LIN break detection
1181:./Lib/Src/stm32f4xx_usart.c ****                             interrupt. 
1182:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
1183:./Lib/Src/stm32f4xx_usart.c ****         (##) USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
1184:./Lib/Src/stm32f4xx_usart.c **** 
1185:./Lib/Src/stm32f4xx_usart.c ****       -@@- Some parameters are coded in order to use them as interrupt source 
1186:./Lib/Src/stm32f4xx_usart.c ****           or as pending bits.
1187:./Lib/Src/stm32f4xx_usart.c ****     [..]
1188:./Lib/Src/stm32f4xx_usart.c ****     In this Mode it is advised to use the following functions:
1189:./Lib/Src/stm32f4xx_usart.c ****       (+) void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
1190:./Lib/Src/stm32f4xx_usart.c ****       (+) ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
1191:./Lib/Src/stm32f4xx_usart.c ****       (+) void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
1192:./Lib/Src/stm32f4xx_usart.c **** 
1193:./Lib/Src/stm32f4xx_usart.c ****     *** DMA Mode ***
1194:./Lib/Src/stm32f4xx_usart.c ****     ================
1195:./Lib/Src/stm32f4xx_usart.c ****     [..]
1196:./Lib/Src/stm32f4xx_usart.c ****     In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
1197:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
1198:./Lib/Src/stm32f4xx_usart.c ****       (#) USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
1199:./Lib/Src/stm32f4xx_usart.c ****     [..]
1200:./Lib/Src/stm32f4xx_usart.c ****     In this Mode it is advised to use the following function:
1201:./Lib/Src/stm32f4xx_usart.c ****       (+) void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
1202:./Lib/Src/stm32f4xx_usart.c **** 
1203:./Lib/Src/stm32f4xx_usart.c **** @endverbatim
1204:./Lib/Src/stm32f4xx_usart.c ****   * @{
1205:./Lib/Src/stm32f4xx_usart.c ****   */
1206:./Lib/Src/stm32f4xx_usart.c **** 
1207:./Lib/Src/stm32f4xx_usart.c **** /**
1208:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
1209:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1210:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1211:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
1212:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1213:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt
1214:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1215:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1216:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1217:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1218:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1219:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1220:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
1221:./Lib/Src/stm32f4xx_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
1222:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be: ENABLE or DISABLE.
1223:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
1224:./Lib/Src/stm32f4xx_usart.c ****   */
1225:./Lib/Src/stm32f4xx_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
1226:./Lib/Src/stm32f4xx_usart.c **** {
 1793              		.loc 1 1226 1
 1794              		.cfi_startproc
 1795              		@ args = 0, pretend = 0, frame = 24
 1796              		@ frame_needed = 1, uses_anonymous_args = 0
 1797              		@ link register save eliminated.
 1798 0000 80B4     		push	{r7}
 1799              		.cfi_def_cfa_offset 4
ARM GAS  /tmp/cc9pQZm7.s 			page 54


 1800              		.cfi_offset 7, -4
 1801 0002 87B0     		sub	sp, sp, #28
 1802              		.cfi_def_cfa_offset 32
 1803 0004 00AF     		add	r7, sp, #0
 1804              		.cfi_def_cfa_register 7
 1805 0006 7860     		str	r0, [r7, #4]
 1806 0008 0B46     		mov	r3, r1
 1807 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 1808 000c 1346     		mov	r3, r2
 1809 000e 7B70     		strb	r3, [r7, #1]
1227:./Lib/Src/stm32f4xx_usart.c ****   uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 1810              		.loc 1 1227 12
 1811 0010 0023     		movs	r3, #0
 1812 0012 3B61     		str	r3, [r7, #16]
 1813              		.loc 1 1227 29
 1814 0014 0023     		movs	r3, #0
 1815 0016 FB60     		str	r3, [r7, #12]
 1816              		.loc 1 1227 43
 1817 0018 0023     		movs	r3, #0
 1818 001a BB60     		str	r3, [r7, #8]
1228:./Lib/Src/stm32f4xx_usart.c ****   uint32_t usartxbase = 0x00;
 1819              		.loc 1 1228 12
 1820 001c 0023     		movs	r3, #0
 1821 001e 7B61     		str	r3, [r7, #20]
1229:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1230:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1231:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
1232:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1233:./Lib/Src/stm32f4xx_usart.c **** 
1234:./Lib/Src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1235:./Lib/Src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1236:./Lib/Src/stm32f4xx_usart.c ****   {
1237:./Lib/Src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1238:./Lib/Src/stm32f4xx_usart.c ****   } 
1239:./Lib/Src/stm32f4xx_usart.c ****     
1240:./Lib/Src/stm32f4xx_usart.c ****   usartxbase = (uint32_t)USARTx;
 1822              		.loc 1 1240 14
 1823 0020 7B68     		ldr	r3, [r7, #4]
 1824 0022 7B61     		str	r3, [r7, #20]
1241:./Lib/Src/stm32f4xx_usart.c **** 
1242:./Lib/Src/stm32f4xx_usart.c ****   /* Get the USART register index */
1243:./Lib/Src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 1825              		.loc 1 1243 16
 1826 0024 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1827 0026 DBB2     		uxtb	r3, r3
 1828              		.loc 1 1243 35
 1829 0028 5B09     		lsrs	r3, r3, #5
 1830 002a DBB2     		uxtb	r3, r3
 1831              		.loc 1 1243 12
 1832 002c 3B61     		str	r3, [r7, #16]
1244:./Lib/Src/stm32f4xx_usart.c **** 
1245:./Lib/Src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1246:./Lib/Src/stm32f4xx_usart.c ****   itpos = USART_IT & IT_MASK;
 1833              		.loc 1 1246 20
 1834 002e 7B88     		ldrh	r3, [r7, #2]
 1835              		.loc 1 1246 9
 1836 0030 03F01F03 		and	r3, r3, #31
ARM GAS  /tmp/cc9pQZm7.s 			page 55


 1837 0034 FB60     		str	r3, [r7, #12]
1247:./Lib/Src/stm32f4xx_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 1838              		.loc 1 1247 10
 1839 0036 0122     		movs	r2, #1
 1840 0038 FB68     		ldr	r3, [r7, #12]
 1841 003a 02FA03F3 		lsl	r3, r2, r3
 1842 003e BB60     		str	r3, [r7, #8]
1248:./Lib/Src/stm32f4xx_usart.c ****     
1249:./Lib/Src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT is in CR1 register */
 1843              		.loc 1 1249 6
 1844 0040 3B69     		ldr	r3, [r7, #16]
 1845 0042 012B     		cmp	r3, #1
 1846 0044 03D1     		bne	.L77
1250:./Lib/Src/stm32f4xx_usart.c ****   {
1251:./Lib/Src/stm32f4xx_usart.c ****     usartxbase += 0x0C;
 1847              		.loc 1 1251 16
 1848 0046 7B69     		ldr	r3, [r7, #20]
 1849 0048 0C33     		adds	r3, r3, #12
 1850 004a 7B61     		str	r3, [r7, #20]
 1851 004c 09E0     		b	.L78
 1852              	.L77:
1252:./Lib/Src/stm32f4xx_usart.c ****   }
1253:./Lib/Src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT is in CR2 register */
 1853              		.loc 1 1253 11
 1854 004e 3B69     		ldr	r3, [r7, #16]
 1855 0050 022B     		cmp	r3, #2
 1856 0052 03D1     		bne	.L79
1254:./Lib/Src/stm32f4xx_usart.c ****   {
1255:./Lib/Src/stm32f4xx_usart.c ****     usartxbase += 0x10;
 1857              		.loc 1 1255 16
 1858 0054 7B69     		ldr	r3, [r7, #20]
 1859 0056 1033     		adds	r3, r3, #16
 1860 0058 7B61     		str	r3, [r7, #20]
 1861 005a 02E0     		b	.L78
 1862              	.L79:
1256:./Lib/Src/stm32f4xx_usart.c ****   }
1257:./Lib/Src/stm32f4xx_usart.c ****   else /* The IT is in CR3 register */
1258:./Lib/Src/stm32f4xx_usart.c ****   {
1259:./Lib/Src/stm32f4xx_usart.c ****     usartxbase += 0x14; 
 1863              		.loc 1 1259 16
 1864 005c 7B69     		ldr	r3, [r7, #20]
 1865 005e 1433     		adds	r3, r3, #20
 1866 0060 7B61     		str	r3, [r7, #20]
 1867              	.L78:
1260:./Lib/Src/stm32f4xx_usart.c ****   }
1261:./Lib/Src/stm32f4xx_usart.c ****   if (NewState != DISABLE)
 1868              		.loc 1 1261 6
 1869 0062 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 1870 0064 002B     		cmp	r3, #0
 1871 0066 06D0     		beq	.L80
1262:./Lib/Src/stm32f4xx_usart.c ****   {
1263:./Lib/Src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 1872              		.loc 1 1263 5
 1873 0068 7B69     		ldr	r3, [r7, #20]
 1874 006a 1968     		ldr	r1, [r3]
 1875 006c 7B69     		ldr	r3, [r7, #20]
 1876              		.loc 1 1263 34
ARM GAS  /tmp/cc9pQZm7.s 			page 56


 1877 006e BA68     		ldr	r2, [r7, #8]
 1878 0070 0A43     		orrs	r2, r2, r1
 1879 0072 1A60     		str	r2, [r3]
1264:./Lib/Src/stm32f4xx_usart.c ****   }
1265:./Lib/Src/stm32f4xx_usart.c ****   else
1266:./Lib/Src/stm32f4xx_usart.c ****   {
1267:./Lib/Src/stm32f4xx_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
1268:./Lib/Src/stm32f4xx_usart.c ****   }
1269:./Lib/Src/stm32f4xx_usart.c **** }
 1880              		.loc 1 1269 1
 1881 0074 06E0     		b	.L82
 1882              	.L80:
1267:./Lib/Src/stm32f4xx_usart.c ****   }
 1883              		.loc 1 1267 5
 1884 0076 7B69     		ldr	r3, [r7, #20]
 1885 0078 1968     		ldr	r1, [r3]
1267:./Lib/Src/stm32f4xx_usart.c ****   }
 1886              		.loc 1 1267 36
 1887 007a BB68     		ldr	r3, [r7, #8]
 1888 007c DA43     		mvns	r2, r3
1267:./Lib/Src/stm32f4xx_usart.c ****   }
 1889              		.loc 1 1267 5
 1890 007e 7B69     		ldr	r3, [r7, #20]
1267:./Lib/Src/stm32f4xx_usart.c ****   }
 1891              		.loc 1 1267 33
 1892 0080 0A40     		ands	r2, r2, r1
 1893 0082 1A60     		str	r2, [r3]
 1894              	.L82:
 1895              		.loc 1 1269 1
 1896 0084 00BF     		nop
 1897 0086 1C37     		adds	r7, r7, #28
 1898              		.cfi_def_cfa_offset 4
 1899 0088 BD46     		mov	sp, r7
 1900              		.cfi_def_cfa_register 13
 1901              		@ sp needed
 1902 008a 5DF8047B 		ldr	r7, [sp], #4
 1903              		.cfi_restore 7
 1904              		.cfi_def_cfa_offset 0
 1905 008e 7047     		bx	lr
 1906              		.cfi_endproc
 1907              	.LFE147:
 1909              		.section	.text.USART_GetFlagStatus,"ax",%progbits
 1910              		.align	1
 1911              		.global	USART_GetFlagStatus
 1912              		.syntax unified
 1913              		.thumb
 1914              		.thumb_func
 1916              	USART_GetFlagStatus:
 1917              	.LFB148:
1270:./Lib/Src/stm32f4xx_usart.c **** 
1271:./Lib/Src/stm32f4xx_usart.c **** /**
1272:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
1273:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1274:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1275:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
1276:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1277:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
ARM GAS  /tmp/cc9pQZm7.s 			page 57


1278:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag
1279:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TXE:  Transmit data register empty flag
1280:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag
1281:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag
1282:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_IDLE: Idle Line detection flag
1283:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_ORE:  OverRun Error flag
1284:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_NE:   Noise Error flag
1285:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_FE:   Framing Error flag
1286:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_PE:   Parity Error flag
1287:./Lib/Src/stm32f4xx_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
1288:./Lib/Src/stm32f4xx_usart.c ****   */
1289:./Lib/Src/stm32f4xx_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1290:./Lib/Src/stm32f4xx_usart.c **** {
 1918              		.loc 1 1290 1
 1919              		.cfi_startproc
 1920              		@ args = 0, pretend = 0, frame = 16
 1921              		@ frame_needed = 1, uses_anonymous_args = 0
 1922              		@ link register save eliminated.
 1923 0000 80B4     		push	{r7}
 1924              		.cfi_def_cfa_offset 4
 1925              		.cfi_offset 7, -4
 1926 0002 85B0     		sub	sp, sp, #20
 1927              		.cfi_def_cfa_offset 24
 1928 0004 00AF     		add	r7, sp, #0
 1929              		.cfi_def_cfa_register 7
 1930 0006 7860     		str	r0, [r7, #4]
 1931 0008 0B46     		mov	r3, r1
 1932 000a 7B80     		strh	r3, [r7, #2]	@ movhi
1291:./Lib/Src/stm32f4xx_usart.c ****   FlagStatus bitstatus = RESET;
 1933              		.loc 1 1291 14
 1934 000c 0023     		movs	r3, #0
 1935 000e FB73     		strb	r3, [r7, #15]
1292:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1293:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1294:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
1295:./Lib/Src/stm32f4xx_usart.c **** 
1296:./Lib/Src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1297:./Lib/Src/stm32f4xx_usart.c ****   if (USART_FLAG == USART_FLAG_CTS)
1298:./Lib/Src/stm32f4xx_usart.c ****   {
1299:./Lib/Src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1300:./Lib/Src/stm32f4xx_usart.c ****   } 
1301:./Lib/Src/stm32f4xx_usart.c ****     
1302:./Lib/Src/stm32f4xx_usart.c ****   if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 1936              		.loc 1 1302 14
 1937 0010 7B68     		ldr	r3, [r7, #4]
 1938 0012 1B88     		ldrh	r3, [r3]	@ movhi
 1939 0014 9AB2     		uxth	r2, r3
 1940              		.loc 1 1302 33
 1941 0016 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1942 0018 1340     		ands	r3, r3, r2
 1943 001a 9BB2     		uxth	r3, r3
 1944              		.loc 1 1302 6
 1945 001c 002B     		cmp	r3, #0
 1946 001e 02D0     		beq	.L84
1303:./Lib/Src/stm32f4xx_usart.c ****   {
1304:./Lib/Src/stm32f4xx_usart.c ****     bitstatus = SET;
 1947              		.loc 1 1304 15
ARM GAS  /tmp/cc9pQZm7.s 			page 58


 1948 0020 0123     		movs	r3, #1
 1949 0022 FB73     		strb	r3, [r7, #15]
 1950 0024 01E0     		b	.L85
 1951              	.L84:
1305:./Lib/Src/stm32f4xx_usart.c ****   }
1306:./Lib/Src/stm32f4xx_usart.c ****   else
1307:./Lib/Src/stm32f4xx_usart.c ****   {
1308:./Lib/Src/stm32f4xx_usart.c ****     bitstatus = RESET;
 1952              		.loc 1 1308 15
 1953 0026 0023     		movs	r3, #0
 1954 0028 FB73     		strb	r3, [r7, #15]
 1955              	.L85:
1309:./Lib/Src/stm32f4xx_usart.c ****   }
1310:./Lib/Src/stm32f4xx_usart.c ****   return bitstatus;
 1956              		.loc 1 1310 10
 1957 002a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1311:./Lib/Src/stm32f4xx_usart.c **** }
 1958              		.loc 1 1311 1
 1959 002c 1846     		mov	r0, r3
 1960 002e 1437     		adds	r7, r7, #20
 1961              		.cfi_def_cfa_offset 4
 1962 0030 BD46     		mov	sp, r7
 1963              		.cfi_def_cfa_register 13
 1964              		@ sp needed
 1965 0032 5DF8047B 		ldr	r7, [sp], #4
 1966              		.cfi_restore 7
 1967              		.cfi_def_cfa_offset 0
 1968 0036 7047     		bx	lr
 1969              		.cfi_endproc
 1970              	.LFE148:
 1972              		.section	.text.USART_ClearFlag,"ax",%progbits
 1973              		.align	1
 1974              		.global	USART_ClearFlag
 1975              		.syntax unified
 1976              		.thumb
 1977              		.thumb_func
 1979              	USART_ClearFlag:
 1980              	.LFB149:
1312:./Lib/Src/stm32f4xx_usart.c **** 
1313:./Lib/Src/stm32f4xx_usart.c **** /**
1314:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's pending flags.
1315:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1316:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1317:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
1318:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be any combination of the following values:
1319:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
1320:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_LBD:  LIN Break detection flag.
1321:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_TC:   Transmission Complete flag.
1322:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
1323:./Lib/Src/stm32f4xx_usart.c ****   *   
1324:./Lib/Src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1325:./Lib/Src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) flags are cleared by software 
1326:./Lib/Src/stm32f4xx_usart.c ****   *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
1327:./Lib/Src/stm32f4xx_usart.c ****   *          followed by a read operation to USART_DR register (USART_ReceiveData()).
1328:./Lib/Src/stm32f4xx_usart.c ****   * @note   RXNE flag can be also cleared by a read to the USART_DR register 
1329:./Lib/Src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1330:./Lib/Src/stm32f4xx_usart.c ****   * @note   TC flag can be also cleared by software sequence: a read operation to 
ARM GAS  /tmp/cc9pQZm7.s 			page 59


1331:./Lib/Src/stm32f4xx_usart.c ****   *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
1332:./Lib/Src/stm32f4xx_usart.c ****   *          to USART_DR register (USART_SendData()).
1333:./Lib/Src/stm32f4xx_usart.c ****   * @note   TXE flag is cleared only by a write to the USART_DR register 
1334:./Lib/Src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1335:./Lib/Src/stm32f4xx_usart.c ****   *   
1336:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
1337:./Lib/Src/stm32f4xx_usart.c ****   */
1338:./Lib/Src/stm32f4xx_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
1339:./Lib/Src/stm32f4xx_usart.c **** {
 1981              		.loc 1 1339 1
 1982              		.cfi_startproc
 1983              		@ args = 0, pretend = 0, frame = 8
 1984              		@ frame_needed = 1, uses_anonymous_args = 0
 1985              		@ link register save eliminated.
 1986 0000 80B4     		push	{r7}
 1987              		.cfi_def_cfa_offset 4
 1988              		.cfi_offset 7, -4
 1989 0002 83B0     		sub	sp, sp, #12
 1990              		.cfi_def_cfa_offset 16
 1991 0004 00AF     		add	r7, sp, #0
 1992              		.cfi_def_cfa_register 7
 1993 0006 7860     		str	r0, [r7, #4]
 1994 0008 0B46     		mov	r3, r1
 1995 000a 7B80     		strh	r3, [r7, #2]	@ movhi
1340:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1341:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1342:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
1343:./Lib/Src/stm32f4xx_usart.c **** 
1344:./Lib/Src/stm32f4xx_usart.c ****   /* The CTS flag is not available for UART4 and UART5 */
1345:./Lib/Src/stm32f4xx_usart.c ****   if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
1346:./Lib/Src/stm32f4xx_usart.c ****   {
1347:./Lib/Src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1348:./Lib/Src/stm32f4xx_usart.c ****   } 
1349:./Lib/Src/stm32f4xx_usart.c ****        
1350:./Lib/Src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~USART_FLAG;
 1996              		.loc 1 1350 16
 1997 000c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1998 000e DB43     		mvns	r3, r3
 1999 0010 9AB2     		uxth	r2, r3
 2000              		.loc 1 1350 14
 2001 0012 7B68     		ldr	r3, [r7, #4]
 2002 0014 1A80     		strh	r2, [r3]	@ movhi
1351:./Lib/Src/stm32f4xx_usart.c **** }
 2003              		.loc 1 1351 1
 2004 0016 00BF     		nop
 2005 0018 0C37     		adds	r7, r7, #12
 2006              		.cfi_def_cfa_offset 4
 2007 001a BD46     		mov	sp, r7
 2008              		.cfi_def_cfa_register 13
 2009              		@ sp needed
 2010 001c 5DF8047B 		ldr	r7, [sp], #4
 2011              		.cfi_restore 7
 2012              		.cfi_def_cfa_offset 0
 2013 0020 7047     		bx	lr
 2014              		.cfi_endproc
 2015              	.LFE149:
 2017              		.section	.text.USART_GetITStatus,"ax",%progbits
ARM GAS  /tmp/cc9pQZm7.s 			page 60


 2018              		.align	1
 2019              		.global	USART_GetITStatus
 2020              		.syntax unified
 2021              		.thumb
 2022              		.thumb_func
 2024              	USART_GetITStatus:
 2025              	.LFB150:
1352:./Lib/Src/stm32f4xx_usart.c **** 
1353:./Lib/Src/stm32f4xx_usart.c **** /**
1354:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
1355:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1356:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1357:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
1358:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1359:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1360:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
1361:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
1362:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt
1363:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
1364:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_IDLE: Idle line detection interrupt
1365:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
1366:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
1367:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_NE:   Noise Error interrupt
1368:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_FE:   Framing Error interrupt
1369:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_PE:   Parity Error interrupt
1370:./Lib/Src/stm32f4xx_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
1371:./Lib/Src/stm32f4xx_usart.c ****   */
1372:./Lib/Src/stm32f4xx_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
1373:./Lib/Src/stm32f4xx_usart.c **** {
 2026              		.loc 1 1373 1
 2027              		.cfi_startproc
 2028              		@ args = 0, pretend = 0, frame = 24
 2029              		@ frame_needed = 1, uses_anonymous_args = 0
 2030              		@ link register save eliminated.
 2031 0000 80B4     		push	{r7}
 2032              		.cfi_def_cfa_offset 4
 2033              		.cfi_offset 7, -4
 2034 0002 87B0     		sub	sp, sp, #28
 2035              		.cfi_def_cfa_offset 32
 2036 0004 00AF     		add	r7, sp, #0
 2037              		.cfi_def_cfa_register 7
 2038 0006 7860     		str	r0, [r7, #4]
 2039 0008 0B46     		mov	r3, r1
 2040 000a 7B80     		strh	r3, [r7, #2]	@ movhi
1374:./Lib/Src/stm32f4xx_usart.c ****   uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 2041              		.loc 1 1374 12
 2042 000c 0023     		movs	r3, #0
 2043 000e FB60     		str	r3, [r7, #12]
 2044              		.loc 1 1374 27
 2045 0010 0023     		movs	r3, #0
 2046 0012 7B61     		str	r3, [r7, #20]
 2047              		.loc 1 1374 42
 2048 0014 0023     		movs	r3, #0
 2049 0016 BB60     		str	r3, [r7, #8]
1375:./Lib/Src/stm32f4xx_usart.c ****   ITStatus bitstatus = RESET;
 2050              		.loc 1 1375 12
 2051 0018 0023     		movs	r3, #0
ARM GAS  /tmp/cc9pQZm7.s 			page 61


 2052 001a FB74     		strb	r3, [r7, #19]
1376:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1377:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1378:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT)); 
1379:./Lib/Src/stm32f4xx_usart.c **** 
1380:./Lib/Src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */ 
1381:./Lib/Src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1382:./Lib/Src/stm32f4xx_usart.c ****   {
1383:./Lib/Src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1384:./Lib/Src/stm32f4xx_usart.c ****   } 
1385:./Lib/Src/stm32f4xx_usart.c ****     
1386:./Lib/Src/stm32f4xx_usart.c ****   /* Get the USART register index */
1387:./Lib/Src/stm32f4xx_usart.c ****   usartreg = (((uint8_t)USART_IT) >> 0x05);
 2053              		.loc 1 1387 16
 2054 001c 7B88     		ldrh	r3, [r7, #2]	@ movhi
 2055 001e DBB2     		uxtb	r3, r3
 2056              		.loc 1 1387 35
 2057 0020 5B09     		lsrs	r3, r3, #5
 2058 0022 DBB2     		uxtb	r3, r3
 2059              		.loc 1 1387 12
 2060 0024 BB60     		str	r3, [r7, #8]
1388:./Lib/Src/stm32f4xx_usart.c ****   /* Get the interrupt position */
1389:./Lib/Src/stm32f4xx_usart.c ****   itmask = USART_IT & IT_MASK;
 2061              		.loc 1 1389 21
 2062 0026 7B88     		ldrh	r3, [r7, #2]
 2063              		.loc 1 1389 10
 2064 0028 03F01F03 		and	r3, r3, #31
 2065 002c 7B61     		str	r3, [r7, #20]
1390:./Lib/Src/stm32f4xx_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 2066              		.loc 1 1390 10
 2067 002e 0122     		movs	r2, #1
 2068 0030 7B69     		ldr	r3, [r7, #20]
 2069 0032 02FA03F3 		lsl	r3, r2, r3
 2070 0036 7B61     		str	r3, [r7, #20]
1391:./Lib/Src/stm32f4xx_usart.c ****   
1392:./Lib/Src/stm32f4xx_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 2071              		.loc 1 1392 6
 2072 0038 BB68     		ldr	r3, [r7, #8]
 2073 003a 012B     		cmp	r3, #1
 2074 003c 07D1     		bne	.L89
1393:./Lib/Src/stm32f4xx_usart.c ****   {
1394:./Lib/Src/stm32f4xx_usart.c ****     itmask &= USARTx->CR1;
 2075              		.loc 1 1394 21
 2076 003e 7B68     		ldr	r3, [r7, #4]
 2077 0040 9B89     		ldrh	r3, [r3, #12]	@ movhi
 2078 0042 9BB2     		uxth	r3, r3
 2079 0044 1A46     		mov	r2, r3
 2080              		.loc 1 1394 12
 2081 0046 7B69     		ldr	r3, [r7, #20]
 2082 0048 1340     		ands	r3, r3, r2
 2083 004a 7B61     		str	r3, [r7, #20]
 2084 004c 11E0     		b	.L90
 2085              	.L89:
1395:./Lib/Src/stm32f4xx_usart.c ****   }
1396:./Lib/Src/stm32f4xx_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 2086              		.loc 1 1396 11
 2087 004e BB68     		ldr	r3, [r7, #8]
ARM GAS  /tmp/cc9pQZm7.s 			page 62


 2088 0050 022B     		cmp	r3, #2
 2089 0052 07D1     		bne	.L91
1397:./Lib/Src/stm32f4xx_usart.c ****   {
1398:./Lib/Src/stm32f4xx_usart.c ****     itmask &= USARTx->CR2;
 2090              		.loc 1 1398 21
 2091 0054 7B68     		ldr	r3, [r7, #4]
 2092 0056 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 2093 0058 9BB2     		uxth	r3, r3
 2094 005a 1A46     		mov	r2, r3
 2095              		.loc 1 1398 12
 2096 005c 7B69     		ldr	r3, [r7, #20]
 2097 005e 1340     		ands	r3, r3, r2
 2098 0060 7B61     		str	r3, [r7, #20]
 2099 0062 06E0     		b	.L90
 2100              	.L91:
1399:./Lib/Src/stm32f4xx_usart.c ****   }
1400:./Lib/Src/stm32f4xx_usart.c ****   else /* The IT  is in CR3 register */
1401:./Lib/Src/stm32f4xx_usart.c ****   {
1402:./Lib/Src/stm32f4xx_usart.c ****     itmask &= USARTx->CR3;
 2101              		.loc 1 1402 21
 2102 0064 7B68     		ldr	r3, [r7, #4]
 2103 0066 9B8A     		ldrh	r3, [r3, #20]	@ movhi
 2104 0068 9BB2     		uxth	r3, r3
 2105 006a 1A46     		mov	r2, r3
 2106              		.loc 1 1402 12
 2107 006c 7B69     		ldr	r3, [r7, #20]
 2108 006e 1340     		ands	r3, r3, r2
 2109 0070 7B61     		str	r3, [r7, #20]
 2110              	.L90:
1403:./Lib/Src/stm32f4xx_usart.c ****   }
1404:./Lib/Src/stm32f4xx_usart.c ****   
1405:./Lib/Src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
 2111              		.loc 1 1405 21
 2112 0072 7B88     		ldrh	r3, [r7, #2]
 2113 0074 1B0A     		lsrs	r3, r3, #8
 2114 0076 9BB2     		uxth	r3, r3
 2115              		.loc 1 1405 10
 2116 0078 FB60     		str	r3, [r7, #12]
1406:./Lib/Src/stm32f4xx_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 2117              		.loc 1 1406 10
 2118 007a 0122     		movs	r2, #1
 2119 007c FB68     		ldr	r3, [r7, #12]
 2120 007e 02FA03F3 		lsl	r3, r2, r3
 2121 0082 FB60     		str	r3, [r7, #12]
1407:./Lib/Src/stm32f4xx_usart.c ****   bitpos &= USARTx->SR;
 2122              		.loc 1 1407 19
 2123 0084 7B68     		ldr	r3, [r7, #4]
 2124 0086 1B88     		ldrh	r3, [r3]	@ movhi
 2125 0088 9BB2     		uxth	r3, r3
 2126 008a 1A46     		mov	r2, r3
 2127              		.loc 1 1407 10
 2128 008c FB68     		ldr	r3, [r7, #12]
 2129 008e 1340     		ands	r3, r3, r2
 2130 0090 FB60     		str	r3, [r7, #12]
1408:./Lib/Src/stm32f4xx_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 2131              		.loc 1 1408 6
 2132 0092 7B69     		ldr	r3, [r7, #20]
ARM GAS  /tmp/cc9pQZm7.s 			page 63


 2133 0094 002B     		cmp	r3, #0
 2134 0096 05D0     		beq	.L92
 2135              		.loc 1 1408 34 discriminator 1
 2136 0098 FB68     		ldr	r3, [r7, #12]
 2137 009a 002B     		cmp	r3, #0
 2138 009c 02D0     		beq	.L92
1409:./Lib/Src/stm32f4xx_usart.c ****   {
1410:./Lib/Src/stm32f4xx_usart.c ****     bitstatus = SET;
 2139              		.loc 1 1410 15
 2140 009e 0123     		movs	r3, #1
 2141 00a0 FB74     		strb	r3, [r7, #19]
 2142 00a2 01E0     		b	.L93
 2143              	.L92:
1411:./Lib/Src/stm32f4xx_usart.c ****   }
1412:./Lib/Src/stm32f4xx_usart.c ****   else
1413:./Lib/Src/stm32f4xx_usart.c ****   {
1414:./Lib/Src/stm32f4xx_usart.c ****     bitstatus = RESET;
 2144              		.loc 1 1414 15
 2145 00a4 0023     		movs	r3, #0
 2146 00a6 FB74     		strb	r3, [r7, #19]
 2147              	.L93:
1415:./Lib/Src/stm32f4xx_usart.c ****   }
1416:./Lib/Src/stm32f4xx_usart.c ****   
1417:./Lib/Src/stm32f4xx_usart.c ****   return bitstatus;  
 2148              		.loc 1 1417 10
 2149 00a8 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
1418:./Lib/Src/stm32f4xx_usart.c **** }
 2150              		.loc 1 1418 1
 2151 00aa 1846     		mov	r0, r3
 2152 00ac 1C37     		adds	r7, r7, #28
 2153              		.cfi_def_cfa_offset 4
 2154 00ae BD46     		mov	sp, r7
 2155              		.cfi_def_cfa_register 13
 2156              		@ sp needed
 2157 00b0 5DF8047B 		ldr	r7, [sp], #4
 2158              		.cfi_restore 7
 2159              		.cfi_def_cfa_offset 0
 2160 00b4 7047     		bx	lr
 2161              		.cfi_endproc
 2162              	.LFE150:
 2164              		.section	.text.USART_ClearITPendingBit,"ax",%progbits
 2165              		.align	1
 2166              		.global	USART_ClearITPendingBit
 2167              		.syntax unified
 2168              		.thumb
 2169              		.thumb_func
 2171              	USART_ClearITPendingBit:
 2172              	.LFB151:
1419:./Lib/Src/stm32f4xx_usart.c **** 
1420:./Lib/Src/stm32f4xx_usart.c **** /**
1421:./Lib/Src/stm32f4xx_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
1422:./Lib/Src/stm32f4xx_usart.c ****   * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
1423:./Lib/Src/stm32f4xx_usart.c ****   *         UART peripheral.
1424:./Lib/Src/stm32f4xx_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
1425:./Lib/Src/stm32f4xx_usart.c ****   *          This parameter can be one of the following values:
1426:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
1427:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_LBD:  LIN Break detection interrupt
ARM GAS  /tmp/cc9pQZm7.s 			page 64


1428:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_TC:   Transmission complete interrupt. 
1429:./Lib/Src/stm32f4xx_usart.c ****   *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
1430:./Lib/Src/stm32f4xx_usart.c ****   *
1431:./Lib/Src/stm32f4xx_usart.c ****   * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
1432:./Lib/Src/stm32f4xx_usart.c ****   *          error) and IDLE (Idle line detected) pending bits are cleared by 
1433:./Lib/Src/stm32f4xx_usart.c ****   *          software sequence: a read operation to USART_SR register 
1434:./Lib/Src/stm32f4xx_usart.c ****   *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
1435:./Lib/Src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1436:./Lib/Src/stm32f4xx_usart.c ****   * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
1437:./Lib/Src/stm32f4xx_usart.c ****   *          (USART_ReceiveData()).
1438:./Lib/Src/stm32f4xx_usart.c ****   * @note   TC pending bit can be also cleared by software sequence: a read 
1439:./Lib/Src/stm32f4xx_usart.c ****   *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
1440:./Lib/Src/stm32f4xx_usart.c ****   *          operation to USART_DR register (USART_SendData()).
1441:./Lib/Src/stm32f4xx_usart.c ****   * @note   TXE pending bit is cleared only by a write to the USART_DR register 
1442:./Lib/Src/stm32f4xx_usart.c ****   *          (USART_SendData()).
1443:./Lib/Src/stm32f4xx_usart.c ****   *  
1444:./Lib/Src/stm32f4xx_usart.c ****   * @retval None
1445:./Lib/Src/stm32f4xx_usart.c ****   */
1446:./Lib/Src/stm32f4xx_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
1447:./Lib/Src/stm32f4xx_usart.c **** {
 2173              		.loc 1 1447 1
 2174              		.cfi_startproc
 2175              		@ args = 0, pretend = 0, frame = 16
 2176              		@ frame_needed = 1, uses_anonymous_args = 0
 2177              		@ link register save eliminated.
 2178 0000 80B4     		push	{r7}
 2179              		.cfi_def_cfa_offset 4
 2180              		.cfi_offset 7, -4
 2181 0002 85B0     		sub	sp, sp, #20
 2182              		.cfi_def_cfa_offset 24
 2183 0004 00AF     		add	r7, sp, #0
 2184              		.cfi_def_cfa_register 7
 2185 0006 7860     		str	r0, [r7, #4]
 2186 0008 0B46     		mov	r3, r1
 2187 000a 7B80     		strh	r3, [r7, #2]	@ movhi
1448:./Lib/Src/stm32f4xx_usart.c ****   uint16_t bitpos = 0x00, itmask = 0x00;
 2188              		.loc 1 1448 12
 2189 000c 0023     		movs	r3, #0
 2190 000e FB81     		strh	r3, [r7, #14]	@ movhi
 2191              		.loc 1 1448 27
 2192 0010 0023     		movs	r3, #0
 2193 0012 BB81     		strh	r3, [r7, #12]	@ movhi
1449:./Lib/Src/stm32f4xx_usart.c ****   /* Check the parameters */
1450:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1451:./Lib/Src/stm32f4xx_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT)); 
1452:./Lib/Src/stm32f4xx_usart.c **** 
1453:./Lib/Src/stm32f4xx_usart.c ****   /* The CTS interrupt is not available for UART4 and UART5 */
1454:./Lib/Src/stm32f4xx_usart.c ****   if (USART_IT == USART_IT_CTS)
1455:./Lib/Src/stm32f4xx_usart.c ****   {
1456:./Lib/Src/stm32f4xx_usart.c ****     assert_param(IS_USART_1236_PERIPH(USARTx));
1457:./Lib/Src/stm32f4xx_usart.c ****   } 
1458:./Lib/Src/stm32f4xx_usart.c ****     
1459:./Lib/Src/stm32f4xx_usart.c ****   bitpos = USART_IT >> 0x08;
 2194              		.loc 1 1459 10
 2195 0014 7B88     		ldrh	r3, [r7, #2]
 2196 0016 1B0A     		lsrs	r3, r3, #8
 2197 0018 FB81     		strh	r3, [r7, #14]	@ movhi
ARM GAS  /tmp/cc9pQZm7.s 			page 65


1460:./Lib/Src/stm32f4xx_usart.c ****   itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 2198              		.loc 1 1460 31
 2199 001a FB89     		ldrh	r3, [r7, #14]
 2200              		.loc 1 1460 28
 2201 001c 0122     		movs	r2, #1
 2202 001e 02FA03F3 		lsl	r3, r2, r3
 2203              		.loc 1 1460 10
 2204 0022 BB81     		strh	r3, [r7, #12]	@ movhi
1461:./Lib/Src/stm32f4xx_usart.c ****   USARTx->SR = (uint16_t)~itmask;
 2205              		.loc 1 1461 16
 2206 0024 BB89     		ldrh	r3, [r7, #12]	@ movhi
 2207 0026 DB43     		mvns	r3, r3
 2208 0028 9AB2     		uxth	r2, r3
 2209              		.loc 1 1461 14
 2210 002a 7B68     		ldr	r3, [r7, #4]
 2211 002c 1A80     		strh	r2, [r3]	@ movhi
1462:./Lib/Src/stm32f4xx_usart.c **** }
 2212              		.loc 1 1462 1
 2213 002e 00BF     		nop
 2214 0030 1437     		adds	r7, r7, #20
 2215              		.cfi_def_cfa_offset 4
 2216 0032 BD46     		mov	sp, r7
 2217              		.cfi_def_cfa_register 13
 2218              		@ sp needed
 2219 0034 5DF8047B 		ldr	r7, [sp], #4
 2220              		.cfi_restore 7
 2221              		.cfi_def_cfa_offset 0
 2222 0038 7047     		bx	lr
 2223              		.cfi_endproc
 2224              	.LFE151:
 2226              		.text
 2227              	.Letext0:
 2228              		.file 2 "/usr/lib/gcc/arm-none-eabi/12.2.1/include/stdint.h"
 2229              		.file 3 "./Start/stm32f4xx.h"
 2230              		.file 4 "./Lib/inc/stm32f4xx_rcc.h"
 2231              		.file 5 "./Lib/inc/stm32f4xx_usart.h"
ARM GAS  /tmp/cc9pQZm7.s 			page 66


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f4xx_usart.c
     /tmp/cc9pQZm7.s:21     .text.USART_DeInit:0000000000000000 $t
     /tmp/cc9pQZm7.s:27     .text.USART_DeInit:0000000000000000 USART_DeInit
     /tmp/cc9pQZm7.s:179    .text.USART_DeInit:00000000000000f8 $d
     /tmp/cc9pQZm7.s:191    .text.USART_Init:0000000000000000 $t
     /tmp/cc9pQZm7.s:197    .text.USART_Init:0000000000000000 USART_Init
     /tmp/cc9pQZm7.s:454    .text.USART_Init:0000000000000168 $d
     /tmp/cc9pQZm7.s:462    .text.USART_StructInit:0000000000000000 $t
     /tmp/cc9pQZm7.s:468    .text.USART_StructInit:0000000000000000 USART_StructInit
     /tmp/cc9pQZm7.s:522    .text.USART_ClockInit:0000000000000000 $t
     /tmp/cc9pQZm7.s:528    .text.USART_ClockInit:0000000000000000 USART_ClockInit
     /tmp/cc9pQZm7.s:604    .text.USART_ClockStructInit:0000000000000000 $t
     /tmp/cc9pQZm7.s:610    .text.USART_ClockStructInit:0000000000000000 USART_ClockStructInit
     /tmp/cc9pQZm7.s:656    .text.USART_Cmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:662    .text.USART_Cmd:0000000000000000 USART_Cmd
     /tmp/cc9pQZm7.s:720    .text.USART_SetPrescaler:0000000000000000 $t
     /tmp/cc9pQZm7.s:726    .text.USART_SetPrescaler:0000000000000000 USART_SetPrescaler
     /tmp/cc9pQZm7.s:778    .text.USART_OverSampling8Cmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:784    .text.USART_OverSampling8Cmd:0000000000000000 USART_OverSampling8Cmd
     /tmp/cc9pQZm7.s:843    .text.USART_OneBitMethodCmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:849    .text.USART_OneBitMethodCmd:0000000000000000 USART_OneBitMethodCmd
     /tmp/cc9pQZm7.s:907    .text.USART_SendData:0000000000000000 $t
     /tmp/cc9pQZm7.s:913    .text.USART_SendData:0000000000000000 USART_SendData
     /tmp/cc9pQZm7.s:952    .text.USART_ReceiveData:0000000000000000 $t
     /tmp/cc9pQZm7.s:958    .text.USART_ReceiveData:0000000000000000 USART_ReceiveData
     /tmp/cc9pQZm7.s:995    .text.USART_SetAddress:0000000000000000 $t
     /tmp/cc9pQZm7.s:1001   .text.USART_SetAddress:0000000000000000 USART_SetAddress
     /tmp/cc9pQZm7.s:1053   .text.USART_ReceiverWakeUpCmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:1059   .text.USART_ReceiverWakeUpCmd:0000000000000000 USART_ReceiverWakeUpCmd
     /tmp/cc9pQZm7.s:1117   .text.USART_WakeUpConfig:0000000000000000 $t
     /tmp/cc9pQZm7.s:1123   .text.USART_WakeUpConfig:0000000000000000 USART_WakeUpConfig
     /tmp/cc9pQZm7.s:1174   .text.USART_LINBreakDetectLengthConfig:0000000000000000 $t
     /tmp/cc9pQZm7.s:1180   .text.USART_LINBreakDetectLengthConfig:0000000000000000 USART_LINBreakDetectLengthConfig
     /tmp/cc9pQZm7.s:1231   .text.USART_LINCmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:1237   .text.USART_LINCmd:0000000000000000 USART_LINCmd
     /tmp/cc9pQZm7.s:1295   .text.USART_SendBreak:0000000000000000 $t
     /tmp/cc9pQZm7.s:1301   .text.USART_SendBreak:0000000000000000 USART_SendBreak
     /tmp/cc9pQZm7.s:1340   .text.USART_HalfDuplexCmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:1346   .text.USART_HalfDuplexCmd:0000000000000000 USART_HalfDuplexCmd
     /tmp/cc9pQZm7.s:1404   .text.USART_SetGuardTime:0000000000000000 $t
     /tmp/cc9pQZm7.s:1410   .text.USART_SetGuardTime:0000000000000000 USART_SetGuardTime
     /tmp/cc9pQZm7.s:1465   .text.USART_SmartCardCmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:1471   .text.USART_SmartCardCmd:0000000000000000 USART_SmartCardCmd
     /tmp/cc9pQZm7.s:1529   .text.USART_SmartCardNACKCmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:1535   .text.USART_SmartCardNACKCmd:0000000000000000 USART_SmartCardNACKCmd
     /tmp/cc9pQZm7.s:1593   .text.USART_IrDAConfig:0000000000000000 $t
     /tmp/cc9pQZm7.s:1599   .text.USART_IrDAConfig:0000000000000000 USART_IrDAConfig
     /tmp/cc9pQZm7.s:1650   .text.USART_IrDACmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:1656   .text.USART_IrDACmd:0000000000000000 USART_IrDACmd
     /tmp/cc9pQZm7.s:1714   .text.USART_DMACmd:0000000000000000 $t
     /tmp/cc9pQZm7.s:1720   .text.USART_DMACmd:0000000000000000 USART_DMACmd
     /tmp/cc9pQZm7.s:1785   .text.USART_ITConfig:0000000000000000 $t
     /tmp/cc9pQZm7.s:1791   .text.USART_ITConfig:0000000000000000 USART_ITConfig
     /tmp/cc9pQZm7.s:1910   .text.USART_GetFlagStatus:0000000000000000 $t
     /tmp/cc9pQZm7.s:1916   .text.USART_GetFlagStatus:0000000000000000 USART_GetFlagStatus
     /tmp/cc9pQZm7.s:1973   .text.USART_ClearFlag:0000000000000000 $t
ARM GAS  /tmp/cc9pQZm7.s 			page 67


     /tmp/cc9pQZm7.s:1979   .text.USART_ClearFlag:0000000000000000 USART_ClearFlag
     /tmp/cc9pQZm7.s:2018   .text.USART_GetITStatus:0000000000000000 $t
     /tmp/cc9pQZm7.s:2024   .text.USART_GetITStatus:0000000000000000 USART_GetITStatus
     /tmp/cc9pQZm7.s:2165   .text.USART_ClearITPendingBit:0000000000000000 $t
     /tmp/cc9pQZm7.s:2171   .text.USART_ClearITPendingBit:0000000000000000 USART_ClearITPendingBit

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
