ARM GAS  /tmp/ccNgkk2X.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"stm32f4xx_pwr.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "./Lib/Src/stm32f4xx_pwr.c"
  20              		.section	.text.PWR_DeInit,"ax",%progbits
  21              		.align	1
  22              		.global	PWR_DeInit
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	PWR_DeInit:
  28              	.LFB123:
   1:./Lib/Src/stm32f4xx_pwr.c **** /**
   2:./Lib/Src/stm32f4xx_pwr.c ****   ******************************************************************************
   3:./Lib/Src/stm32f4xx_pwr.c ****   * @file    stm32f4xx_pwr.c
   4:./Lib/Src/stm32f4xx_pwr.c ****   * @author  MCD Application Team
   5:./Lib/Src/stm32f4xx_pwr.c ****   * @version V1.8.1
   6:./Lib/Src/stm32f4xx_pwr.c ****   * @date    27-January-2022
   7:./Lib/Src/stm32f4xx_pwr.c ****   * @brief   This file provides firmware functions to manage the following 
   8:./Lib/Src/stm32f4xx_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:           
   9:./Lib/Src/stm32f4xx_pwr.c ****   *           + Backup Domain Access
  10:./Lib/Src/stm32f4xx_pwr.c ****   *           + PVD configuration
  11:./Lib/Src/stm32f4xx_pwr.c ****   *           + WakeUp pin configuration
  12:./Lib/Src/stm32f4xx_pwr.c ****   *           + Main and Backup Regulators configuration
  13:./Lib/Src/stm32f4xx_pwr.c ****   *           + FLASH Power Down configuration
  14:./Lib/Src/stm32f4xx_pwr.c ****   *           + Low Power modes configuration
  15:./Lib/Src/stm32f4xx_pwr.c ****   *           + Flags management
  16:./Lib/Src/stm32f4xx_pwr.c ****   *               
  17:./Lib/Src/stm32f4xx_pwr.c ****   ******************************************************************************
  18:./Lib/Src/stm32f4xx_pwr.c ****   * @attention
  19:./Lib/Src/stm32f4xx_pwr.c ****   *
  20:./Lib/Src/stm32f4xx_pwr.c ****   * Copyright (c) 2016 STMicroelectronics.
  21:./Lib/Src/stm32f4xx_pwr.c ****   * All rights reserved.
  22:./Lib/Src/stm32f4xx_pwr.c ****   *
  23:./Lib/Src/stm32f4xx_pwr.c ****   * This software is licensed under terms that can be found in the LICENSE file
  24:./Lib/Src/stm32f4xx_pwr.c ****   * in the root directory of this software component.
  25:./Lib/Src/stm32f4xx_pwr.c ****   * If no LICENSE file comes with this software, it is provided AS-IS.
  26:./Lib/Src/stm32f4xx_pwr.c ****   *
  27:./Lib/Src/stm32f4xx_pwr.c ****   ******************************************************************************
  28:./Lib/Src/stm32f4xx_pwr.c ****   */
  29:./Lib/Src/stm32f4xx_pwr.c **** 
  30:./Lib/Src/stm32f4xx_pwr.c **** /* Includes ------------------------------------------------------------------*/
ARM GAS  /tmp/ccNgkk2X.s 			page 2


  31:./Lib/Src/stm32f4xx_pwr.c **** #include "stm32f4xx_pwr.h"
  32:./Lib/Src/stm32f4xx_pwr.c **** #include "stm32f4xx_rcc.h"
  33:./Lib/Src/stm32f4xx_pwr.c **** 
  34:./Lib/Src/stm32f4xx_pwr.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  35:./Lib/Src/stm32f4xx_pwr.c ****   * @{
  36:./Lib/Src/stm32f4xx_pwr.c ****   */
  37:./Lib/Src/stm32f4xx_pwr.c **** 
  38:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR 
  39:./Lib/Src/stm32f4xx_pwr.c ****   * @brief PWR driver modules
  40:./Lib/Src/stm32f4xx_pwr.c ****   * @{
  41:./Lib/Src/stm32f4xx_pwr.c ****   */ 
  42:./Lib/Src/stm32f4xx_pwr.c **** 
  43:./Lib/Src/stm32f4xx_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  44:./Lib/Src/stm32f4xx_pwr.c **** /* Private define ------------------------------------------------------------*/
  45:./Lib/Src/stm32f4xx_pwr.c **** /* --------- PWR registers bit address in the alias region ---------- */
  46:./Lib/Src/stm32f4xx_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  47:./Lib/Src/stm32f4xx_pwr.c **** 
  48:./Lib/Src/stm32f4xx_pwr.c **** /* --- CR Register ---*/
  49:./Lib/Src/stm32f4xx_pwr.c **** 
  50:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of DBP bit */
  51:./Lib/Src/stm32f4xx_pwr.c **** #define CR_OFFSET                (PWR_OFFSET + 0x00)
  52:./Lib/Src/stm32f4xx_pwr.c **** #define DBP_BitNumber            0x08
  53:./Lib/Src/stm32f4xx_pwr.c **** #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
  54:./Lib/Src/stm32f4xx_pwr.c **** 
  55:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of PVDE bit */
  56:./Lib/Src/stm32f4xx_pwr.c **** #define PVDE_BitNumber           0x04
  57:./Lib/Src/stm32f4xx_pwr.c **** #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
  58:./Lib/Src/stm32f4xx_pwr.c **** 
  59:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of FPDS bit */
  60:./Lib/Src/stm32f4xx_pwr.c **** #define FPDS_BitNumber           0x09
  61:./Lib/Src/stm32f4xx_pwr.c **** #define CR_FPDS_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (FPDS_BitNumber * 4))
  62:./Lib/Src/stm32f4xx_pwr.c **** 
  63:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of PMODE bit */
  64:./Lib/Src/stm32f4xx_pwr.c **** #define PMODE_BitNumber           0x0E
  65:./Lib/Src/stm32f4xx_pwr.c **** #define CR_PMODE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PMODE_BitNumber * 4))
  66:./Lib/Src/stm32f4xx_pwr.c **** 
  67:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of ODEN bit */
  68:./Lib/Src/stm32f4xx_pwr.c **** #define ODEN_BitNumber           0x10
  69:./Lib/Src/stm32f4xx_pwr.c **** #define CR_ODEN_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODEN_BitNumber * 4))
  70:./Lib/Src/stm32f4xx_pwr.c **** 
  71:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of ODSWEN bit */
  72:./Lib/Src/stm32f4xx_pwr.c **** #define ODSWEN_BitNumber         0x11
  73:./Lib/Src/stm32f4xx_pwr.c **** #define CR_ODSWEN_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODSWEN_BitNumber * 4))
  74:./Lib/Src/stm32f4xx_pwr.c **** 
  75:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx)
  76:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of MRUDS bit */
  77:./Lib/Src/stm32f4xx_pwr.c **** #define MRUDS_BitNumber         0x0B
  78:./Lib/Src/stm32f4xx_pwr.c **** #define CR_MRUDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (MRUDS_BitNumber * 4))
  79:./Lib/Src/stm32f4xx_pwr.c **** 
  80:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of LPUDS bit */
  81:./Lib/Src/stm32f4xx_pwr.c **** #define LPUDS_BitNumber         0x0A
  82:./Lib/Src/stm32f4xx_pwr.c **** #define CR_LPUDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (LPUDS_BitNumber * 4))
  83:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F427_437xx || STM32F429_439xx || STM32F446xx */
  84:./Lib/Src/stm32f4xx_pwr.c **** 
  85:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F412xG) ||
  86:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of MRLVDS bit */
  87:./Lib/Src/stm32f4xx_pwr.c **** #define MRLVDS_BitNumber         0x0B
ARM GAS  /tmp/ccNgkk2X.s 			page 3


  88:./Lib/Src/stm32f4xx_pwr.c **** #define CR_MRLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (MRLVDS_BitNumber * 4))
  89:./Lib/Src/stm32f4xx_pwr.c **** 
  90:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of LPLVDS bit */
  91:./Lib/Src/stm32f4xx_pwr.c **** #define LPLVDS_BitNumber         0x0A
  92:./Lib/Src/stm32f4xx_pwr.c **** #define CR_LPLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (LPLVDS_BitNumber * 4))
  93:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F401xx || STM32F410xx || STM32F411xE || STM32F412xG || STM32F413_423xx */
  94:./Lib/Src/stm32f4xx_pwr.c **** 
  95:./Lib/Src/stm32f4xx_pwr.c **** /* --- CSR Register ---*/
  96:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM3
  97:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of EWUP bit */
  98:./Lib/Src/stm32f4xx_pwr.c **** #define CSR_OFFSET               (PWR_OFFSET + 0x04)
  99:./Lib/Src/stm32f4xx_pwr.c **** #define EWUP_BitNumber           0x08
 100:./Lib/Src/stm32f4xx_pwr.c **** #define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
 101:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F410xx || STM
 102:./Lib/Src/stm32f4xx_pwr.c **** 
 103:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx
 104:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of EWUP2 bit */
 105:./Lib/Src/stm32f4xx_pwr.c **** #define CSR_OFFSET               (PWR_OFFSET + 0x04)
 106:./Lib/Src/stm32f4xx_pwr.c **** #define EWUP1_BitNumber           0x08
 107:./Lib/Src/stm32f4xx_pwr.c **** #define CSR_EWUP1_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP1_BitNumber * 4))
 108:./Lib/Src/stm32f4xx_pwr.c **** #define EWUP2_BitNumber           0x07
 109:./Lib/Src/stm32f4xx_pwr.c **** #define CSR_EWUP2_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP2_BitNumber * 4))
 110:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
 111:./Lib/Src/stm32f4xx_pwr.c **** #define EWUP3_BitNumber           0x06
 112:./Lib/Src/stm32f4xx_pwr.c **** #define CSR_EWUP3_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP2_BitNumber * 4))
 113:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F410xx || STM32F412xG || STM32F413_423xx */
 114:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
 115:./Lib/Src/stm32f4xx_pwr.c **** 
 116:./Lib/Src/stm32f4xx_pwr.c **** /* Alias word address of BRE bit */
 117:./Lib/Src/stm32f4xx_pwr.c **** #define BRE_BitNumber            0x09
 118:./Lib/Src/stm32f4xx_pwr.c **** #define CSR_BRE_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (BRE_BitNumber * 4))
 119:./Lib/Src/stm32f4xx_pwr.c **** 
 120:./Lib/Src/stm32f4xx_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
 121:./Lib/Src/stm32f4xx_pwr.c **** 
 122:./Lib/Src/stm32f4xx_pwr.c **** /* CR register bit mask */
 123:./Lib/Src/stm32f4xx_pwr.c **** #define CR_DS_MASK               ((uint32_t)0xFFFFF3FC)
 124:./Lib/Src/stm32f4xx_pwr.c **** #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
 125:./Lib/Src/stm32f4xx_pwr.c **** #define CR_VOS_MASK              ((uint32_t)0xFFFF3FFF)
 126:./Lib/Src/stm32f4xx_pwr.c **** 
 127:./Lib/Src/stm32f4xx_pwr.c **** /* Private macro -------------------------------------------------------------*/
 128:./Lib/Src/stm32f4xx_pwr.c **** /* Private variables ---------------------------------------------------------*/
 129:./Lib/Src/stm32f4xx_pwr.c **** /* Private function prototypes -----------------------------------------------*/
 130:./Lib/Src/stm32f4xx_pwr.c **** /* Private functions ---------------------------------------------------------*/
 131:./Lib/Src/stm32f4xx_pwr.c **** 
 132:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Private_Functions
 133:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 134:./Lib/Src/stm32f4xx_pwr.c ****   */
 135:./Lib/Src/stm32f4xx_pwr.c **** 
 136:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group1 Backup Domain Access function 
 137:./Lib/Src/stm32f4xx_pwr.c ****   *  @brief   Backup Domain Access function  
 138:./Lib/Src/stm32f4xx_pwr.c ****   *
 139:./Lib/Src/stm32f4xx_pwr.c **** @verbatim   
 140:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================
 141:./Lib/Src/stm32f4xx_pwr.c ****                   ##### Backup Domain Access function #####
 142:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================  
 143:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 144:./Lib/Src/stm32f4xx_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data 
ARM GAS  /tmp/ccNgkk2X.s 			page 4


 145:./Lib/Src/stm32f4xx_pwr.c ****       registers and backup SRAM) is protected against possible unwanted 
 146:./Lib/Src/stm32f4xx_pwr.c ****       write accesses. 
 147:./Lib/Src/stm32f4xx_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
 148:./Lib/Src/stm32f4xx_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
 149:./Lib/Src/stm32f4xx_pwr.c ****             RCC_APB1PeriphClockCmd() function.
 150:./Lib/Src/stm32f4xx_pwr.c ****         (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
 151:./Lib/Src/stm32f4xx_pwr.c **** 
 152:./Lib/Src/stm32f4xx_pwr.c **** @endverbatim
 153:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 154:./Lib/Src/stm32f4xx_pwr.c ****   */
 155:./Lib/Src/stm32f4xx_pwr.c **** 
 156:./Lib/Src/stm32f4xx_pwr.c **** /**
 157:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
 158:./Lib/Src/stm32f4xx_pwr.c ****   * @param  None
 159:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 160:./Lib/Src/stm32f4xx_pwr.c ****   */
 161:./Lib/Src/stm32f4xx_pwr.c **** void PWR_DeInit(void)
 162:./Lib/Src/stm32f4xx_pwr.c **** {
  29              		.loc 1 162 1
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 80B5     		push	{r7, lr}
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 00AF     		add	r7, sp, #0
  38              		.cfi_def_cfa_register 7
 163:./Lib/Src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  39              		.loc 1 163 3
  40 0004 0121     		movs	r1, #1
  41 0006 4FF08050 		mov	r0, #268435456
  42 000a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 164:./Lib/Src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
  43              		.loc 1 164 3
  44 000e 0021     		movs	r1, #0
  45 0010 4FF08050 		mov	r0, #268435456
  46 0014 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 165:./Lib/Src/stm32f4xx_pwr.c **** }
  47              		.loc 1 165 1
  48 0018 00BF     		nop
  49 001a 80BD     		pop	{r7, pc}
  50              		.cfi_endproc
  51              	.LFE123:
  53              		.section	.text.PWR_BackupAccessCmd,"ax",%progbits
  54              		.align	1
  55              		.global	PWR_BackupAccessCmd
  56              		.syntax unified
  57              		.thumb
  58              		.thumb_func
  60              	PWR_BackupAccessCmd:
  61              	.LFB124:
 166:./Lib/Src/stm32f4xx_pwr.c **** 
 167:./Lib/Src/stm32f4xx_pwr.c **** /**
 168:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables access to the backup domain (RTC registers, RTC 
 169:./Lib/Src/stm32f4xx_pwr.c ****   *         backup data registers and backup SRAM).
 170:./Lib/Src/stm32f4xx_pwr.c ****   * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
ARM GAS  /tmp/ccNgkk2X.s 			page 5


 171:./Lib/Src/stm32f4xx_pwr.c ****   *         Backup Domain Access should be kept enabled.
 172:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the access to the backup domain.
 173:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 174:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 175:./Lib/Src/stm32f4xx_pwr.c ****   */
 176:./Lib/Src/stm32f4xx_pwr.c **** void PWR_BackupAccessCmd(FunctionalState NewState)
 177:./Lib/Src/stm32f4xx_pwr.c **** {
  62              		.loc 1 177 1
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 1, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67 0000 80B4     		push	{r7}
  68              		.cfi_def_cfa_offset 4
  69              		.cfi_offset 7, -4
  70 0002 83B0     		sub	sp, sp, #12
  71              		.cfi_def_cfa_offset 16
  72 0004 00AF     		add	r7, sp, #0
  73              		.cfi_def_cfa_register 7
  74 0006 0346     		mov	r3, r0
  75 0008 FB71     		strb	r3, [r7, #7]
 178:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 179:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 180:./Lib/Src/stm32f4xx_pwr.c ****   
 181:./Lib/Src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
  76              		.loc 1 181 3
  77 000a 044A     		ldr	r2, .L3
  78              		.loc 1 181 34
  79 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  80              		.loc 1 181 32
  81 000e 1360     		str	r3, [r2]
 182:./Lib/Src/stm32f4xx_pwr.c **** }
  82              		.loc 1 182 1
  83 0010 00BF     		nop
  84 0012 0C37     		adds	r7, r7, #12
  85              		.cfi_def_cfa_offset 4
  86 0014 BD46     		mov	sp, r7
  87              		.cfi_def_cfa_register 13
  88              		@ sp needed
  89 0016 5DF8047B 		ldr	r7, [sp], #4
  90              		.cfi_restore 7
  91              		.cfi_def_cfa_offset 0
  92 001a 7047     		bx	lr
  93              	.L4:
  94              		.align	2
  95              	.L3:
  96 001c 20000E42 		.word	1108213792
  97              		.cfi_endproc
  98              	.LFE124:
 100              		.section	.text.PWR_PVDLevelConfig,"ax",%progbits
 101              		.align	1
 102              		.global	PWR_PVDLevelConfig
 103              		.syntax unified
 104              		.thumb
 105              		.thumb_func
 107              	PWR_PVDLevelConfig:
 108              	.LFB125:
ARM GAS  /tmp/ccNgkk2X.s 			page 6


 183:./Lib/Src/stm32f4xx_pwr.c **** 
 184:./Lib/Src/stm32f4xx_pwr.c **** /**
 185:./Lib/Src/stm32f4xx_pwr.c ****   * @}
 186:./Lib/Src/stm32f4xx_pwr.c ****   */
 187:./Lib/Src/stm32f4xx_pwr.c **** 
 188:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group2 PVD configuration functions
 189:./Lib/Src/stm32f4xx_pwr.c ****   *  @brief   PVD configuration functions 
 190:./Lib/Src/stm32f4xx_pwr.c ****   *
 191:./Lib/Src/stm32f4xx_pwr.c **** @verbatim   
 192:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================
 193:./Lib/Src/stm32f4xx_pwr.c ****                     ##### PVD configuration functions #####
 194:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================  
 195:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 196:./Lib/Src/stm32f4xx_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a 
 197:./Lib/Src/stm32f4xx_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 198:./Lib/Src/stm32f4xx_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower 
 199:./Lib/Src/stm32f4xx_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI 
 200:./Lib/Src/stm32f4xx_pwr.c ****           line16 and can generate an interrupt if enabled through the EXTI registers.
 201:./Lib/Src/stm32f4xx_pwr.c ****       (+) The PVD is stopped in Standby mode.
 202:./Lib/Src/stm32f4xx_pwr.c **** 
 203:./Lib/Src/stm32f4xx_pwr.c **** @endverbatim
 204:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 205:./Lib/Src/stm32f4xx_pwr.c ****   */
 206:./Lib/Src/stm32f4xx_pwr.c **** 
 207:./Lib/Src/stm32f4xx_pwr.c **** /**
 208:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 209:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 210:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 211:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_0
 212:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_1
 213:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_2
 214:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_3
 215:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_4
 216:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_5
 217:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_6
 218:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_7
 219:./Lib/Src/stm32f4xx_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 220:./Lib/Src/stm32f4xx_pwr.c ****   *         more details about the voltage threshold corresponding to each 
 221:./Lib/Src/stm32f4xx_pwr.c ****   *         detection level.
 222:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 223:./Lib/Src/stm32f4xx_pwr.c ****   */
 224:./Lib/Src/stm32f4xx_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
 225:./Lib/Src/stm32f4xx_pwr.c **** {
 109              		.loc 1 225 1
 110              		.cfi_startproc
 111              		@ args = 0, pretend = 0, frame = 16
 112              		@ frame_needed = 1, uses_anonymous_args = 0
 113              		@ link register save eliminated.
 114 0000 80B4     		push	{r7}
 115              		.cfi_def_cfa_offset 4
 116              		.cfi_offset 7, -4
 117 0002 85B0     		sub	sp, sp, #20
 118              		.cfi_def_cfa_offset 24
 119 0004 00AF     		add	r7, sp, #0
 120              		.cfi_def_cfa_register 7
 121 0006 7860     		str	r0, [r7, #4]
 226:./Lib/Src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
ARM GAS  /tmp/ccNgkk2X.s 			page 7


 122              		.loc 1 226 12
 123 0008 0023     		movs	r3, #0
 124 000a FB60     		str	r3, [r7, #12]
 227:./Lib/Src/stm32f4xx_pwr.c ****   
 228:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 229:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 230:./Lib/Src/stm32f4xx_pwr.c ****   
 231:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 125              		.loc 1 231 15
 126 000c 094B     		ldr	r3, .L6
 127              		.loc 1 231 10
 128 000e 1B68     		ldr	r3, [r3]
 129 0010 FB60     		str	r3, [r7, #12]
 232:./Lib/Src/stm32f4xx_pwr.c ****   
 233:./Lib/Src/stm32f4xx_pwr.c ****   /* Clear PLS[7:5] bits */
 234:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg &= CR_PLS_MASK;
 130              		.loc 1 234 10
 131 0012 FB68     		ldr	r3, [r7, #12]
 132 0014 23F0E003 		bic	r3, r3, #224
 133 0018 FB60     		str	r3, [r7, #12]
 235:./Lib/Src/stm32f4xx_pwr.c ****   
 236:./Lib/Src/stm32f4xx_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 237:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg |= PWR_PVDLevel;
 134              		.loc 1 237 10
 135 001a FA68     		ldr	r2, [r7, #12]
 136 001c 7B68     		ldr	r3, [r7, #4]
 137 001e 1343     		orrs	r3, r3, r2
 138 0020 FB60     		str	r3, [r7, #12]
 238:./Lib/Src/stm32f4xx_pwr.c ****   
 239:./Lib/Src/stm32f4xx_pwr.c ****   /* Store the new value */
 240:./Lib/Src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 139              		.loc 1 240 6
 140 0022 044A     		ldr	r2, .L6
 141              		.loc 1 240 11
 142 0024 FB68     		ldr	r3, [r7, #12]
 143 0026 1360     		str	r3, [r2]
 241:./Lib/Src/stm32f4xx_pwr.c **** }
 144              		.loc 1 241 1
 145 0028 00BF     		nop
 146 002a 1437     		adds	r7, r7, #20
 147              		.cfi_def_cfa_offset 4
 148 002c BD46     		mov	sp, r7
 149              		.cfi_def_cfa_register 13
 150              		@ sp needed
 151 002e 5DF8047B 		ldr	r7, [sp], #4
 152              		.cfi_restore 7
 153              		.cfi_def_cfa_offset 0
 154 0032 7047     		bx	lr
 155              	.L7:
 156              		.align	2
 157              	.L6:
 158 0034 00700040 		.word	1073770496
 159              		.cfi_endproc
 160              	.LFE125:
 162              		.section	.text.PWR_PVDCmd,"ax",%progbits
 163              		.align	1
 164              		.global	PWR_PVDCmd
ARM GAS  /tmp/ccNgkk2X.s 			page 8


 165              		.syntax unified
 166              		.thumb
 167              		.thumb_func
 169              	PWR_PVDCmd:
 170              	.LFB126:
 242:./Lib/Src/stm32f4xx_pwr.c **** 
 243:./Lib/Src/stm32f4xx_pwr.c **** /**
 244:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 245:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the PVD.
 246:./Lib/Src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 247:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 248:./Lib/Src/stm32f4xx_pwr.c ****   */
 249:./Lib/Src/stm32f4xx_pwr.c **** void PWR_PVDCmd(FunctionalState NewState)
 250:./Lib/Src/stm32f4xx_pwr.c **** {
 171              		.loc 1 250 1
 172              		.cfi_startproc
 173              		@ args = 0, pretend = 0, frame = 8
 174              		@ frame_needed = 1, uses_anonymous_args = 0
 175              		@ link register save eliminated.
 176 0000 80B4     		push	{r7}
 177              		.cfi_def_cfa_offset 4
 178              		.cfi_offset 7, -4
 179 0002 83B0     		sub	sp, sp, #12
 180              		.cfi_def_cfa_offset 16
 181 0004 00AF     		add	r7, sp, #0
 182              		.cfi_def_cfa_register 7
 183 0006 0346     		mov	r3, r0
 184 0008 FB71     		strb	r3, [r7, #7]
 251:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 252:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 253:./Lib/Src/stm32f4xx_pwr.c ****   
 254:./Lib/Src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 185              		.loc 1 254 3
 186 000a 044A     		ldr	r2, .L9
 187              		.loc 1 254 35
 188 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 189              		.loc 1 254 33
 190 000e 1360     		str	r3, [r2]
 255:./Lib/Src/stm32f4xx_pwr.c **** }
 191              		.loc 1 255 1
 192 0010 00BF     		nop
 193 0012 0C37     		adds	r7, r7, #12
 194              		.cfi_def_cfa_offset 4
 195 0014 BD46     		mov	sp, r7
 196              		.cfi_def_cfa_register 13
 197              		@ sp needed
 198 0016 5DF8047B 		ldr	r7, [sp], #4
 199              		.cfi_restore 7
 200              		.cfi_def_cfa_offset 0
 201 001a 7047     		bx	lr
 202              	.L10:
 203              		.align	2
 204              	.L9:
 205 001c 10000E42 		.word	1108213776
 206              		.cfi_endproc
 207              	.LFE126:
 209              		.section	.text.PWR_WakeUpPinCmd,"ax",%progbits
ARM GAS  /tmp/ccNgkk2X.s 			page 9


 210              		.align	1
 211              		.global	PWR_WakeUpPinCmd
 212              		.syntax unified
 213              		.thumb
 214              		.thumb_func
 216              	PWR_WakeUpPinCmd:
 217              	.LFB127:
 256:./Lib/Src/stm32f4xx_pwr.c **** 
 257:./Lib/Src/stm32f4xx_pwr.c **** /**
 258:./Lib/Src/stm32f4xx_pwr.c ****   * @}
 259:./Lib/Src/stm32f4xx_pwr.c ****   */
 260:./Lib/Src/stm32f4xx_pwr.c **** 
 261:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group3 WakeUp pin configuration functions
 262:./Lib/Src/stm32f4xx_pwr.c ****   *  @brief   WakeUp pin configuration functions 
 263:./Lib/Src/stm32f4xx_pwr.c ****   *
 264:./Lib/Src/stm32f4xx_pwr.c **** @verbatim   
 265:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================
 266:./Lib/Src/stm32f4xx_pwr.c ****                  ##### WakeUp pin configuration functions #####
 267:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================  
 268:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 269:./Lib/Src/stm32f4xx_pwr.c ****       (+) WakeUp pin is used to wakeup the system from Standby mode. This pin is 
 270:./Lib/Src/stm32f4xx_pwr.c ****           forced in input pull down configuration and is active on rising edges.
 271:./Lib/Src/stm32f4xx_pwr.c ****       (+) There is one Wake-up pin: Wake-up Pin 1 on PA.00.
 272:./Lib/Src/stm32f4xx_pwr.c **** 	   (++) For STM32F446xx there are two Wake-Up pins: Pin1 on PA.00 and Pin2 on PC.13
 273:./Lib/Src/stm32f4xx_pwr.c ****            (++) For STM32F410xx/STM32F412xG/STM32F413_423xx there are three Wake-Up pins: Pin1 on P
 274:./Lib/Src/stm32f4xx_pwr.c **** @endverbatim
 275:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 276:./Lib/Src/stm32f4xx_pwr.c ****   */
 277:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM3
 278:./Lib/Src/stm32f4xx_pwr.c **** /**
 279:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 280:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 281:./Lib/Src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 282:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 283:./Lib/Src/stm32f4xx_pwr.c ****   */
 284:./Lib/Src/stm32f4xx_pwr.c **** void PWR_WakeUpPinCmd(FunctionalState NewState)
 285:./Lib/Src/stm32f4xx_pwr.c **** {
 218              		.loc 1 285 1
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 8
 221              		@ frame_needed = 1, uses_anonymous_args = 0
 222              		@ link register save eliminated.
 223 0000 80B4     		push	{r7}
 224              		.cfi_def_cfa_offset 4
 225              		.cfi_offset 7, -4
 226 0002 83B0     		sub	sp, sp, #12
 227              		.cfi_def_cfa_offset 16
 228 0004 00AF     		add	r7, sp, #0
 229              		.cfi_def_cfa_register 7
 230 0006 0346     		mov	r3, r0
 231 0008 FB71     		strb	r3, [r7, #7]
 286:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */  
 287:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 288:./Lib/Src/stm32f4xx_pwr.c **** 
 289:./Lib/Src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 232              		.loc 1 289 3
 233 000a 044A     		ldr	r2, .L12
ARM GAS  /tmp/ccNgkk2X.s 			page 10


 234              		.loc 1 289 36
 235 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 236              		.loc 1 289 34
 237 000e 1360     		str	r3, [r2]
 290:./Lib/Src/stm32f4xx_pwr.c **** }
 238              		.loc 1 290 1
 239 0010 00BF     		nop
 240 0012 0C37     		adds	r7, r7, #12
 241              		.cfi_def_cfa_offset 4
 242 0014 BD46     		mov	sp, r7
 243              		.cfi_def_cfa_register 13
 244              		@ sp needed
 245 0016 5DF8047B 		ldr	r7, [sp], #4
 246              		.cfi_restore 7
 247              		.cfi_def_cfa_offset 0
 248 001a 7047     		bx	lr
 249              	.L13:
 250              		.align	2
 251              	.L12:
 252 001c A0000E42 		.word	1108213920
 253              		.cfi_endproc
 254              	.LFE127:
 256              		.section	.text.PWR_BackupRegulatorCmd,"ax",%progbits
 257              		.align	1
 258              		.global	PWR_BackupRegulatorCmd
 259              		.syntax unified
 260              		.thumb
 261              		.thumb_func
 263              	PWR_BackupRegulatorCmd:
 264              	.LFB128:
 291:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
 292:./Lib/Src/stm32f4xx_pwr.c **** 
 293:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx
 294:./Lib/Src/stm32f4xx_pwr.c **** /**
 295:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 296:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_WakeUpPinx: specifies the WakeUp Pin.
 297:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 298:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_WakeUp_Pin1: WKUP1 pin is used for wakeup from Standby mode.
 299:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_WakeUp_Pin2: WKUP2 pin is used for wakeup from Standby mode.
 300:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_WakeUp_Pin3: WKUP3 pin is used for wakeup from Standby mode.(only for STM32
 301:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 302:./Lib/Src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 303:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 304:./Lib/Src/stm32f4xx_pwr.c ****   */
 305:./Lib/Src/stm32f4xx_pwr.c **** void PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPinx, FunctionalState NewState)
 306:./Lib/Src/stm32f4xx_pwr.c **** {
 307:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */  
 308:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 309:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(NewState));
 310:./Lib/Src/stm32f4xx_pwr.c ****   if(PWR_WakeUpPinx == PWR_WakeUp_Pin1) /* PWR_WakeUp_Pin1 */
 311:./Lib/Src/stm32f4xx_pwr.c ****   {
 312:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CSR_EWUP1_BB = (uint32_t)NewState;
 313:./Lib/Src/stm32f4xx_pwr.c ****   }
 314:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F410xx)|| defined(STM32F412xG) || defined(STM32F413_423xx)  
 315:./Lib/Src/stm32f4xx_pwr.c ****   else if(PWR_WakeUpPinx == PWR_WakeUp_Pin3) /* PWR_WakeUp_Pin3 */
 316:./Lib/Src/stm32f4xx_pwr.c ****   {
 317:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CSR_EWUP3_BB = (uint32_t)NewState;
ARM GAS  /tmp/ccNgkk2X.s 			page 11


 318:./Lib/Src/stm32f4xx_pwr.c ****   }
 319:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F410xx */  
 320:./Lib/Src/stm32f4xx_pwr.c ****   else /* PWR_WakeUp_Pin2 */
 321:./Lib/Src/stm32f4xx_pwr.c ****   {
 322:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CSR_EWUP2_BB = (uint32_t)NewState;
 323:./Lib/Src/stm32f4xx_pwr.c ****   }
 324:./Lib/Src/stm32f4xx_pwr.c **** }
 325:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
 326:./Lib/Src/stm32f4xx_pwr.c **** 
 327:./Lib/Src/stm32f4xx_pwr.c **** /**
 328:./Lib/Src/stm32f4xx_pwr.c ****   * @}
 329:./Lib/Src/stm32f4xx_pwr.c ****   */
 330:./Lib/Src/stm32f4xx_pwr.c **** 
 331:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group4 Main and Backup Regulators configuration functions
 332:./Lib/Src/stm32f4xx_pwr.c ****   *  @brief   Main and Backup Regulators configuration functions 
 333:./Lib/Src/stm32f4xx_pwr.c ****   *
 334:./Lib/Src/stm32f4xx_pwr.c **** @verbatim   
 335:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================
 336:./Lib/Src/stm32f4xx_pwr.c ****           ##### Main and Backup Regulators configuration functions #####
 337:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================  
 338:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 339:./Lib/Src/stm32f4xx_pwr.c ****       (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
 340:./Lib/Src/stm32f4xx_pwr.c ****           the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
 341:./Lib/Src/stm32f4xx_pwr.c ****           retained even in Standby or VBAT mode when the low power backup regulator
 342:./Lib/Src/stm32f4xx_pwr.c ****           is enabled. It can be considered as an internal EEPROM when VBAT is 
 343:./Lib/Src/stm32f4xx_pwr.c ****           always present. You can use the PWR_BackupRegulatorCmd() function to 
 344:./Lib/Src/stm32f4xx_pwr.c ****           enable the low power backup regulator and use the PWR_GetFlagStatus
 345:./Lib/Src/stm32f4xx_pwr.c ****           (PWR_FLAG_BRR) to check if it is ready or not. 
 346:./Lib/Src/stm32f4xx_pwr.c **** 
 347:./Lib/Src/stm32f4xx_pwr.c ****       (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
 348:./Lib/Src/stm32f4xx_pwr.c ****           the backup SRAM is powered from VDD which replaces the VBAT power supply to 
 349:./Lib/Src/stm32f4xx_pwr.c ****           save battery life.
 350:./Lib/Src/stm32f4xx_pwr.c **** 
 351:./Lib/Src/stm32f4xx_pwr.c ****       (+) The backup SRAM is not mass erased by an tamper event. It is read 
 352:./Lib/Src/stm32f4xx_pwr.c ****           protected to prevent confidential data, such as cryptographic private 
 353:./Lib/Src/stm32f4xx_pwr.c ****           key, from being accessed. The backup SRAM can be erased only through 
 354:./Lib/Src/stm32f4xx_pwr.c ****           the Flash interface when a protection level change from level 1 to 
 355:./Lib/Src/stm32f4xx_pwr.c ****           level 0 is requested. 
 356:./Lib/Src/stm32f4xx_pwr.c ****       -@- Refer to the description of Read protection (RDP) in the reference manual.
 357:./Lib/Src/stm32f4xx_pwr.c **** 
 358:./Lib/Src/stm32f4xx_pwr.c ****       (+) The main internal regulator can be configured to have a tradeoff between 
 359:./Lib/Src/stm32f4xx_pwr.c ****           performance and power consumption when the device does not operate at 
 360:./Lib/Src/stm32f4xx_pwr.c ****           the maximum frequency. 
 361:./Lib/Src/stm32f4xx_pwr.c ****       (+) For STM32F405xx/407xx and STM32F415xx/417xx  Devices, the regulator can be     
 362:./Lib/Src/stm32f4xx_pwr.c ****           configured on the fly through PWR_MainRegulatorModeConfig() function which  
 363:./Lib/Src/stm32f4xx_pwr.c ****           configure VOS bit in PWR_CR register:
 364:./Lib/Src/stm32f4xx_pwr.c ****         (++) When this bit is set (Regulator voltage output Scale 1 mode selected) 
 365:./Lib/Src/stm32f4xx_pwr.c ****              the System frequency can go up to 168 MHz. 
 366:./Lib/Src/stm32f4xx_pwr.c ****         (++) When this bit is reset (Regulator voltage output Scale 2 mode selected) 
 367:./Lib/Src/stm32f4xx_pwr.c ****              the System frequency can go up to 144 MHz.
 368:./Lib/Src/stm32f4xx_pwr.c ****              
 369:./Lib/Src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, the regulator can be configured through    
 370:./Lib/Src/stm32f4xx_pwr.c ****            PWR_MainRegulatorModeConfig() function which configure VOS[1:0] bits in
 371:./Lib/Src/stm32f4xx_pwr.c ****            PWR_CR register:  
 372:./Lib/Src/stm32f4xx_pwr.c ****            which configure VOS[1:0] bits in PWR_CR register: 
 373:./Lib/Src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 11 (Regulator voltage output Scale 1 mode selected) 
 374:./Lib/Src/stm32f4xx_pwr.c ****              the System frequency can go up to 168 MHz. 
ARM GAS  /tmp/ccNgkk2X.s 			page 12


 375:./Lib/Src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 10 (Regulator voltage output Scale 2 mode selected) 
 376:./Lib/Src/stm32f4xx_pwr.c ****              the System frequency can go up to 144 MHz.  
 377:./Lib/Src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 01 (Regulator voltage output Scale 3 mode selected) 
 378:./Lib/Src/stm32f4xx_pwr.c ****              the System frequency can go up to 120 MHz. 
 379:./Lib/Src/stm32f4xx_pwr.c ****                           
 380:./Lib/Src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, the scale can be modified only when the PLL 
 381:./Lib/Src/stm32f4xx_pwr.c ****            is OFF and the HSI or HSE clock source is selected as system clock. 
 382:./Lib/Src/stm32f4xx_pwr.c ****            The new value programmed is active only when the PLL is ON.
 383:./Lib/Src/stm32f4xx_pwr.c ****            When the PLL is OFF, the voltage scale 3 is automatically selected. 
 384:./Lib/Src/stm32f4xx_pwr.c ****         Refer to the datasheets for more details.
 385:./Lib/Src/stm32f4xx_pwr.c ****         
 386:./Lib/Src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, in Run mode: the main regulator has
 387:./Lib/Src/stm32f4xx_pwr.c ****            2 operating modes available:
 388:./Lib/Src/stm32f4xx_pwr.c ****         (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
 389:./Lib/Src/stm32f4xx_pwr.c ****              voltage scaling (scale 1, scale 2 or scale 3)
 390:./Lib/Src/stm32f4xx_pwr.c ****         (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
 391:./Lib/Src/stm32f4xx_pwr.c ****             higher frequency than the normal mode for a given voltage scaling (scale 1,  
 392:./Lib/Src/stm32f4xx_pwr.c ****             scale 2 or scale 3). This mode is enabled through PWR_OverDriveCmd() function and
 393:./Lib/Src/stm32f4xx_pwr.c ****             PWR_OverDriveSWCmd() function, to enter or exit from Over-drive mode please follow 
 394:./Lib/Src/stm32f4xx_pwr.c ****             the sequence described in Reference manual.
 395:./Lib/Src/stm32f4xx_pwr.c ****              
 396:./Lib/Src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, in Stop mode: the main regulator or low power regulator 
 397:./Lib/Src/stm32f4xx_pwr.c ****            supplies a low power voltage to the 1.2V domain, thus preserving the content of register
 398:./Lib/Src/stm32f4xx_pwr.c ****            and internal SRAM. 2 operating modes are available:
 399:./Lib/Src/stm32f4xx_pwr.c ****          (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
 400:./Lib/Src/stm32f4xx_pwr.c ****               available when the main regulator or the low power regulator is used in Scale 3 or 
 401:./Lib/Src/stm32f4xx_pwr.c ****               low voltage mode.
 402:./Lib/Src/stm32f4xx_pwr.c ****          (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is 
 403:./Lib/Src/stm32f4xx_pwr.c ****               available when the main regulator or the low power regulator is in low voltage mode.
 404:./Lib/Src/stm32f4xx_pwr.c ****               This mode is enabled through PWR_UnderDriveCmd() function.
 405:./Lib/Src/stm32f4xx_pwr.c ****             
 406:./Lib/Src/stm32f4xx_pwr.c **** @endverbatim
 407:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 408:./Lib/Src/stm32f4xx_pwr.c ****   */
 409:./Lib/Src/stm32f4xx_pwr.c **** 
 410:./Lib/Src/stm32f4xx_pwr.c **** /**
 411:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Backup Regulator.
 412:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Backup Regulator.
 413:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 414:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 415:./Lib/Src/stm32f4xx_pwr.c ****   */
 416:./Lib/Src/stm32f4xx_pwr.c **** void PWR_BackupRegulatorCmd(FunctionalState NewState)
 417:./Lib/Src/stm32f4xx_pwr.c **** {
 265              		.loc 1 417 1
 266              		.cfi_startproc
 267              		@ args = 0, pretend = 0, frame = 8
 268              		@ frame_needed = 1, uses_anonymous_args = 0
 269              		@ link register save eliminated.
 270 0000 80B4     		push	{r7}
 271              		.cfi_def_cfa_offset 4
 272              		.cfi_offset 7, -4
 273 0002 83B0     		sub	sp, sp, #12
 274              		.cfi_def_cfa_offset 16
 275 0004 00AF     		add	r7, sp, #0
 276              		.cfi_def_cfa_register 7
 277 0006 0346     		mov	r3, r0
 278 0008 FB71     		strb	r3, [r7, #7]
ARM GAS  /tmp/ccNgkk2X.s 			page 13


 418:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 419:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 420:./Lib/Src/stm32f4xx_pwr.c **** 
 421:./Lib/Src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 279              		.loc 1 421 3
 280 000a 044A     		ldr	r2, .L15
 281              		.loc 1 421 35
 282 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 283              		.loc 1 421 33
 284 000e 1360     		str	r3, [r2]
 422:./Lib/Src/stm32f4xx_pwr.c **** }
 285              		.loc 1 422 1
 286 0010 00BF     		nop
 287 0012 0C37     		adds	r7, r7, #12
 288              		.cfi_def_cfa_offset 4
 289 0014 BD46     		mov	sp, r7
 290              		.cfi_def_cfa_register 13
 291              		@ sp needed
 292 0016 5DF8047B 		ldr	r7, [sp], #4
 293              		.cfi_restore 7
 294              		.cfi_def_cfa_offset 0
 295 001a 7047     		bx	lr
 296              	.L16:
 297              		.align	2
 298              	.L15:
 299 001c A4000E42 		.word	1108213924
 300              		.cfi_endproc
 301              	.LFE128:
 303              		.section	.text.PWR_MainRegulatorModeConfig,"ax",%progbits
 304              		.align	1
 305              		.global	PWR_MainRegulatorModeConfig
 306              		.syntax unified
 307              		.thumb
 308              		.thumb_func
 310              	PWR_MainRegulatorModeConfig:
 311              	.LFB129:
 423:./Lib/Src/stm32f4xx_pwr.c **** 
 424:./Lib/Src/stm32f4xx_pwr.c **** /**
 425:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Configures the main internal regulator output voltage.
 426:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator_Voltage: specifies the regulator output voltage to achieve
 427:./Lib/Src/stm32f4xx_pwr.c ****   *         a tradeoff between performance and power consumption when the device does
 428:./Lib/Src/stm32f4xx_pwr.c ****   *         not operate at the maximum frequency (refer to the datasheets for more details).
 429:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 430:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale1: Regulator voltage output Scale 1 mode, 
 431:./Lib/Src/stm32f4xx_pwr.c ****   *                                                System frequency up to 168 MHz. 
 432:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
 433:./Lib/Src/stm32f4xx_pwr.c ****   *                                                System frequency up to 144 MHz.    
 434:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale3: Regulator voltage output Scale 3 mode, 
 435:./Lib/Src/stm32f4xx_pwr.c ****   *                                                System frequency up to 120 MHz (only for STM32F4
 436:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 437:./Lib/Src/stm32f4xx_pwr.c ****   */
 438:./Lib/Src/stm32f4xx_pwr.c **** void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
 439:./Lib/Src/stm32f4xx_pwr.c **** {
 312              		.loc 1 439 1
 313              		.cfi_startproc
 314              		@ args = 0, pretend = 0, frame = 16
 315              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  /tmp/ccNgkk2X.s 			page 14


 316              		@ link register save eliminated.
 317 0000 80B4     		push	{r7}
 318              		.cfi_def_cfa_offset 4
 319              		.cfi_offset 7, -4
 320 0002 85B0     		sub	sp, sp, #20
 321              		.cfi_def_cfa_offset 24
 322 0004 00AF     		add	r7, sp, #0
 323              		.cfi_def_cfa_register 7
 324 0006 7860     		str	r0, [r7, #4]
 440:./Lib/Src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 325              		.loc 1 440 12
 326 0008 0023     		movs	r3, #0
 327 000a FB60     		str	r3, [r7, #12]
 441:./Lib/Src/stm32f4xx_pwr.c **** 	
 442:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 443:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
 444:./Lib/Src/stm32f4xx_pwr.c **** 
 445:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 328              		.loc 1 445 15
 329 000c 094B     		ldr	r3, .L18
 330              		.loc 1 445 10
 331 000e 1B68     		ldr	r3, [r3]
 332 0010 FB60     		str	r3, [r7, #12]
 446:./Lib/Src/stm32f4xx_pwr.c ****   
 447:./Lib/Src/stm32f4xx_pwr.c ****   /* Clear VOS[15:14] bits */
 448:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg &= CR_VOS_MASK;
 333              		.loc 1 448 10
 334 0012 FB68     		ldr	r3, [r7, #12]
 335 0014 23F44043 		bic	r3, r3, #49152
 336 0018 FB60     		str	r3, [r7, #12]
 449:./Lib/Src/stm32f4xx_pwr.c ****   
 450:./Lib/Src/stm32f4xx_pwr.c ****   /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
 451:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator_Voltage;
 337              		.loc 1 451 10
 338 001a FA68     		ldr	r2, [r7, #12]
 339 001c 7B68     		ldr	r3, [r7, #4]
 340 001e 1343     		orrs	r3, r3, r2
 341 0020 FB60     		str	r3, [r7, #12]
 452:./Lib/Src/stm32f4xx_pwr.c ****   
 453:./Lib/Src/stm32f4xx_pwr.c ****   /* Store the new value */
 454:./Lib/Src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 342              		.loc 1 454 6
 343 0022 044A     		ldr	r2, .L18
 344              		.loc 1 454 11
 345 0024 FB68     		ldr	r3, [r7, #12]
 346 0026 1360     		str	r3, [r2]
 455:./Lib/Src/stm32f4xx_pwr.c **** }
 347              		.loc 1 455 1
 348 0028 00BF     		nop
 349 002a 1437     		adds	r7, r7, #20
 350              		.cfi_def_cfa_offset 4
 351 002c BD46     		mov	sp, r7
 352              		.cfi_def_cfa_register 13
 353              		@ sp needed
 354 002e 5DF8047B 		ldr	r7, [sp], #4
 355              		.cfi_restore 7
 356              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/ccNgkk2X.s 			page 15


 357 0032 7047     		bx	lr
 358              	.L19:
 359              		.align	2
 360              	.L18:
 361 0034 00700040 		.word	1073770496
 362              		.cfi_endproc
 363              	.LFE129:
 365              		.section	.text.PWR_OverDriveCmd,"ax",%progbits
 366              		.align	1
 367              		.global	PWR_OverDriveCmd
 368              		.syntax unified
 369              		.thumb
 370              		.thumb_func
 372              	PWR_OverDriveCmd:
 373              	.LFB130:
 456:./Lib/Src/stm32f4xx_pwr.c **** 
 457:./Lib/Src/stm32f4xx_pwr.c **** /**
 458:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Over-Drive.
 459:./Lib/Src/stm32f4xx_pwr.c ****   * 
 460:./Lib/Src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
 461:./Lib/Src/stm32f4xx_pwr.c ****   *         This mode allows the CPU and the core logic to operate at a higher frequency
 462:./Lib/Src/stm32f4xx_pwr.c ****   *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
 463:./Lib/Src/stm32f4xx_pwr.c ****   * 
 464:./Lib/Src/stm32f4xx_pwr.c ****   * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
 465:./Lib/Src/stm32f4xx_pwr.c ****   *          critical tasks and when the system clock source is either HSI or HSE. 
 466:./Lib/Src/stm32f4xx_pwr.c ****   *          During the Over-drive switch activation, no peripheral clocks should be enabled.   
 467:./Lib/Src/stm32f4xx_pwr.c ****   *          The peripheral clocks must be enabled once the Over-drive mode is activated.
 468:./Lib/Src/stm32f4xx_pwr.c ****   *            
 469:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Over Drive mode.
 470:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 471:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 472:./Lib/Src/stm32f4xx_pwr.c ****   */
 473:./Lib/Src/stm32f4xx_pwr.c **** void PWR_OverDriveCmd(FunctionalState NewState)
 474:./Lib/Src/stm32f4xx_pwr.c **** {
 374              		.loc 1 474 1
 375              		.cfi_startproc
 376              		@ args = 0, pretend = 0, frame = 8
 377              		@ frame_needed = 1, uses_anonymous_args = 0
 378              		@ link register save eliminated.
 379 0000 80B4     		push	{r7}
 380              		.cfi_def_cfa_offset 4
 381              		.cfi_offset 7, -4
 382 0002 83B0     		sub	sp, sp, #12
 383              		.cfi_def_cfa_offset 16
 384 0004 00AF     		add	r7, sp, #0
 385              		.cfi_def_cfa_register 7
 386 0006 0346     		mov	r3, r0
 387 0008 FB71     		strb	r3, [r7, #7]
 475:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 476:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 477:./Lib/Src/stm32f4xx_pwr.c ****   
 478:./Lib/Src/stm32f4xx_pwr.c ****   /* Set/Reset the ODEN bit to enable/disable the Over Drive mode */
 479:./Lib/Src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_ODEN_BB = (uint32_t)NewState;
 388              		.loc 1 479 3
 389 000a 044A     		ldr	r2, .L21
 390              		.loc 1 479 35
 391 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
ARM GAS  /tmp/ccNgkk2X.s 			page 16


 392              		.loc 1 479 33
 393 000e 1360     		str	r3, [r2]
 480:./Lib/Src/stm32f4xx_pwr.c **** }
 394              		.loc 1 480 1
 395 0010 00BF     		nop
 396 0012 0C37     		adds	r7, r7, #12
 397              		.cfi_def_cfa_offset 4
 398 0014 BD46     		mov	sp, r7
 399              		.cfi_def_cfa_register 13
 400              		@ sp needed
 401 0016 5DF8047B 		ldr	r7, [sp], #4
 402              		.cfi_restore 7
 403              		.cfi_def_cfa_offset 0
 404 001a 7047     		bx	lr
 405              	.L22:
 406              		.align	2
 407              	.L21:
 408 001c 40000E42 		.word	1108213824
 409              		.cfi_endproc
 410              	.LFE130:
 412              		.section	.text.PWR_OverDriveSWCmd,"ax",%progbits
 413              		.align	1
 414              		.global	PWR_OverDriveSWCmd
 415              		.syntax unified
 416              		.thumb
 417              		.thumb_func
 419              	PWR_OverDriveSWCmd:
 420              	.LFB131:
 481:./Lib/Src/stm32f4xx_pwr.c **** 
 482:./Lib/Src/stm32f4xx_pwr.c **** /**
 483:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Over-Drive switching.
 484:./Lib/Src/stm32f4xx_pwr.c ****   * 
 485:./Lib/Src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices. 
 486:./Lib/Src/stm32f4xx_pwr.c ****   *       
 487:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Over Drive switching mode.
 488:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 489:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 490:./Lib/Src/stm32f4xx_pwr.c ****   */
 491:./Lib/Src/stm32f4xx_pwr.c **** void PWR_OverDriveSWCmd(FunctionalState NewState)
 492:./Lib/Src/stm32f4xx_pwr.c **** {
 421              		.loc 1 492 1
 422              		.cfi_startproc
 423              		@ args = 0, pretend = 0, frame = 8
 424              		@ frame_needed = 1, uses_anonymous_args = 0
 425              		@ link register save eliminated.
 426 0000 80B4     		push	{r7}
 427              		.cfi_def_cfa_offset 4
 428              		.cfi_offset 7, -4
 429 0002 83B0     		sub	sp, sp, #12
 430              		.cfi_def_cfa_offset 16
 431 0004 00AF     		add	r7, sp, #0
 432              		.cfi_def_cfa_register 7
 433 0006 0346     		mov	r3, r0
 434 0008 FB71     		strb	r3, [r7, #7]
 493:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 494:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 495:./Lib/Src/stm32f4xx_pwr.c **** 
ARM GAS  /tmp/ccNgkk2X.s 			page 17


 496:./Lib/Src/stm32f4xx_pwr.c ****   /* Set/Reset the ODSWEN bit to enable/disable the Over Drive switching mode */
 497:./Lib/Src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_ODSWEN_BB = (uint32_t)NewState;
 435              		.loc 1 497 3
 436 000a 044A     		ldr	r2, .L24
 437              		.loc 1 497 37
 438 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 439              		.loc 1 497 35
 440 000e 1360     		str	r3, [r2]
 498:./Lib/Src/stm32f4xx_pwr.c **** }
 441              		.loc 1 498 1
 442 0010 00BF     		nop
 443 0012 0C37     		adds	r7, r7, #12
 444              		.cfi_def_cfa_offset 4
 445 0014 BD46     		mov	sp, r7
 446              		.cfi_def_cfa_register 13
 447              		@ sp needed
 448 0016 5DF8047B 		ldr	r7, [sp], #4
 449              		.cfi_restore 7
 450              		.cfi_def_cfa_offset 0
 451 001a 7047     		bx	lr
 452              	.L25:
 453              		.align	2
 454              	.L24:
 455 001c 44000E42 		.word	1108213828
 456              		.cfi_endproc
 457              	.LFE131:
 459              		.section	.text.PWR_UnderDriveCmd,"ax",%progbits
 460              		.align	1
 461              		.global	PWR_UnderDriveCmd
 462              		.syntax unified
 463              		.thumb
 464              		.thumb_func
 466              	PWR_UnderDriveCmd:
 467              	.LFB132:
 499:./Lib/Src/stm32f4xx_pwr.c **** 
 500:./Lib/Src/stm32f4xx_pwr.c **** /**
 501:./Lib/Src/stm32f4xx_pwr.c ****   * @brief   Enables or disables the Under-Drive mode.
 502:./Lib/Src/stm32f4xx_pwr.c ****   * 
 503:./Lib/Src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
 504:./Lib/Src/stm32f4xx_pwr.c ****   * @note    This mode is enabled only with STOP low power mode.
 505:./Lib/Src/stm32f4xx_pwr.c ****   *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
 506:./Lib/Src/stm32f4xx_pwr.c ****   *          mode is only available when the main regulator or the low power regulator 
 507:./Lib/Src/stm32f4xx_pwr.c ****   *          is in low voltage mode
 508:./Lib/Src/stm32f4xx_pwr.c ****   *        
 509:./Lib/Src/stm32f4xx_pwr.c ****   * @note   If the Under-drive mode was enabled, it is automatically disabled after 
 510:./Lib/Src/stm32f4xx_pwr.c ****   *         exiting Stop mode. 
 511:./Lib/Src/stm32f4xx_pwr.c ****   *         When the voltage regulator operates in Under-drive mode, an additional  
 512:./Lib/Src/stm32f4xx_pwr.c ****   *         startup delay is induced when waking up from Stop mode.
 513:./Lib/Src/stm32f4xx_pwr.c ****   *                    
 514:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Under Drive mode.
 515:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 516:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 517:./Lib/Src/stm32f4xx_pwr.c ****   */
 518:./Lib/Src/stm32f4xx_pwr.c **** void PWR_UnderDriveCmd(FunctionalState NewState)
 519:./Lib/Src/stm32f4xx_pwr.c **** {
 468              		.loc 1 519 1
 469              		.cfi_startproc
ARM GAS  /tmp/ccNgkk2X.s 			page 18


 470              		@ args = 0, pretend = 0, frame = 8
 471              		@ frame_needed = 1, uses_anonymous_args = 0
 472              		@ link register save eliminated.
 473 0000 80B4     		push	{r7}
 474              		.cfi_def_cfa_offset 4
 475              		.cfi_offset 7, -4
 476 0002 83B0     		sub	sp, sp, #12
 477              		.cfi_def_cfa_offset 16
 478 0004 00AF     		add	r7, sp, #0
 479              		.cfi_def_cfa_register 7
 480 0006 0346     		mov	r3, r0
 481 0008 FB71     		strb	r3, [r7, #7]
 520:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 521:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 522:./Lib/Src/stm32f4xx_pwr.c **** 
 523:./Lib/Src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 482              		.loc 1 523 6
 483 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 484 000c 002B     		cmp	r3, #0
 485 000e 06D0     		beq	.L27
 524:./Lib/Src/stm32f4xx_pwr.c ****   {
 525:./Lib/Src/stm32f4xx_pwr.c ****     /* Set the UDEN[1:0] bits to enable the Under Drive mode */
 526:./Lib/Src/stm32f4xx_pwr.c ****     PWR->CR |= (uint32_t)PWR_CR_UDEN;
 486              		.loc 1 526 8
 487 0010 094B     		ldr	r3, .L30
 488 0012 1B68     		ldr	r3, [r3]
 489 0014 084A     		ldr	r2, .L30
 490              		.loc 1 526 13
 491 0016 43F44023 		orr	r3, r3, #786432
 492 001a 1360     		str	r3, [r2]
 527:./Lib/Src/stm32f4xx_pwr.c ****   }
 528:./Lib/Src/stm32f4xx_pwr.c ****   else
 529:./Lib/Src/stm32f4xx_pwr.c ****   {
 530:./Lib/Src/stm32f4xx_pwr.c ****     /* Reset the UDEN[1:0] bits to disable the Under Drive mode */
 531:./Lib/Src/stm32f4xx_pwr.c ****     PWR->CR &= (uint32_t)(~PWR_CR_UDEN);
 532:./Lib/Src/stm32f4xx_pwr.c ****   }
 533:./Lib/Src/stm32f4xx_pwr.c **** }
 493              		.loc 1 533 1
 494 001c 05E0     		b	.L29
 495              	.L27:
 531:./Lib/Src/stm32f4xx_pwr.c ****   }
 496              		.loc 1 531 8
 497 001e 064B     		ldr	r3, .L30
 498 0020 1B68     		ldr	r3, [r3]
 499 0022 054A     		ldr	r2, .L30
 531:./Lib/Src/stm32f4xx_pwr.c ****   }
 500              		.loc 1 531 13
 501 0024 23F44023 		bic	r3, r3, #786432
 502 0028 1360     		str	r3, [r2]
 503              	.L29:
 504              		.loc 1 533 1
 505 002a 00BF     		nop
 506 002c 0C37     		adds	r7, r7, #12
 507              		.cfi_def_cfa_offset 4
 508 002e BD46     		mov	sp, r7
 509              		.cfi_def_cfa_register 13
 510              		@ sp needed
ARM GAS  /tmp/ccNgkk2X.s 			page 19


 511 0030 5DF8047B 		ldr	r7, [sp], #4
 512              		.cfi_restore 7
 513              		.cfi_def_cfa_offset 0
 514 0034 7047     		bx	lr
 515              	.L31:
 516 0036 00BF     		.align	2
 517              	.L30:
 518 0038 00700040 		.word	1073770496
 519              		.cfi_endproc
 520              	.LFE132:
 522              		.section	.text.PWR_MainRegulatorLowVoltageCmd,"ax",%progbits
 523              		.align	1
 524              		.global	PWR_MainRegulatorLowVoltageCmd
 525              		.syntax unified
 526              		.thumb
 527              		.thumb_func
 529              	PWR_MainRegulatorLowVoltageCmd:
 530              	.LFB133:
 534:./Lib/Src/stm32f4xx_pwr.c **** 
 535:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx)
 536:./Lib/Src/stm32f4xx_pwr.c **** /**
 537:./Lib/Src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Main Regulator under drive mode.
 538:./Lib/Src/stm32f4xx_pwr.c ****   *
 539:./Lib/Src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F427_437xx/STM32F429_439xx/STM32F446xx devices.
 540:./Lib/Src/stm32f4xx_pwr.c ****   *
 541:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Main Regulator Under Drive mode.
 542:./Lib/Src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 543:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 544:./Lib/Src/stm32f4xx_pwr.c ****   */
 545:./Lib/Src/stm32f4xx_pwr.c **** void PWR_MainRegulatorUnderDriveCmd(FunctionalState NewState)
 546:./Lib/Src/stm32f4xx_pwr.c **** { 
 547:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 548:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 549:./Lib/Src/stm32f4xx_pwr.c ****   
 550:./Lib/Src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 551:./Lib/Src/stm32f4xx_pwr.c ****   {
 552:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRUDS_BB = (uint32_t)ENABLE;
 553:./Lib/Src/stm32f4xx_pwr.c ****   }
 554:./Lib/Src/stm32f4xx_pwr.c ****   else
 555:./Lib/Src/stm32f4xx_pwr.c ****   {
 556:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRUDS_BB = (uint32_t)DISABLE;
 557:./Lib/Src/stm32f4xx_pwr.c ****   }
 558:./Lib/Src/stm32f4xx_pwr.c **** }
 559:./Lib/Src/stm32f4xx_pwr.c **** 
 560:./Lib/Src/stm32f4xx_pwr.c **** /**
 561:./Lib/Src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Low Power Regulator under drive mode.
 562:./Lib/Src/stm32f4xx_pwr.c ****   *
 563:./Lib/Src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F427_437xx/STM32F429_439xx/STM32F446xx devices.
 564:./Lib/Src/stm32f4xx_pwr.c ****   *
 565:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Low Power Regulator Under Drive mode.
 566:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 567:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 568:./Lib/Src/stm32f4xx_pwr.c ****   */
 569:./Lib/Src/stm32f4xx_pwr.c **** void PWR_LowRegulatorUnderDriveCmd(FunctionalState NewState)
 570:./Lib/Src/stm32f4xx_pwr.c **** {
 571:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 572:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
ARM GAS  /tmp/ccNgkk2X.s 			page 20


 573:./Lib/Src/stm32f4xx_pwr.c ****   
 574:./Lib/Src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 575:./Lib/Src/stm32f4xx_pwr.c ****   {
 576:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPUDS_BB = (uint32_t)ENABLE;
 577:./Lib/Src/stm32f4xx_pwr.c ****   }
 578:./Lib/Src/stm32f4xx_pwr.c ****   else
 579:./Lib/Src/stm32f4xx_pwr.c ****   {
 580:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPUDS_BB = (uint32_t)DISABLE;
 581:./Lib/Src/stm32f4xx_pwr.c ****   }
 582:./Lib/Src/stm32f4xx_pwr.c **** }
 583:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F427_437xx || STM32F429_439xx || STM32F446xx */
 584:./Lib/Src/stm32f4xx_pwr.c **** 
 585:./Lib/Src/stm32f4xx_pwr.c **** #if defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F412xG) ||
 586:./Lib/Src/stm32f4xx_pwr.c **** /**
 587:./Lib/Src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Main Regulator low voltage mode.
 588:./Lib/Src/stm32f4xx_pwr.c ****   *
 589:./Lib/Src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412xG/STM32F41
 590:./Lib/Src/stm32f4xx_pwr.c ****   *
 591:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Main Regulator Low Voltage mode.
 592:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 593:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 594:./Lib/Src/stm32f4xx_pwr.c ****   */
 595:./Lib/Src/stm32f4xx_pwr.c **** void PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState)
 596:./Lib/Src/stm32f4xx_pwr.c **** { 
 531              		.loc 1 596 1
 532              		.cfi_startproc
 533              		@ args = 0, pretend = 0, frame = 8
 534              		@ frame_needed = 1, uses_anonymous_args = 0
 535              		@ link register save eliminated.
 536 0000 80B4     		push	{r7}
 537              		.cfi_def_cfa_offset 4
 538              		.cfi_offset 7, -4
 539 0002 83B0     		sub	sp, sp, #12
 540              		.cfi_def_cfa_offset 16
 541 0004 00AF     		add	r7, sp, #0
 542              		.cfi_def_cfa_register 7
 543 0006 0346     		mov	r3, r0
 544 0008 FB71     		strb	r3, [r7, #7]
 597:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 598:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 599:./Lib/Src/stm32f4xx_pwr.c ****   
 600:./Lib/Src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 545              		.loc 1 600 6
 546 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 547 000c 002B     		cmp	r3, #0
 548 000e 03D0     		beq	.L33
 601:./Lib/Src/stm32f4xx_pwr.c ****   {
 602:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;
 549              		.loc 1 602 5
 550 0010 064B     		ldr	r3, .L36
 551              		.loc 1 602 37
 552 0012 0122     		movs	r2, #1
 553 0014 1A60     		str	r2, [r3]
 603:./Lib/Src/stm32f4xx_pwr.c ****   }
 604:./Lib/Src/stm32f4xx_pwr.c ****   else
 605:./Lib/Src/stm32f4xx_pwr.c ****   {
 606:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;
ARM GAS  /tmp/ccNgkk2X.s 			page 21


 607:./Lib/Src/stm32f4xx_pwr.c ****   }
 608:./Lib/Src/stm32f4xx_pwr.c **** }
 554              		.loc 1 608 1
 555 0016 02E0     		b	.L35
 556              	.L33:
 606:./Lib/Src/stm32f4xx_pwr.c ****   }
 557              		.loc 1 606 5
 558 0018 044B     		ldr	r3, .L36
 606:./Lib/Src/stm32f4xx_pwr.c ****   }
 559              		.loc 1 606 37
 560 001a 0022     		movs	r2, #0
 561 001c 1A60     		str	r2, [r3]
 562              	.L35:
 563              		.loc 1 608 1
 564 001e 00BF     		nop
 565 0020 0C37     		adds	r7, r7, #12
 566              		.cfi_def_cfa_offset 4
 567 0022 BD46     		mov	sp, r7
 568              		.cfi_def_cfa_register 13
 569              		@ sp needed
 570 0024 5DF8047B 		ldr	r7, [sp], #4
 571              		.cfi_restore 7
 572              		.cfi_def_cfa_offset 0
 573 0028 7047     		bx	lr
 574              	.L37:
 575 002a 00BF     		.align	2
 576              	.L36:
 577 002c 2C000E42 		.word	1108213804
 578              		.cfi_endproc
 579              	.LFE133:
 581              		.section	.text.PWR_LowRegulatorLowVoltageCmd,"ax",%progbits
 582              		.align	1
 583              		.global	PWR_LowRegulatorLowVoltageCmd
 584              		.syntax unified
 585              		.thumb
 586              		.thumb_func
 588              	PWR_LowRegulatorLowVoltageCmd:
 589              	.LFB134:
 609:./Lib/Src/stm32f4xx_pwr.c **** 
 610:./Lib/Src/stm32f4xx_pwr.c **** /**
 611:./Lib/Src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Low Power Regulator low voltage mode.
 612:./Lib/Src/stm32f4xx_pwr.c ****   *
 613:./Lib/Src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412xG/STM32F41
 614:./Lib/Src/stm32f4xx_pwr.c ****   *
 615:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Low Power Regulator Low Voltage mode.
 616:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 617:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 618:./Lib/Src/stm32f4xx_pwr.c ****   */
 619:./Lib/Src/stm32f4xx_pwr.c **** void PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState)
 620:./Lib/Src/stm32f4xx_pwr.c **** {
 590              		.loc 1 620 1
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 8
 593              		@ frame_needed = 1, uses_anonymous_args = 0
 594              		@ link register save eliminated.
 595 0000 80B4     		push	{r7}
 596              		.cfi_def_cfa_offset 4
ARM GAS  /tmp/ccNgkk2X.s 			page 22


 597              		.cfi_offset 7, -4
 598 0002 83B0     		sub	sp, sp, #12
 599              		.cfi_def_cfa_offset 16
 600 0004 00AF     		add	r7, sp, #0
 601              		.cfi_def_cfa_register 7
 602 0006 0346     		mov	r3, r0
 603 0008 FB71     		strb	r3, [r7, #7]
 621:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 622:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 623:./Lib/Src/stm32f4xx_pwr.c ****   
 624:./Lib/Src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 604              		.loc 1 624 6
 605 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 606 000c 002B     		cmp	r3, #0
 607 000e 03D0     		beq	.L39
 625:./Lib/Src/stm32f4xx_pwr.c ****   {
 626:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;
 608              		.loc 1 626 5
 609 0010 064B     		ldr	r3, .L42
 610              		.loc 1 626 37
 611 0012 0122     		movs	r2, #1
 612 0014 1A60     		str	r2, [r3]
 627:./Lib/Src/stm32f4xx_pwr.c ****   }
 628:./Lib/Src/stm32f4xx_pwr.c ****   else
 629:./Lib/Src/stm32f4xx_pwr.c ****   {
 630:./Lib/Src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;
 631:./Lib/Src/stm32f4xx_pwr.c ****   }
 632:./Lib/Src/stm32f4xx_pwr.c **** }
 613              		.loc 1 632 1
 614 0016 02E0     		b	.L41
 615              	.L39:
 630:./Lib/Src/stm32f4xx_pwr.c ****   }
 616              		.loc 1 630 5
 617 0018 044B     		ldr	r3, .L42
 630:./Lib/Src/stm32f4xx_pwr.c ****   }
 618              		.loc 1 630 37
 619 001a 0022     		movs	r2, #0
 620 001c 1A60     		str	r2, [r3]
 621              	.L41:
 622              		.loc 1 632 1
 623 001e 00BF     		nop
 624 0020 0C37     		adds	r7, r7, #12
 625              		.cfi_def_cfa_offset 4
 626 0022 BD46     		mov	sp, r7
 627              		.cfi_def_cfa_register 13
 628              		@ sp needed
 629 0024 5DF8047B 		ldr	r7, [sp], #4
 630              		.cfi_restore 7
 631              		.cfi_def_cfa_offset 0
 632 0028 7047     		bx	lr
 633              	.L43:
 634 002a 00BF     		.align	2
 635              	.L42:
 636 002c 28000E42 		.word	1108213800
 637              		.cfi_endproc
 638              	.LFE134:
 640              		.section	.text.PWR_FlashPowerDownCmd,"ax",%progbits
ARM GAS  /tmp/ccNgkk2X.s 			page 23


 641              		.align	1
 642              		.global	PWR_FlashPowerDownCmd
 643              		.syntax unified
 644              		.thumb
 645              		.thumb_func
 647              	PWR_FlashPowerDownCmd:
 648              	.LFB135:
 633:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F401xx || STM32F410xx || STM32F411xE || STM32F412xG || STM32F413_423xx */
 634:./Lib/Src/stm32f4xx_pwr.c **** 
 635:./Lib/Src/stm32f4xx_pwr.c **** /**
 636:./Lib/Src/stm32f4xx_pwr.c ****   * @}
 637:./Lib/Src/stm32f4xx_pwr.c ****   */
 638:./Lib/Src/stm32f4xx_pwr.c **** 
 639:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group5 FLASH Power Down configuration functions
 640:./Lib/Src/stm32f4xx_pwr.c ****   *  @brief   FLASH Power Down configuration functions 
 641:./Lib/Src/stm32f4xx_pwr.c ****   *
 642:./Lib/Src/stm32f4xx_pwr.c **** @verbatim   
 643:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================
 644:./Lib/Src/stm32f4xx_pwr.c ****              ##### FLASH Power Down configuration functions #####
 645:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================  
 646:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 647:./Lib/Src/stm32f4xx_pwr.c ****       (+) By setting the FPDS bit in the PWR_CR register by using the 
 648:./Lib/Src/stm32f4xx_pwr.c ****           PWR_FlashPowerDownCmd() function, the Flash memory also enters power 
 649:./Lib/Src/stm32f4xx_pwr.c ****           down mode when the device enters Stop mode. When the Flash memory 
 650:./Lib/Src/stm32f4xx_pwr.c ****           is in power down mode, an additional startup delay is incurred when 
 651:./Lib/Src/stm32f4xx_pwr.c ****           waking up from Stop mode.
 652:./Lib/Src/stm32f4xx_pwr.c **** @endverbatim
 653:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 654:./Lib/Src/stm32f4xx_pwr.c ****   */
 655:./Lib/Src/stm32f4xx_pwr.c **** 
 656:./Lib/Src/stm32f4xx_pwr.c **** /**
 657:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Flash Power Down in STOP mode.
 658:./Lib/Src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Flash power mode.
 659:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 660:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 661:./Lib/Src/stm32f4xx_pwr.c ****   */
 662:./Lib/Src/stm32f4xx_pwr.c **** void PWR_FlashPowerDownCmd(FunctionalState NewState)
 663:./Lib/Src/stm32f4xx_pwr.c **** {
 649              		.loc 1 663 1
 650              		.cfi_startproc
 651              		@ args = 0, pretend = 0, frame = 8
 652              		@ frame_needed = 1, uses_anonymous_args = 0
 653              		@ link register save eliminated.
 654 0000 80B4     		push	{r7}
 655              		.cfi_def_cfa_offset 4
 656              		.cfi_offset 7, -4
 657 0002 83B0     		sub	sp, sp, #12
 658              		.cfi_def_cfa_offset 16
 659 0004 00AF     		add	r7, sp, #0
 660              		.cfi_def_cfa_register 7
 661 0006 0346     		mov	r3, r0
 662 0008 FB71     		strb	r3, [r7, #7]
 664:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 665:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 666:./Lib/Src/stm32f4xx_pwr.c **** 
 667:./Lib/Src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 663              		.loc 1 667 3
ARM GAS  /tmp/ccNgkk2X.s 			page 24


 664 000a 044A     		ldr	r2, .L45
 665              		.loc 1 667 35
 666 000c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 667              		.loc 1 667 33
 668 000e 1360     		str	r3, [r2]
 668:./Lib/Src/stm32f4xx_pwr.c **** }
 669              		.loc 1 668 1
 670 0010 00BF     		nop
 671 0012 0C37     		adds	r7, r7, #12
 672              		.cfi_def_cfa_offset 4
 673 0014 BD46     		mov	sp, r7
 674              		.cfi_def_cfa_register 13
 675              		@ sp needed
 676 0016 5DF8047B 		ldr	r7, [sp], #4
 677              		.cfi_restore 7
 678              		.cfi_def_cfa_offset 0
 679 001a 7047     		bx	lr
 680              	.L46:
 681              		.align	2
 682              	.L45:
 683 001c 24000E42 		.word	1108213796
 684              		.cfi_endproc
 685              	.LFE135:
 687              		.section	.text.PWR_EnterSTOPMode,"ax",%progbits
 688              		.align	1
 689              		.global	PWR_EnterSTOPMode
 690              		.syntax unified
 691              		.thumb
 692              		.thumb_func
 694              	PWR_EnterSTOPMode:
 695              	.LFB136:
 669:./Lib/Src/stm32f4xx_pwr.c **** 
 670:./Lib/Src/stm32f4xx_pwr.c **** /**
 671:./Lib/Src/stm32f4xx_pwr.c ****   * @}
 672:./Lib/Src/stm32f4xx_pwr.c ****   */
 673:./Lib/Src/stm32f4xx_pwr.c **** 
 674:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group6 Low Power modes configuration functions
 675:./Lib/Src/stm32f4xx_pwr.c ****   *  @brief   Low Power modes configuration functions 
 676:./Lib/Src/stm32f4xx_pwr.c ****   *
 677:./Lib/Src/stm32f4xx_pwr.c **** @verbatim   
 678:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================
 679:./Lib/Src/stm32f4xx_pwr.c ****               ##### Low Power modes configuration functions #####
 680:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================  
 681:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 682:./Lib/Src/stm32f4xx_pwr.c ****       The devices feature 3 low-power modes:
 683:./Lib/Src/stm32f4xx_pwr.c ****       (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.
 684:./Lib/Src/stm32f4xx_pwr.c ****       (+) Stop mode: all clocks are stopped, regulator running, regulator 
 685:./Lib/Src/stm32f4xx_pwr.c ****           in low power mode
 686:./Lib/Src/stm32f4xx_pwr.c ****       (+) Standby mode: 1.2V domain powered off.
 687:./Lib/Src/stm32f4xx_pwr.c ****    
 688:./Lib/Src/stm32f4xx_pwr.c ****    *** Sleep mode ***
 689:./Lib/Src/stm32f4xx_pwr.c ****    ==================
 690:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 691:./Lib/Src/stm32f4xx_pwr.c ****       (+) Entry:
 692:./Lib/Src/stm32f4xx_pwr.c ****         (++) The Sleep mode is entered by using the __WFI() or __WFE() functions.
 693:./Lib/Src/stm32f4xx_pwr.c ****       (+) Exit:
 694:./Lib/Src/stm32f4xx_pwr.c ****         (++) Any peripheral interrupt acknowledged by the nested vectored interrupt 
ARM GAS  /tmp/ccNgkk2X.s 			page 25


 695:./Lib/Src/stm32f4xx_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 696:./Lib/Src/stm32f4xx_pwr.c **** 
 697:./Lib/Src/stm32f4xx_pwr.c ****    *** Stop mode ***
 698:./Lib/Src/stm32f4xx_pwr.c ****    =================
 699:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 700:./Lib/Src/stm32f4xx_pwr.c ****       In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
 701:./Lib/Src/stm32f4xx_pwr.c ****       and the HSE RC oscillators are disabled. Internal SRAM and register contents 
 702:./Lib/Src/stm32f4xx_pwr.c ****       are preserved.
 703:./Lib/Src/stm32f4xx_pwr.c ****       The voltage regulator can be configured either in normal or low-power mode.
 704:./Lib/Src/stm32f4xx_pwr.c ****       To minimize the consumption In Stop mode, FLASH can be powered off before 
 705:./Lib/Src/stm32f4xx_pwr.c ****       entering the Stop mode. It can be switched on again by software after exiting 
 706:./Lib/Src/stm32f4xx_pwr.c ****       the Stop mode using the PWR_FlashPowerDownCmd() function. 
 707:./Lib/Src/stm32f4xx_pwr.c ****    
 708:./Lib/Src/stm32f4xx_pwr.c ****       (+) Entry:
 709:./Lib/Src/stm32f4xx_pwr.c ****         (++) The Stop mode is entered using the PWR_EnterSTOPMode(PWR_MainRegulator_ON) 
 710:./Lib/Src/stm32f4xx_pwr.c ****              function with:
 711:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Main regulator ON.
 712:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Low Power regulator ON.
 713:./Lib/Src/stm32f4xx_pwr.c ****       (+) Exit:
 714:./Lib/Src/stm32f4xx_pwr.c ****         (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
 715:./Lib/Src/stm32f4xx_pwr.c ****       
 716:./Lib/Src/stm32f4xx_pwr.c ****    *** Standby mode ***
 717:./Lib/Src/stm32f4xx_pwr.c ****    ====================
 718:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 719:./Lib/Src/stm32f4xx_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based 
 720:./Lib/Src/stm32f4xx_pwr.c ****       on the Cortex-M4 deepsleep mode, with the voltage regulator disabled. 
 721:./Lib/Src/stm32f4xx_pwr.c ****       The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
 722:./Lib/Src/stm32f4xx_pwr.c ****       the HSE oscillator are also switched off. SRAM and register contents are lost 
 723:./Lib/Src/stm32f4xx_pwr.c ****       except for the RTC registers, RTC backup registers, backup SRAM and Standby 
 724:./Lib/Src/stm32f4xx_pwr.c ****       circuitry.
 725:./Lib/Src/stm32f4xx_pwr.c ****    
 726:./Lib/Src/stm32f4xx_pwr.c ****       The voltage regulator is OFF.
 727:./Lib/Src/stm32f4xx_pwr.c ****       
 728:./Lib/Src/stm32f4xx_pwr.c ****       (+) Entry:
 729:./Lib/Src/stm32f4xx_pwr.c ****         (++) The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
 730:./Lib/Src/stm32f4xx_pwr.c ****       (+) Exit:
 731:./Lib/Src/stm32f4xx_pwr.c ****         (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 732:./Lib/Src/stm32f4xx_pwr.c ****              tamper event, time-stamp event, external reset in NRST pin, IWDG reset.              
 733:./Lib/Src/stm32f4xx_pwr.c **** 
 734:./Lib/Src/stm32f4xx_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 735:./Lib/Src/stm32f4xx_pwr.c ****    =============================================
 736:./Lib/Src/stm32f4xx_pwr.c ****     [..]
 737:./Lib/Src/stm32f4xx_pwr.c ****       The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
 738:./Lib/Src/stm32f4xx_pwr.c ****       Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
 739:./Lib/Src/stm32f4xx_pwr.c ****       without depending on an external interrupt (Auto-wakeup mode).
 740:./Lib/Src/stm32f4xx_pwr.c **** 
 741:./Lib/Src/stm32f4xx_pwr.c ****       (#) RTC auto-wakeup (AWU) from the Stop mode
 742:./Lib/Src/stm32f4xx_pwr.c ****        
 743:./Lib/Src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to:
 744:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
 745:./Lib/Src/stm32f4xx_pwr.c ****                 or Event modes) using the EXTI_Init() function.
 746:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 747:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 748:./Lib/Src/stm32f4xx_pwr.c ****                 and RTC_AlarmCmd() functions.
 749:./Lib/Src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
 750:./Lib/Src/stm32f4xx_pwr.c ****              is necessary to:
 751:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Configure the EXTI Line 21 to be sensitive to rising edges (Interrupt 
ARM GAS  /tmp/ccNgkk2X.s 			page 26


 752:./Lib/Src/stm32f4xx_pwr.c ****                 or Event modes) using the EXTI_Init() function.
 753:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 754:./Lib/Src/stm32f4xx_pwr.c ****                 function
 755:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to detect the tamper or time stamp event using the
 756:./Lib/Src/stm32f4xx_pwr.c ****                 RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 757:./Lib/Src/stm32f4xx_pwr.c ****                 functions.
 758:./Lib/Src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
 759:./Lib/Src/stm32f4xx_pwr.c ****            (+++) Configure the EXTI Line 22 to be sensitive to rising edges (Interrupt 
 760:./Lib/Src/stm32f4xx_pwr.c ****                  or Event modes) using the EXTI_Init() function.
 761:./Lib/Src/stm32f4xx_pwr.c ****            (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 762:./Lib/Src/stm32f4xx_pwr.c ****            (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig
 763:./Lib/Src/stm32f4xx_pwr.c ****                  RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 764:./Lib/Src/stm32f4xx_pwr.c **** 
 765:./Lib/Src/stm32f4xx_pwr.c ****       (#) RTC auto-wakeup (AWU) from the Standby mode
 766:./Lib/Src/stm32f4xx_pwr.c ****    
 767:./Lib/Src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC alarm event, it is necessary to:
 768:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 769:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 770:./Lib/Src/stm32f4xx_pwr.c ****                 and RTC_AlarmCmd() functions.
 771:./Lib/Src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
 772:./Lib/Src/stm32f4xx_pwr.c ****              is necessary to:
 773:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 774:./Lib/Src/stm32f4xx_pwr.c ****                 function
 775:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to detect the tamper or time stamp event using the
 776:./Lib/Src/stm32f4xx_pwr.c ****                 RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 777:./Lib/Src/stm32f4xx_pwr.c ****                 functions.
 778:./Lib/Src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
 779:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 780:./Lib/Src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(
 781:./Lib/Src/stm32f4xx_pwr.c ****                 RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 782:./Lib/Src/stm32f4xx_pwr.c **** 
 783:./Lib/Src/stm32f4xx_pwr.c **** @endverbatim
 784:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 785:./Lib/Src/stm32f4xx_pwr.c ****   */
 786:./Lib/Src/stm32f4xx_pwr.c **** 
 787:./Lib/Src/stm32f4xx_pwr.c **** /**
 788:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enters STOP mode.
 789:./Lib/Src/stm32f4xx_pwr.c ****   *   
 790:./Lib/Src/stm32f4xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 791:./Lib/Src/stm32f4xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 792:./Lib/Src/stm32f4xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 793:./Lib/Src/stm32f4xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 794:./Lib/Src/stm32f4xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 795:./Lib/Src/stm32f4xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 796:./Lib/Src/stm32f4xx_pwr.c ****   *         is higher although the startup time is reduced.
 797:./Lib/Src/stm32f4xx_pwr.c ****   *     
 798:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 799:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 800:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_MainRegulator_ON: STOP mode with regulator ON
 801:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_LowPowerRegulator_ON: STOP mode with low power regulator ON
 802:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 803:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 804:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 805:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 806:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 807:./Lib/Src/stm32f4xx_pwr.c ****   */
 808:./Lib/Src/stm32f4xx_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
ARM GAS  /tmp/ccNgkk2X.s 			page 27


 809:./Lib/Src/stm32f4xx_pwr.c **** {
 696              		.loc 1 809 1
 697              		.cfi_startproc
 698              		@ args = 0, pretend = 0, frame = 16
 699              		@ frame_needed = 1, uses_anonymous_args = 0
 700              		@ link register save eliminated.
 701 0000 80B4     		push	{r7}
 702              		.cfi_def_cfa_offset 4
 703              		.cfi_offset 7, -4
 704 0002 85B0     		sub	sp, sp, #20
 705              		.cfi_def_cfa_offset 24
 706 0004 00AF     		add	r7, sp, #0
 707              		.cfi_def_cfa_register 7
 708 0006 7860     		str	r0, [r7, #4]
 709 0008 0B46     		mov	r3, r1
 710 000a FB70     		strb	r3, [r7, #3]
 810:./Lib/Src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 711              		.loc 1 810 12
 712 000c 0023     		movs	r3, #0
 713 000e FB60     		str	r3, [r7, #12]
 811:./Lib/Src/stm32f4xx_pwr.c ****   
 812:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 813:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 814:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 815:./Lib/Src/stm32f4xx_pwr.c ****   
 816:./Lib/Src/stm32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 817:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 714              		.loc 1 817 15
 715 0010 144B     		ldr	r3, .L50
 716              		.loc 1 817 10
 717 0012 1B68     		ldr	r3, [r3]
 718 0014 FB60     		str	r3, [r7, #12]
 818:./Lib/Src/stm32f4xx_pwr.c ****   /* Clear PDDS and LPDS bits */
 819:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 719              		.loc 1 819 10
 720 0016 FB68     		ldr	r3, [r7, #12]
 721 0018 23F44063 		bic	r3, r3, #3072
 722 001c 23F00303 		bic	r3, r3, #3
 723 0020 FB60     		str	r3, [r7, #12]
 820:./Lib/Src/stm32f4xx_pwr.c ****   
 821:./Lib/Src/stm32f4xx_pwr.c ****   /* Set LPDS, MRLVDS and LPLVDS bits according to PWR_Regulator value */
 822:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator;
 724              		.loc 1 822 10
 725 0022 FA68     		ldr	r2, [r7, #12]
 726 0024 7B68     		ldr	r3, [r7, #4]
 727 0026 1343     		orrs	r3, r3, r2
 728 0028 FB60     		str	r3, [r7, #12]
 823:./Lib/Src/stm32f4xx_pwr.c ****   
 824:./Lib/Src/stm32f4xx_pwr.c ****   /* Store the new value */
 825:./Lib/Src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 729              		.loc 1 825 6
 730 002a 0E4A     		ldr	r2, .L50
 731              		.loc 1 825 11
 732 002c FB68     		ldr	r3, [r7, #12]
 733 002e 1360     		str	r3, [r2]
 826:./Lib/Src/stm32f4xx_pwr.c ****   
 827:./Lib/Src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
ARM GAS  /tmp/ccNgkk2X.s 			page 28


 828:./Lib/Src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 734              		.loc 1 828 6
 735 0030 0D4B     		ldr	r3, .L50+4
 736 0032 1B69     		ldr	r3, [r3, #16]
 737 0034 0C4A     		ldr	r2, .L50+4
 738              		.loc 1 828 12
 739 0036 43F00403 		orr	r3, r3, #4
 740 003a 1361     		str	r3, [r2, #16]
 829:./Lib/Src/stm32f4xx_pwr.c ****   
 830:./Lib/Src/stm32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 831:./Lib/Src/stm32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 741              		.loc 1 831 5
 742 003c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 743 003e 012B     		cmp	r3, #1
 744 0040 01D1     		bne	.L48
 745              	.LBB12:
 746              	.LBB13:
 747              		.file 2 "./Start/core_cmInstr.h"
   1:./Start/core_cmInstr.h **** /**************************************************************************//**
   2:./Start/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:./Start/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:./Start/core_cmInstr.h ****  * @version  V4.10
   5:./Start/core_cmInstr.h ****  * @date     18. March 2015
   6:./Start/core_cmInstr.h ****  *
   7:./Start/core_cmInstr.h ****  * @note
   8:./Start/core_cmInstr.h ****  *
   9:./Start/core_cmInstr.h ****  ******************************************************************************/
  10:./Start/core_cmInstr.h **** /* Copyright (c) 2009 - 2014 ARM LIMITED
  11:./Start/core_cmInstr.h **** 
  12:./Start/core_cmInstr.h ****    All rights reserved.
  13:./Start/core_cmInstr.h ****    Redistribution and use in source and binary forms, with or without
  14:./Start/core_cmInstr.h ****    modification, are permitted provided that the following conditions are met:
  15:./Start/core_cmInstr.h ****    - Redistributions of source code must retain the above copyright
  16:./Start/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer.
  17:./Start/core_cmInstr.h ****    - Redistributions in binary form must reproduce the above copyright
  18:./Start/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer in the
  19:./Start/core_cmInstr.h ****      documentation and/or other materials provided with the distribution.
  20:./Start/core_cmInstr.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:./Start/core_cmInstr.h ****      to endorse or promote products derived from this software without
  22:./Start/core_cmInstr.h ****      specific prior written permission.
  23:./Start/core_cmInstr.h ****    *
  24:./Start/core_cmInstr.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:./Start/core_cmInstr.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:./Start/core_cmInstr.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:./Start/core_cmInstr.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:./Start/core_cmInstr.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:./Start/core_cmInstr.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:./Start/core_cmInstr.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:./Start/core_cmInstr.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:./Start/core_cmInstr.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:./Start/core_cmInstr.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:./Start/core_cmInstr.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:./Start/core_cmInstr.h ****    ---------------------------------------------------------------------------*/
  36:./Start/core_cmInstr.h **** 
  37:./Start/core_cmInstr.h **** 
  38:./Start/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  39:./Start/core_cmInstr.h **** #define __CORE_CMINSTR_H
ARM GAS  /tmp/ccNgkk2X.s 			page 29


  40:./Start/core_cmInstr.h **** 
  41:./Start/core_cmInstr.h **** 
  42:./Start/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  43:./Start/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  44:./Start/core_cmInstr.h ****   Access to dedicated instructions
  45:./Start/core_cmInstr.h ****   @{
  46:./Start/core_cmInstr.h **** */
  47:./Start/core_cmInstr.h **** 
  48:./Start/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:./Start/core_cmInstr.h **** /* ARM armcc specific functions */
  50:./Start/core_cmInstr.h **** 
  51:./Start/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  52:./Start/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:./Start/core_cmInstr.h **** #endif
  54:./Start/core_cmInstr.h **** 
  55:./Start/core_cmInstr.h **** 
  56:./Start/core_cmInstr.h **** /** \brief  No Operation
  57:./Start/core_cmInstr.h **** 
  58:./Start/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  59:./Start/core_cmInstr.h ****  */
  60:./Start/core_cmInstr.h **** #define __NOP                             __nop
  61:./Start/core_cmInstr.h **** 
  62:./Start/core_cmInstr.h **** 
  63:./Start/core_cmInstr.h **** /** \brief  Wait For Interrupt
  64:./Start/core_cmInstr.h **** 
  65:./Start/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  66:./Start/core_cmInstr.h ****     until one of a number of events occurs.
  67:./Start/core_cmInstr.h ****  */
  68:./Start/core_cmInstr.h **** #define __WFI                             __wfi
  69:./Start/core_cmInstr.h **** 
  70:./Start/core_cmInstr.h **** 
  71:./Start/core_cmInstr.h **** /** \brief  Wait For Event
  72:./Start/core_cmInstr.h **** 
  73:./Start/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  74:./Start/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  75:./Start/core_cmInstr.h ****  */
  76:./Start/core_cmInstr.h **** #define __WFE                             __wfe
  77:./Start/core_cmInstr.h **** 
  78:./Start/core_cmInstr.h **** 
  79:./Start/core_cmInstr.h **** /** \brief  Send Event
  80:./Start/core_cmInstr.h **** 
  81:./Start/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  82:./Start/core_cmInstr.h ****  */
  83:./Start/core_cmInstr.h **** #define __SEV                             __sev
  84:./Start/core_cmInstr.h **** 
  85:./Start/core_cmInstr.h **** 
  86:./Start/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  87:./Start/core_cmInstr.h **** 
  88:./Start/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  89:./Start/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  90:./Start/core_cmInstr.h ****     memory, after the instruction has been completed.
  91:./Start/core_cmInstr.h ****  */
  92:./Start/core_cmInstr.h **** #define __ISB() do {\
  93:./Start/core_cmInstr.h ****                    __schedule_barrier();\
  94:./Start/core_cmInstr.h ****                    __isb(0xF);\
  95:./Start/core_cmInstr.h ****                    __schedule_barrier();\
  96:./Start/core_cmInstr.h ****                 } while (0)
ARM GAS  /tmp/ccNgkk2X.s 			page 30


  97:./Start/core_cmInstr.h **** 
  98:./Start/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  99:./Start/core_cmInstr.h **** 
 100:./Start/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
 101:./Start/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
 102:./Start/core_cmInstr.h ****  */
 103:./Start/core_cmInstr.h **** #define __DSB() do {\
 104:./Start/core_cmInstr.h ****                    __schedule_barrier();\
 105:./Start/core_cmInstr.h ****                    __dsb(0xF);\
 106:./Start/core_cmInstr.h ****                    __schedule_barrier();\
 107:./Start/core_cmInstr.h ****                 } while (0)
 108:./Start/core_cmInstr.h **** 
 109:./Start/core_cmInstr.h **** /** \brief  Data Memory Barrier
 110:./Start/core_cmInstr.h **** 
 111:./Start/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 112:./Start/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 113:./Start/core_cmInstr.h ****  */
 114:./Start/core_cmInstr.h **** #define __DMB() do {\
 115:./Start/core_cmInstr.h ****                    __schedule_barrier();\
 116:./Start/core_cmInstr.h ****                    __dmb(0xF);\
 117:./Start/core_cmInstr.h ****                    __schedule_barrier();\
 118:./Start/core_cmInstr.h ****                 } while (0)
 119:./Start/core_cmInstr.h **** 
 120:./Start/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 121:./Start/core_cmInstr.h **** 
 122:./Start/core_cmInstr.h ****     This function reverses the byte order in integer value.
 123:./Start/core_cmInstr.h **** 
 124:./Start/core_cmInstr.h ****     \param [in]    value  Value to reverse
 125:./Start/core_cmInstr.h ****     \return               Reversed value
 126:./Start/core_cmInstr.h ****  */
 127:./Start/core_cmInstr.h **** #define __REV                             __rev
 128:./Start/core_cmInstr.h **** 
 129:./Start/core_cmInstr.h **** 
 130:./Start/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 131:./Start/core_cmInstr.h **** 
 132:./Start/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 133:./Start/core_cmInstr.h **** 
 134:./Start/core_cmInstr.h ****     \param [in]    value  Value to reverse
 135:./Start/core_cmInstr.h ****     \return               Reversed value
 136:./Start/core_cmInstr.h ****  */
 137:./Start/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 138:./Start/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 139:./Start/core_cmInstr.h **** {
 140:./Start/core_cmInstr.h ****   rev16 r0, r0
 141:./Start/core_cmInstr.h ****   bx lr
 142:./Start/core_cmInstr.h **** }
 143:./Start/core_cmInstr.h **** #endif
 144:./Start/core_cmInstr.h **** 
 145:./Start/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 146:./Start/core_cmInstr.h **** 
 147:./Start/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 148:./Start/core_cmInstr.h **** 
 149:./Start/core_cmInstr.h ****     \param [in]    value  Value to reverse
 150:./Start/core_cmInstr.h ****     \return               Reversed value
 151:./Start/core_cmInstr.h ****  */
 152:./Start/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 153:./Start/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
ARM GAS  /tmp/ccNgkk2X.s 			page 31


 154:./Start/core_cmInstr.h **** {
 155:./Start/core_cmInstr.h ****   revsh r0, r0
 156:./Start/core_cmInstr.h ****   bx lr
 157:./Start/core_cmInstr.h **** }
 158:./Start/core_cmInstr.h **** #endif
 159:./Start/core_cmInstr.h **** 
 160:./Start/core_cmInstr.h **** 
 161:./Start/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 162:./Start/core_cmInstr.h **** 
 163:./Start/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 164:./Start/core_cmInstr.h **** 
 165:./Start/core_cmInstr.h ****     \param [in]    value  Value to rotate
 166:./Start/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 167:./Start/core_cmInstr.h ****     \return               Rotated value
 168:./Start/core_cmInstr.h ****  */
 169:./Start/core_cmInstr.h **** #define __ROR                             __ror
 170:./Start/core_cmInstr.h **** 
 171:./Start/core_cmInstr.h **** 
 172:./Start/core_cmInstr.h **** /** \brief  Breakpoint
 173:./Start/core_cmInstr.h **** 
 174:./Start/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 175:./Start/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 176:./Start/core_cmInstr.h **** 
 177:./Start/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 178:./Start/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 179:./Start/core_cmInstr.h ****  */
 180:./Start/core_cmInstr.h **** #define __BKPT(value)                       __breakpoint(value)
 181:./Start/core_cmInstr.h **** 
 182:./Start/core_cmInstr.h **** 
 183:./Start/core_cmInstr.h **** /** \brief  Reverse bit order of value
 184:./Start/core_cmInstr.h **** 
 185:./Start/core_cmInstr.h ****     This function reverses the bit order of the given value.
 186:./Start/core_cmInstr.h **** 
 187:./Start/core_cmInstr.h ****     \param [in]    value  Value to reverse
 188:./Start/core_cmInstr.h ****     \return               Reversed value
 189:./Start/core_cmInstr.h ****  */
 190:./Start/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
 191:./Start/core_cmInstr.h ****   #define __RBIT                          __rbit
 192:./Start/core_cmInstr.h **** #else
 193:./Start/core_cmInstr.h **** __attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
 194:./Start/core_cmInstr.h **** {
 195:./Start/core_cmInstr.h ****   uint32_t result;
 196:./Start/core_cmInstr.h ****   int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
 197:./Start/core_cmInstr.h **** 
 198:./Start/core_cmInstr.h ****   result = value;                      // r will be reversed bits of v; first get LSB of v
 199:./Start/core_cmInstr.h ****   for (value >>= 1; value; value >>= 1)
 200:./Start/core_cmInstr.h ****   {
 201:./Start/core_cmInstr.h ****     result <<= 1;
 202:./Start/core_cmInstr.h ****     result |= value & 1;
 203:./Start/core_cmInstr.h ****     s--;
 204:./Start/core_cmInstr.h ****   }
 205:./Start/core_cmInstr.h ****   result <<= s;                       // shift when v's highest bits are zero
 206:./Start/core_cmInstr.h ****   return(result);
 207:./Start/core_cmInstr.h **** }
 208:./Start/core_cmInstr.h **** #endif
 209:./Start/core_cmInstr.h **** 
 210:./Start/core_cmInstr.h **** 
ARM GAS  /tmp/ccNgkk2X.s 			page 32


 211:./Start/core_cmInstr.h **** /** \brief  Count leading zeros
 212:./Start/core_cmInstr.h **** 
 213:./Start/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 214:./Start/core_cmInstr.h **** 
 215:./Start/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 216:./Start/core_cmInstr.h ****     \return             number of leading zeros in value
 217:./Start/core_cmInstr.h ****  */
 218:./Start/core_cmInstr.h **** #define __CLZ                             __clz
 219:./Start/core_cmInstr.h **** 
 220:./Start/core_cmInstr.h **** 
 221:./Start/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
 222:./Start/core_cmInstr.h **** 
 223:./Start/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 224:./Start/core_cmInstr.h **** 
 225:./Start/core_cmInstr.h ****     This function executes a exclusive LDR instruction for 8 bit value.
 226:./Start/core_cmInstr.h **** 
 227:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 228:./Start/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 229:./Start/core_cmInstr.h ****  */
 230:./Start/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 231:./Start/core_cmInstr.h **** 
 232:./Start/core_cmInstr.h **** 
 233:./Start/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 234:./Start/core_cmInstr.h **** 
 235:./Start/core_cmInstr.h ****     This function executes a exclusive LDR instruction for 16 bit values.
 236:./Start/core_cmInstr.h **** 
 237:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 238:./Start/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 239:./Start/core_cmInstr.h ****  */
 240:./Start/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 241:./Start/core_cmInstr.h **** 
 242:./Start/core_cmInstr.h **** 
 243:./Start/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 244:./Start/core_cmInstr.h **** 
 245:./Start/core_cmInstr.h ****     This function executes a exclusive LDR instruction for 32 bit values.
 246:./Start/core_cmInstr.h **** 
 247:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 248:./Start/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 249:./Start/core_cmInstr.h ****  */
 250:./Start/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 251:./Start/core_cmInstr.h **** 
 252:./Start/core_cmInstr.h **** 
 253:./Start/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 254:./Start/core_cmInstr.h **** 
 255:./Start/core_cmInstr.h ****     This function executes a exclusive STR instruction for 8 bit values.
 256:./Start/core_cmInstr.h **** 
 257:./Start/core_cmInstr.h ****     \param [in]  value  Value to store
 258:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 259:./Start/core_cmInstr.h ****     \return          0  Function succeeded
 260:./Start/core_cmInstr.h ****     \return          1  Function failed
 261:./Start/core_cmInstr.h ****  */
 262:./Start/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 263:./Start/core_cmInstr.h **** 
 264:./Start/core_cmInstr.h **** 
 265:./Start/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 266:./Start/core_cmInstr.h **** 
 267:./Start/core_cmInstr.h ****     This function executes a exclusive STR instruction for 16 bit values.
ARM GAS  /tmp/ccNgkk2X.s 			page 33


 268:./Start/core_cmInstr.h **** 
 269:./Start/core_cmInstr.h ****     \param [in]  value  Value to store
 270:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 271:./Start/core_cmInstr.h ****     \return          0  Function succeeded
 272:./Start/core_cmInstr.h ****     \return          1  Function failed
 273:./Start/core_cmInstr.h ****  */
 274:./Start/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 275:./Start/core_cmInstr.h **** 
 276:./Start/core_cmInstr.h **** 
 277:./Start/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 278:./Start/core_cmInstr.h **** 
 279:./Start/core_cmInstr.h ****     This function executes a exclusive STR instruction for 32 bit values.
 280:./Start/core_cmInstr.h **** 
 281:./Start/core_cmInstr.h ****     \param [in]  value  Value to store
 282:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 283:./Start/core_cmInstr.h ****     \return          0  Function succeeded
 284:./Start/core_cmInstr.h ****     \return          1  Function failed
 285:./Start/core_cmInstr.h ****  */
 286:./Start/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 287:./Start/core_cmInstr.h **** 
 288:./Start/core_cmInstr.h **** 
 289:./Start/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 290:./Start/core_cmInstr.h **** 
 291:./Start/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 292:./Start/core_cmInstr.h **** 
 293:./Start/core_cmInstr.h ****  */
 294:./Start/core_cmInstr.h **** #define __CLREX                           __clrex
 295:./Start/core_cmInstr.h **** 
 296:./Start/core_cmInstr.h **** 
 297:./Start/core_cmInstr.h **** /** \brief  Signed Saturate
 298:./Start/core_cmInstr.h **** 
 299:./Start/core_cmInstr.h ****     This function saturates a signed value.
 300:./Start/core_cmInstr.h **** 
 301:./Start/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 302:./Start/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 303:./Start/core_cmInstr.h ****     \return             Saturated value
 304:./Start/core_cmInstr.h ****  */
 305:./Start/core_cmInstr.h **** #define __SSAT                            __ssat
 306:./Start/core_cmInstr.h **** 
 307:./Start/core_cmInstr.h **** 
 308:./Start/core_cmInstr.h **** /** \brief  Unsigned Saturate
 309:./Start/core_cmInstr.h **** 
 310:./Start/core_cmInstr.h ****     This function saturates an unsigned value.
 311:./Start/core_cmInstr.h **** 
 312:./Start/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 313:./Start/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 314:./Start/core_cmInstr.h ****     \return             Saturated value
 315:./Start/core_cmInstr.h ****  */
 316:./Start/core_cmInstr.h **** #define __USAT                            __usat
 317:./Start/core_cmInstr.h **** 
 318:./Start/core_cmInstr.h **** 
 319:./Start/core_cmInstr.h **** /** \brief  Rotate Right with Extend (32 bit)
 320:./Start/core_cmInstr.h **** 
 321:./Start/core_cmInstr.h ****     This function moves each bit of a bitstring right by one bit.
 322:./Start/core_cmInstr.h ****     The carry input is shifted in at the left end of the bitstring.
 323:./Start/core_cmInstr.h **** 
 324:./Start/core_cmInstr.h ****     \param [in]    value  Value to rotate
ARM GAS  /tmp/ccNgkk2X.s 			page 34


 325:./Start/core_cmInstr.h ****     \return               Rotated value
 326:./Start/core_cmInstr.h ****  */
 327:./Start/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 328:./Start/core_cmInstr.h **** __attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
 329:./Start/core_cmInstr.h **** {
 330:./Start/core_cmInstr.h ****   rrx r0, r0
 331:./Start/core_cmInstr.h ****   bx lr
 332:./Start/core_cmInstr.h **** }
 333:./Start/core_cmInstr.h **** #endif
 334:./Start/core_cmInstr.h **** 
 335:./Start/core_cmInstr.h **** 
 336:./Start/core_cmInstr.h **** /** \brief  LDRT Unprivileged (8 bit)
 337:./Start/core_cmInstr.h **** 
 338:./Start/core_cmInstr.h ****     This function executes a Unprivileged LDRT instruction for 8 bit value.
 339:./Start/core_cmInstr.h **** 
 340:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 341:./Start/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 342:./Start/core_cmInstr.h ****  */
 343:./Start/core_cmInstr.h **** #define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
 344:./Start/core_cmInstr.h **** 
 345:./Start/core_cmInstr.h **** 
 346:./Start/core_cmInstr.h **** /** \brief  LDRT Unprivileged (16 bit)
 347:./Start/core_cmInstr.h **** 
 348:./Start/core_cmInstr.h ****     This function executes a Unprivileged LDRT instruction for 16 bit values.
 349:./Start/core_cmInstr.h **** 
 350:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 351:./Start/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 352:./Start/core_cmInstr.h ****  */
 353:./Start/core_cmInstr.h **** #define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
 354:./Start/core_cmInstr.h **** 
 355:./Start/core_cmInstr.h **** 
 356:./Start/core_cmInstr.h **** /** \brief  LDRT Unprivileged (32 bit)
 357:./Start/core_cmInstr.h **** 
 358:./Start/core_cmInstr.h ****     This function executes a Unprivileged LDRT instruction for 32 bit values.
 359:./Start/core_cmInstr.h **** 
 360:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 361:./Start/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 362:./Start/core_cmInstr.h ****  */
 363:./Start/core_cmInstr.h **** #define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
 364:./Start/core_cmInstr.h **** 
 365:./Start/core_cmInstr.h **** 
 366:./Start/core_cmInstr.h **** /** \brief  STRT Unprivileged (8 bit)
 367:./Start/core_cmInstr.h **** 
 368:./Start/core_cmInstr.h ****     This function executes a Unprivileged STRT instruction for 8 bit values.
 369:./Start/core_cmInstr.h **** 
 370:./Start/core_cmInstr.h ****     \param [in]  value  Value to store
 371:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 372:./Start/core_cmInstr.h ****  */
 373:./Start/core_cmInstr.h **** #define __STRBT(value, ptr)               __strt(value, ptr)
 374:./Start/core_cmInstr.h **** 
 375:./Start/core_cmInstr.h **** 
 376:./Start/core_cmInstr.h **** /** \brief  STRT Unprivileged (16 bit)
 377:./Start/core_cmInstr.h **** 
 378:./Start/core_cmInstr.h ****     This function executes a Unprivileged STRT instruction for 16 bit values.
 379:./Start/core_cmInstr.h **** 
 380:./Start/core_cmInstr.h ****     \param [in]  value  Value to store
 381:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
ARM GAS  /tmp/ccNgkk2X.s 			page 35


 382:./Start/core_cmInstr.h ****  */
 383:./Start/core_cmInstr.h **** #define __STRHT(value, ptr)               __strt(value, ptr)
 384:./Start/core_cmInstr.h **** 
 385:./Start/core_cmInstr.h **** 
 386:./Start/core_cmInstr.h **** /** \brief  STRT Unprivileged (32 bit)
 387:./Start/core_cmInstr.h **** 
 388:./Start/core_cmInstr.h ****     This function executes a Unprivileged STRT instruction for 32 bit values.
 389:./Start/core_cmInstr.h **** 
 390:./Start/core_cmInstr.h ****     \param [in]  value  Value to store
 391:./Start/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 392:./Start/core_cmInstr.h ****  */
 393:./Start/core_cmInstr.h **** #define __STRT(value, ptr)                __strt(value, ptr)
 394:./Start/core_cmInstr.h **** 
 395:./Start/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
 396:./Start/core_cmInstr.h **** 
 397:./Start/core_cmInstr.h **** 
 398:./Start/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 399:./Start/core_cmInstr.h **** /* GNU gcc specific functions */
 400:./Start/core_cmInstr.h **** 
 401:./Start/core_cmInstr.h **** /* Define macros for porting to both thumb1 and thumb2.
 402:./Start/core_cmInstr.h ****  * For thumb1, use low register (r0-r7), specified by constrant "l"
 403:./Start/core_cmInstr.h ****  * Otherwise, use general registers, specified by constrant "r" */
 404:./Start/core_cmInstr.h **** #if defined (__thumb__) && !defined (__thumb2__)
 405:./Start/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 406:./Start/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 407:./Start/core_cmInstr.h **** #else
 408:./Start/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 409:./Start/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 410:./Start/core_cmInstr.h **** #endif
 411:./Start/core_cmInstr.h **** 
 412:./Start/core_cmInstr.h **** /** \brief  No Operation
 413:./Start/core_cmInstr.h **** 
 414:./Start/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 415:./Start/core_cmInstr.h ****  */
 416:./Start/core_cmInstr.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 417:./Start/core_cmInstr.h **** {
 418:./Start/core_cmInstr.h ****   __ASM volatile ("nop");
 419:./Start/core_cmInstr.h **** }
 420:./Start/core_cmInstr.h **** 
 421:./Start/core_cmInstr.h **** 
 422:./Start/core_cmInstr.h **** /** \brief  Wait For Interrupt
 423:./Start/core_cmInstr.h **** 
 424:./Start/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 425:./Start/core_cmInstr.h ****     until one of a number of events occurs.
 426:./Start/core_cmInstr.h ****  */
 427:./Start/core_cmInstr.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 428:./Start/core_cmInstr.h **** {
 429:./Start/core_cmInstr.h ****   __ASM volatile ("wfi");
 748              		.loc 2 429 3
 749              		.syntax unified
 750              	@ 429 "./Start/core_cmInstr.h" 1
 751 0042 30BF     		wfi
 752              	@ 0 "" 2
 430:./Start/core_cmInstr.h **** }
 753              		.loc 2 430 1
 754              		.thumb
 755              		.syntax unified
ARM GAS  /tmp/ccNgkk2X.s 			page 36


 756 0044 01E0     		b	.L49
 757              	.L48:
 758              	.LBE13:
 759              	.LBE12:
 760              	.LBB14:
 761              	.LBB15:
 431:./Start/core_cmInstr.h **** 
 432:./Start/core_cmInstr.h **** 
 433:./Start/core_cmInstr.h **** /** \brief  Wait For Event
 434:./Start/core_cmInstr.h **** 
 435:./Start/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 436:./Start/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 437:./Start/core_cmInstr.h ****  */
 438:./Start/core_cmInstr.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 439:./Start/core_cmInstr.h **** {
 440:./Start/core_cmInstr.h ****   __ASM volatile ("wfe");
 762              		.loc 2 440 3
 763              		.syntax unified
 764              	@ 440 "./Start/core_cmInstr.h" 1
 765 0046 20BF     		wfe
 766              	@ 0 "" 2
 441:./Start/core_cmInstr.h **** }
 767              		.loc 2 441 1
 768              		.thumb
 769              		.syntax unified
 770 0048 00BF     		nop
 771              	.L49:
 772              	.LBE15:
 773              	.LBE14:
 832:./Lib/Src/stm32f4xx_pwr.c ****   {   
 833:./Lib/Src/stm32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 834:./Lib/Src/stm32f4xx_pwr.c ****     __WFI();
 835:./Lib/Src/stm32f4xx_pwr.c ****   }
 836:./Lib/Src/stm32f4xx_pwr.c ****   else
 837:./Lib/Src/stm32f4xx_pwr.c ****   {
 838:./Lib/Src/stm32f4xx_pwr.c ****     /* Request Wait For Event */
 839:./Lib/Src/stm32f4xx_pwr.c ****     __WFE();
 840:./Lib/Src/stm32f4xx_pwr.c ****   }
 841:./Lib/Src/stm32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 842:./Lib/Src/stm32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 774              		.loc 1 842 6
 775 004a 074B     		ldr	r3, .L50+4
 776 004c 1B69     		ldr	r3, [r3, #16]
 777 004e 064A     		ldr	r2, .L50+4
 778              		.loc 1 842 12
 779 0050 23F00403 		bic	r3, r3, #4
 780 0054 1361     		str	r3, [r2, #16]
 843:./Lib/Src/stm32f4xx_pwr.c **** }
 781              		.loc 1 843 1
 782 0056 00BF     		nop
 783 0058 1437     		adds	r7, r7, #20
 784              		.cfi_def_cfa_offset 4
 785 005a BD46     		mov	sp, r7
 786              		.cfi_def_cfa_register 13
 787              		@ sp needed
 788 005c 5DF8047B 		ldr	r7, [sp], #4
 789              		.cfi_restore 7
ARM GAS  /tmp/ccNgkk2X.s 			page 37


 790              		.cfi_def_cfa_offset 0
 791 0060 7047     		bx	lr
 792              	.L51:
 793 0062 00BF     		.align	2
 794              	.L50:
 795 0064 00700040 		.word	1073770496
 796 0068 00ED00E0 		.word	-536810240
 797              		.cfi_endproc
 798              	.LFE136:
 800              		.section	.text.PWR_EnterUnderDriveSTOPMode,"ax",%progbits
 801              		.align	1
 802              		.global	PWR_EnterUnderDriveSTOPMode
 803              		.syntax unified
 804              		.thumb
 805              		.thumb_func
 807              	PWR_EnterUnderDriveSTOPMode:
 808              	.LFB137:
 844:./Lib/Src/stm32f4xx_pwr.c **** 
 845:./Lib/Src/stm32f4xx_pwr.c **** /**
 846:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enters in Under-Drive STOP mode.
 847:./Lib/Src/stm32f4xx_pwr.c ****   *  
 848:./Lib/Src/stm32f4xx_pwr.c ****   * @note   This mode is only available for STM32F42xxx/STM3243xxx devices. 
 849:./Lib/Src/stm32f4xx_pwr.c ****   * 
 850:./Lib/Src/stm32f4xx_pwr.c ****   * @note    This mode can be selected only when the Under-Drive is already active 
 851:./Lib/Src/stm32f4xx_pwr.c ****   *         
 852:./Lib/Src/stm32f4xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 853:./Lib/Src/stm32f4xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 854:./Lib/Src/stm32f4xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 855:./Lib/Src/stm32f4xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 856:./Lib/Src/stm32f4xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 857:./Lib/Src/stm32f4xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 858:./Lib/Src/stm32f4xx_pwr.c ****   *         is higher although the startup time is reduced.
 859:./Lib/Src/stm32f4xx_pwr.c ****   *     
 860:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 861:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 862:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_MainRegulator_UnderDrive_ON:  Main Regulator in under-drive mode 
 863:./Lib/Src/stm32f4xx_pwr.c ****   *                 and Flash memory in power-down when the device is in Stop under-drive mode
 864:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_LowPowerRegulator_UnderDrive_ON:  Low Power Regulator in under-drive mode 
 865:./Lib/Src/stm32f4xx_pwr.c ****   *                and Flash memory in power-down when the device is in Stop under-drive mode
 866:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 867:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 868:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 869:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 870:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 871:./Lib/Src/stm32f4xx_pwr.c ****   */
 872:./Lib/Src/stm32f4xx_pwr.c **** void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 873:./Lib/Src/stm32f4xx_pwr.c **** {
 809              		.loc 1 873 1
 810              		.cfi_startproc
 811              		@ args = 0, pretend = 0, frame = 16
 812              		@ frame_needed = 1, uses_anonymous_args = 0
 813              		@ link register save eliminated.
 814 0000 80B4     		push	{r7}
 815              		.cfi_def_cfa_offset 4
 816              		.cfi_offset 7, -4
 817 0002 85B0     		sub	sp, sp, #20
 818              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccNgkk2X.s 			page 38


 819 0004 00AF     		add	r7, sp, #0
 820              		.cfi_def_cfa_register 7
 821 0006 7860     		str	r0, [r7, #4]
 822 0008 0B46     		mov	r3, r1
 823 000a FB70     		strb	r3, [r7, #3]
 874:./Lib/Src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 824              		.loc 1 874 12
 825 000c 0023     		movs	r3, #0
 826 000e FB60     		str	r3, [r7, #12]
 875:./Lib/Src/stm32f4xx_pwr.c ****   
 876:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 877:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR_UNDERDRIVE(PWR_Regulator));
 878:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 879:./Lib/Src/stm32f4xx_pwr.c ****   
 880:./Lib/Src/stm32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 881:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 827              		.loc 1 881 15
 828 0010 144B     		ldr	r3, .L55
 829              		.loc 1 881 10
 830 0012 1B68     		ldr	r3, [r3]
 831 0014 FB60     		str	r3, [r7, #12]
 882:./Lib/Src/stm32f4xx_pwr.c ****   /* Clear PDDS and LPDS bits */
 883:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 832              		.loc 1 883 10
 833 0016 FB68     		ldr	r3, [r7, #12]
 834 0018 23F44063 		bic	r3, r3, #3072
 835 001c 23F00303 		bic	r3, r3, #3
 836 0020 FB60     		str	r3, [r7, #12]
 884:./Lib/Src/stm32f4xx_pwr.c ****   
 885:./Lib/Src/stm32f4xx_pwr.c ****   /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
 886:./Lib/Src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator;
 837              		.loc 1 886 10
 838 0022 FA68     		ldr	r2, [r7, #12]
 839 0024 7B68     		ldr	r3, [r7, #4]
 840 0026 1343     		orrs	r3, r3, r2
 841 0028 FB60     		str	r3, [r7, #12]
 887:./Lib/Src/stm32f4xx_pwr.c ****   
 888:./Lib/Src/stm32f4xx_pwr.c ****   /* Store the new value */
 889:./Lib/Src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 842              		.loc 1 889 6
 843 002a 0E4A     		ldr	r2, .L55
 844              		.loc 1 889 11
 845 002c FB68     		ldr	r3, [r7, #12]
 846 002e 1360     		str	r3, [r2]
 890:./Lib/Src/stm32f4xx_pwr.c ****   
 891:./Lib/Src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 892:./Lib/Src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 847              		.loc 1 892 6
 848 0030 0D4B     		ldr	r3, .L55+4
 849 0032 1B69     		ldr	r3, [r3, #16]
 850 0034 0C4A     		ldr	r2, .L55+4
 851              		.loc 1 892 12
 852 0036 43F00403 		orr	r3, r3, #4
 853 003a 1361     		str	r3, [r2, #16]
 893:./Lib/Src/stm32f4xx_pwr.c ****   
 894:./Lib/Src/stm32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 895:./Lib/Src/stm32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
ARM GAS  /tmp/ccNgkk2X.s 			page 39


 854              		.loc 1 895 5
 855 003c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 856 003e 012B     		cmp	r3, #1
 857 0040 01D1     		bne	.L53
 858              	.LBB16:
 859              	.LBB17:
 429:./Start/core_cmInstr.h **** }
 860              		.loc 2 429 3
 861              		.syntax unified
 862              	@ 429 "./Start/core_cmInstr.h" 1
 863 0042 30BF     		wfi
 864              	@ 0 "" 2
 430:./Start/core_cmInstr.h **** 
 865              		.loc 2 430 1
 866              		.thumb
 867              		.syntax unified
 868 0044 01E0     		b	.L54
 869              	.L53:
 870              	.LBE17:
 871              	.LBE16:
 872              	.LBB18:
 873              	.LBB19:
 440:./Start/core_cmInstr.h **** }
 874              		.loc 2 440 3
 875              		.syntax unified
 876              	@ 440 "./Start/core_cmInstr.h" 1
 877 0046 20BF     		wfe
 878              	@ 0 "" 2
 879              		.loc 2 441 1
 880              		.thumb
 881              		.syntax unified
 882 0048 00BF     		nop
 883              	.L54:
 884              	.LBE19:
 885              	.LBE18:
 896:./Lib/Src/stm32f4xx_pwr.c ****   {   
 897:./Lib/Src/stm32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 898:./Lib/Src/stm32f4xx_pwr.c ****     __WFI();
 899:./Lib/Src/stm32f4xx_pwr.c ****   }
 900:./Lib/Src/stm32f4xx_pwr.c ****   else
 901:./Lib/Src/stm32f4xx_pwr.c ****   {
 902:./Lib/Src/stm32f4xx_pwr.c ****     /* Request Wait For Event */
 903:./Lib/Src/stm32f4xx_pwr.c ****     __WFE();
 904:./Lib/Src/stm32f4xx_pwr.c ****   }
 905:./Lib/Src/stm32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 906:./Lib/Src/stm32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 886              		.loc 1 906 6
 887 004a 074B     		ldr	r3, .L55+4
 888 004c 1B69     		ldr	r3, [r3, #16]
 889 004e 064A     		ldr	r2, .L55+4
 890              		.loc 1 906 12
 891 0050 23F00403 		bic	r3, r3, #4
 892 0054 1361     		str	r3, [r2, #16]
 907:./Lib/Src/stm32f4xx_pwr.c **** }
 893              		.loc 1 907 1
 894 0056 00BF     		nop
 895 0058 1437     		adds	r7, r7, #20
ARM GAS  /tmp/ccNgkk2X.s 			page 40


 896              		.cfi_def_cfa_offset 4
 897 005a BD46     		mov	sp, r7
 898              		.cfi_def_cfa_register 13
 899              		@ sp needed
 900 005c 5DF8047B 		ldr	r7, [sp], #4
 901              		.cfi_restore 7
 902              		.cfi_def_cfa_offset 0
 903 0060 7047     		bx	lr
 904              	.L56:
 905 0062 00BF     		.align	2
 906              	.L55:
 907 0064 00700040 		.word	1073770496
 908 0068 00ED00E0 		.word	-536810240
 909              		.cfi_endproc
 910              	.LFE137:
 912              		.section	.text.PWR_EnterSTANDBYMode,"ax",%progbits
 913              		.align	1
 914              		.global	PWR_EnterSTANDBYMode
 915              		.syntax unified
 916              		.thumb
 917              		.thumb_func
 919              	PWR_EnterSTANDBYMode:
 920              	.LFB138:
 908:./Lib/Src/stm32f4xx_pwr.c **** 
 909:./Lib/Src/stm32f4xx_pwr.c **** /**
 910:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Enters STANDBY mode.
 911:./Lib/Src/stm32f4xx_pwr.c ****   * @note   In Standby mode, all I/O pins are high impedance except for:
 912:./Lib/Src/stm32f4xx_pwr.c ****   *          - Reset pad (still available) 
 913:./Lib/Src/stm32f4xx_pwr.c ****   *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
 914:./Lib/Src/stm32f4xx_pwr.c ****   *            Alarm out, or RTC clock calibration out.
 915:./Lib/Src/stm32f4xx_pwr.c ****   *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
 916:./Lib/Src/stm32f4xx_pwr.c ****   *          - WKUP pin 1 (PA0) if enabled.
 917:./Lib/Src/stm32f4xx_pwr.c ****   * @note   The Wakeup flag (WUF) need to be cleared at application level before to call this funct
 918:./Lib/Src/stm32f4xx_pwr.c ****   * @param  None
 919:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
 920:./Lib/Src/stm32f4xx_pwr.c ****   */
 921:./Lib/Src/stm32f4xx_pwr.c **** void PWR_EnterSTANDBYMode(void)
 922:./Lib/Src/stm32f4xx_pwr.c **** {
 921              		.loc 1 922 1
 922              		.cfi_startproc
 923              		@ args = 0, pretend = 0, frame = 0
 924              		@ frame_needed = 1, uses_anonymous_args = 0
 925              		@ link register save eliminated.
 926 0000 80B4     		push	{r7}
 927              		.cfi_def_cfa_offset 4
 928              		.cfi_offset 7, -4
 929 0002 00AF     		add	r7, sp, #0
 930              		.cfi_def_cfa_register 7
 923:./Lib/Src/stm32f4xx_pwr.c ****   /* Select STANDBY mode */
 924:./Lib/Src/stm32f4xx_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 931              		.loc 1 924 6
 932 0004 094B     		ldr	r3, .L58
 933 0006 1B68     		ldr	r3, [r3]
 934 0008 084A     		ldr	r2, .L58
 935              		.loc 1 924 11
 936 000a 43F00203 		orr	r3, r3, #2
 937 000e 1360     		str	r3, [r2]
ARM GAS  /tmp/ccNgkk2X.s 			page 41


 925:./Lib/Src/stm32f4xx_pwr.c ****   
 926:./Lib/Src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 927:./Lib/Src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 938              		.loc 1 927 6
 939 0010 074B     		ldr	r3, .L58+4
 940 0012 1B69     		ldr	r3, [r3, #16]
 941 0014 064A     		ldr	r2, .L58+4
 942              		.loc 1 927 12
 943 0016 43F00403 		orr	r3, r3, #4
 944 001a 1361     		str	r3, [r2, #16]
 945              	.LBB20:
 946              	.LBB21:
 429:./Start/core_cmInstr.h **** }
 947              		.loc 2 429 3
 948              		.syntax unified
 949              	@ 429 "./Start/core_cmInstr.h" 1
 950 001c 30BF     		wfi
 951              	@ 0 "" 2
 430:./Start/core_cmInstr.h **** 
 952              		.loc 2 430 1
 953              		.thumb
 954              		.syntax unified
 955 001e 00BF     		nop
 956              	.LBE21:
 957              	.LBE20:
 928:./Lib/Src/stm32f4xx_pwr.c ****   
 929:./Lib/Src/stm32f4xx_pwr.c ****   /* This option is used to ensure that store operations are completed */
 930:./Lib/Src/stm32f4xx_pwr.c **** #if defined ( __CC_ARM   )
 931:./Lib/Src/stm32f4xx_pwr.c ****   __force_stores();
 932:./Lib/Src/stm32f4xx_pwr.c **** #endif
 933:./Lib/Src/stm32f4xx_pwr.c ****   /* Request Wait For Interrupt */
 934:./Lib/Src/stm32f4xx_pwr.c ****   __WFI();
 935:./Lib/Src/stm32f4xx_pwr.c **** }
 958              		.loc 1 935 1
 959 0020 00BF     		nop
 960 0022 BD46     		mov	sp, r7
 961              		.cfi_def_cfa_register 13
 962              		@ sp needed
 963 0024 5DF8047B 		ldr	r7, [sp], #4
 964              		.cfi_restore 7
 965              		.cfi_def_cfa_offset 0
 966 0028 7047     		bx	lr
 967              	.L59:
 968 002a 00BF     		.align	2
 969              	.L58:
 970 002c 00700040 		.word	1073770496
 971 0030 00ED00E0 		.word	-536810240
 972              		.cfi_endproc
 973              	.LFE138:
 975              		.section	.text.PWR_GetFlagStatus,"ax",%progbits
 976              		.align	1
 977              		.global	PWR_GetFlagStatus
 978              		.syntax unified
 979              		.thumb
 980              		.thumb_func
 982              	PWR_GetFlagStatus:
 983              	.LFB139:
ARM GAS  /tmp/ccNgkk2X.s 			page 42


 936:./Lib/Src/stm32f4xx_pwr.c **** 
 937:./Lib/Src/stm32f4xx_pwr.c **** /**
 938:./Lib/Src/stm32f4xx_pwr.c ****   * @}
 939:./Lib/Src/stm32f4xx_pwr.c ****   */
 940:./Lib/Src/stm32f4xx_pwr.c **** 
 941:./Lib/Src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group7 Flags management functions
 942:./Lib/Src/stm32f4xx_pwr.c ****   *  @brief   Flags management functions 
 943:./Lib/Src/stm32f4xx_pwr.c ****   *
 944:./Lib/Src/stm32f4xx_pwr.c **** @verbatim   
 945:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================
 946:./Lib/Src/stm32f4xx_pwr.c ****                     ##### Flags management functions #####
 947:./Lib/Src/stm32f4xx_pwr.c ****  ===============================================================================  
 948:./Lib/Src/stm32f4xx_pwr.c **** 
 949:./Lib/Src/stm32f4xx_pwr.c **** @endverbatim
 950:./Lib/Src/stm32f4xx_pwr.c ****   * @{
 951:./Lib/Src/stm32f4xx_pwr.c ****   */
 952:./Lib/Src/stm32f4xx_pwr.c **** 
 953:./Lib/Src/stm32f4xx_pwr.c **** /**
 954:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 955:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 956:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 957:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
 958:./Lib/Src/stm32f4xx_pwr.c ****   *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
 959:./Lib/Src/stm32f4xx_pwr.c ****   *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
 960:./Lib/Src/stm32f4xx_pwr.c ****   *                  An additional wakeup event is detected if the WKUP pin is enabled 
 961:./Lib/Src/stm32f4xx_pwr.c ****   *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
 962:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
 963:./Lib/Src/stm32f4xx_pwr.c ****   *                  resumed from StandBy mode.    
 964:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
 965:./Lib/Src/stm32f4xx_pwr.c ****   *                  by the PWR_PVDCmd() function. The PVD is stopped by Standby mode 
 966:./Lib/Src/stm32f4xx_pwr.c ****   *                  For this reason, this bit is equal to 0 after Standby or reset
 967:./Lib/Src/stm32f4xx_pwr.c ****   *                  until the PVDE bit is set.
 968:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
 969:./Lib/Src/stm32f4xx_pwr.c ****   *                  when the device wakes up from Standby mode or by a system reset 
 970:./Lib/Src/stm32f4xx_pwr.c ****   *                  or power reset.  
 971:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
 972:./Lib/Src/stm32f4xx_pwr.c ****   *                 scaling output selection is ready.
 973:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
 974:./Lib/Src/stm32f4xx_pwr.c ****   *                 is ready (STM32F42xxx/43xxx devices) 
 975:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
 976:./Lib/Src/stm32f4xx_pwr.c ****   *                 switching is ready (STM32F42xxx/43xxx devices) 
 977:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
 978:./Lib/Src/stm32f4xx_pwr.c ****   *                 is enabled in Stop mode (STM32F42xxx/43xxx devices)
 979:./Lib/Src/stm32f4xx_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 980:./Lib/Src/stm32f4xx_pwr.c ****   */
 981:./Lib/Src/stm32f4xx_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
 982:./Lib/Src/stm32f4xx_pwr.c **** {
 984              		.loc 1 982 1
 985              		.cfi_startproc
 986              		@ args = 0, pretend = 0, frame = 16
 987              		@ frame_needed = 1, uses_anonymous_args = 0
 988              		@ link register save eliminated.
 989 0000 80B4     		push	{r7}
 990              		.cfi_def_cfa_offset 4
 991              		.cfi_offset 7, -4
 992 0002 85B0     		sub	sp, sp, #20
 993              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccNgkk2X.s 			page 43


 994 0004 00AF     		add	r7, sp, #0
 995              		.cfi_def_cfa_register 7
 996 0006 7860     		str	r0, [r7, #4]
 983:./Lib/Src/stm32f4xx_pwr.c ****   FlagStatus bitstatus = RESET;
 997              		.loc 1 983 14
 998 0008 0023     		movs	r3, #0
 999 000a FB73     		strb	r3, [r7, #15]
 984:./Lib/Src/stm32f4xx_pwr.c ****   
 985:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
 986:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 987:./Lib/Src/stm32f4xx_pwr.c ****   
 988:./Lib/Src/stm32f4xx_pwr.c ****   if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 1000              		.loc 1 988 11
 1001 000c 084B     		ldr	r3, .L64
 1002 000e 5A68     		ldr	r2, [r3, #4]
 1003              		.loc 1 988 17
 1004 0010 7B68     		ldr	r3, [r7, #4]
 1005 0012 1340     		ands	r3, r3, r2
 1006              		.loc 1 988 6
 1007 0014 002B     		cmp	r3, #0
 1008 0016 02D0     		beq	.L61
 989:./Lib/Src/stm32f4xx_pwr.c ****   {
 990:./Lib/Src/stm32f4xx_pwr.c ****     bitstatus = SET;
 1009              		.loc 1 990 15
 1010 0018 0123     		movs	r3, #1
 1011 001a FB73     		strb	r3, [r7, #15]
 1012 001c 01E0     		b	.L62
 1013              	.L61:
 991:./Lib/Src/stm32f4xx_pwr.c ****   }
 992:./Lib/Src/stm32f4xx_pwr.c ****   else
 993:./Lib/Src/stm32f4xx_pwr.c ****   {
 994:./Lib/Src/stm32f4xx_pwr.c ****     bitstatus = RESET;
 1014              		.loc 1 994 15
 1015 001e 0023     		movs	r3, #0
 1016 0020 FB73     		strb	r3, [r7, #15]
 1017              	.L62:
 995:./Lib/Src/stm32f4xx_pwr.c ****   }
 996:./Lib/Src/stm32f4xx_pwr.c ****   /* Return the flag status */
 997:./Lib/Src/stm32f4xx_pwr.c ****   return bitstatus;
 1018              		.loc 1 997 10
 1019 0022 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 998:./Lib/Src/stm32f4xx_pwr.c **** }
 1020              		.loc 1 998 1
 1021 0024 1846     		mov	r0, r3
 1022 0026 1437     		adds	r7, r7, #20
 1023              		.cfi_def_cfa_offset 4
 1024 0028 BD46     		mov	sp, r7
 1025              		.cfi_def_cfa_register 13
 1026              		@ sp needed
 1027 002a 5DF8047B 		ldr	r7, [sp], #4
 1028              		.cfi_restore 7
 1029              		.cfi_def_cfa_offset 0
 1030 002e 7047     		bx	lr
 1031              	.L65:
 1032              		.align	2
 1033              	.L64:
 1034 0030 00700040 		.word	1073770496
ARM GAS  /tmp/ccNgkk2X.s 			page 44


 1035              		.cfi_endproc
 1036              	.LFE139:
 1038              		.section	.text.PWR_ClearFlag,"ax",%progbits
 1039              		.align	1
 1040              		.global	PWR_ClearFlag
 1041              		.syntax unified
 1042              		.thumb
 1043              		.thumb_func
 1045              	PWR_ClearFlag:
 1046              	.LFB140:
 999:./Lib/Src/stm32f4xx_pwr.c **** 
1000:./Lib/Src/stm32f4xx_pwr.c **** /**
1001:./Lib/Src/stm32f4xx_pwr.c ****   * @brief  Clears the PWR's pending flags.
1002:./Lib/Src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
1003:./Lib/Src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
1004:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag
1005:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag
1006:./Lib/Src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_UDRDY: Under-drive ready flag (STM32F42xxx/43xxx devices)
1007:./Lib/Src/stm32f4xx_pwr.c ****   * @retval None
1008:./Lib/Src/stm32f4xx_pwr.c ****   */
1009:./Lib/Src/stm32f4xx_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
1010:./Lib/Src/stm32f4xx_pwr.c **** {
 1047              		.loc 1 1010 1
 1048              		.cfi_startproc
 1049              		@ args = 0, pretend = 0, frame = 8
 1050              		@ frame_needed = 1, uses_anonymous_args = 0
 1051              		@ link register save eliminated.
 1052 0000 80B4     		push	{r7}
 1053              		.cfi_def_cfa_offset 4
 1054              		.cfi_offset 7, -4
 1055 0002 83B0     		sub	sp, sp, #12
 1056              		.cfi_def_cfa_offset 16
 1057 0004 00AF     		add	r7, sp, #0
 1058              		.cfi_def_cfa_register 7
 1059 0006 7860     		str	r0, [r7, #4]
1011:./Lib/Src/stm32f4xx_pwr.c ****   /* Check the parameters */
1012:./Lib/Src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
1013:./Lib/Src/stm32f4xx_pwr.c ****   
1014:./Lib/Src/stm32f4xx_pwr.c **** #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
1015:./Lib/Src/stm32f4xx_pwr.c ****   if (PWR_FLAG != PWR_FLAG_UDRDY)
1016:./Lib/Src/stm32f4xx_pwr.c ****   {
1017:./Lib/Src/stm32f4xx_pwr.c ****     PWR->CR |=  PWR_FLAG << 2;
1018:./Lib/Src/stm32f4xx_pwr.c ****   }
1019:./Lib/Src/stm32f4xx_pwr.c ****   else
1020:./Lib/Src/stm32f4xx_pwr.c ****   {
1021:./Lib/Src/stm32f4xx_pwr.c ****     PWR->CSR |= PWR_FLAG_UDRDY;
1022:./Lib/Src/stm32f4xx_pwr.c ****   }
1023:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F427_437xx ||  STM32F429_439xx */
1024:./Lib/Src/stm32f4xx_pwr.c **** 
1025:./Lib/Src/stm32f4xx_pwr.c **** #if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F410xx) || defined (STM32F41
1026:./Lib/Src/stm32f4xx_pwr.c ****   PWR->CR |=  PWR_FLAG << 2;
 1060              		.loc 1 1026 6
 1061 0008 064B     		ldr	r3, .L67
 1062 000a 1A68     		ldr	r2, [r3]
 1063              		.loc 1 1026 24
 1064 000c 7B68     		ldr	r3, [r7, #4]
 1065 000e 9B00     		lsls	r3, r3, #2
ARM GAS  /tmp/ccNgkk2X.s 			page 45


 1066              		.loc 1 1026 6
 1067 0010 0449     		ldr	r1, .L67
 1068              		.loc 1 1026 11
 1069 0012 1343     		orrs	r3, r3, r2
 1070 0014 0B60     		str	r3, [r1]
1027:./Lib/Src/stm32f4xx_pwr.c **** #endif /* STM32F40_41xxx  || STM32F401xx || STM32F410xx || STM32F411xE || STM32F412xG || STM32F413_
1028:./Lib/Src/stm32f4xx_pwr.c **** }
 1071              		.loc 1 1028 1
 1072 0016 00BF     		nop
 1073 0018 0C37     		adds	r7, r7, #12
 1074              		.cfi_def_cfa_offset 4
 1075 001a BD46     		mov	sp, r7
 1076              		.cfi_def_cfa_register 13
 1077              		@ sp needed
 1078 001c 5DF8047B 		ldr	r7, [sp], #4
 1079              		.cfi_restore 7
 1080              		.cfi_def_cfa_offset 0
 1081 0020 7047     		bx	lr
 1082              	.L68:
 1083 0022 00BF     		.align	2
 1084              	.L67:
 1085 0024 00700040 		.word	1073770496
 1086              		.cfi_endproc
 1087              	.LFE140:
 1089              		.text
 1090              	.Letext0:
 1091              		.file 3 "/usr/lib/gcc/arm-none-eabi/12.2.1/include/stdint.h"
 1092              		.file 4 "./Start/core_cm4.h"
 1093              		.file 5 "./Start/stm32f4xx.h"
 1094              		.file 6 "./Lib/inc/stm32f4xx_rcc.h"
ARM GAS  /tmp/ccNgkk2X.s 			page 46


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f4xx_pwr.c
     /tmp/ccNgkk2X.s:21     .text.PWR_DeInit:0000000000000000 $t
     /tmp/ccNgkk2X.s:27     .text.PWR_DeInit:0000000000000000 PWR_DeInit
     /tmp/ccNgkk2X.s:54     .text.PWR_BackupAccessCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:60     .text.PWR_BackupAccessCmd:0000000000000000 PWR_BackupAccessCmd
     /tmp/ccNgkk2X.s:96     .text.PWR_BackupAccessCmd:000000000000001c $d
     /tmp/ccNgkk2X.s:101    .text.PWR_PVDLevelConfig:0000000000000000 $t
     /tmp/ccNgkk2X.s:107    .text.PWR_PVDLevelConfig:0000000000000000 PWR_PVDLevelConfig
     /tmp/ccNgkk2X.s:158    .text.PWR_PVDLevelConfig:0000000000000034 $d
     /tmp/ccNgkk2X.s:163    .text.PWR_PVDCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:169    .text.PWR_PVDCmd:0000000000000000 PWR_PVDCmd
     /tmp/ccNgkk2X.s:205    .text.PWR_PVDCmd:000000000000001c $d
     /tmp/ccNgkk2X.s:210    .text.PWR_WakeUpPinCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:216    .text.PWR_WakeUpPinCmd:0000000000000000 PWR_WakeUpPinCmd
     /tmp/ccNgkk2X.s:252    .text.PWR_WakeUpPinCmd:000000000000001c $d
     /tmp/ccNgkk2X.s:257    .text.PWR_BackupRegulatorCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:263    .text.PWR_BackupRegulatorCmd:0000000000000000 PWR_BackupRegulatorCmd
     /tmp/ccNgkk2X.s:299    .text.PWR_BackupRegulatorCmd:000000000000001c $d
     /tmp/ccNgkk2X.s:304    .text.PWR_MainRegulatorModeConfig:0000000000000000 $t
     /tmp/ccNgkk2X.s:310    .text.PWR_MainRegulatorModeConfig:0000000000000000 PWR_MainRegulatorModeConfig
     /tmp/ccNgkk2X.s:361    .text.PWR_MainRegulatorModeConfig:0000000000000034 $d
     /tmp/ccNgkk2X.s:366    .text.PWR_OverDriveCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:372    .text.PWR_OverDriveCmd:0000000000000000 PWR_OverDriveCmd
     /tmp/ccNgkk2X.s:408    .text.PWR_OverDriveCmd:000000000000001c $d
     /tmp/ccNgkk2X.s:413    .text.PWR_OverDriveSWCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:419    .text.PWR_OverDriveSWCmd:0000000000000000 PWR_OverDriveSWCmd
     /tmp/ccNgkk2X.s:455    .text.PWR_OverDriveSWCmd:000000000000001c $d
     /tmp/ccNgkk2X.s:460    .text.PWR_UnderDriveCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:466    .text.PWR_UnderDriveCmd:0000000000000000 PWR_UnderDriveCmd
     /tmp/ccNgkk2X.s:518    .text.PWR_UnderDriveCmd:0000000000000038 $d
     /tmp/ccNgkk2X.s:523    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:529    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000000 PWR_MainRegulatorLowVoltageCmd
     /tmp/ccNgkk2X.s:577    .text.PWR_MainRegulatorLowVoltageCmd:000000000000002c $d
     /tmp/ccNgkk2X.s:582    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:588    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000000 PWR_LowRegulatorLowVoltageCmd
     /tmp/ccNgkk2X.s:636    .text.PWR_LowRegulatorLowVoltageCmd:000000000000002c $d
     /tmp/ccNgkk2X.s:641    .text.PWR_FlashPowerDownCmd:0000000000000000 $t
     /tmp/ccNgkk2X.s:647    .text.PWR_FlashPowerDownCmd:0000000000000000 PWR_FlashPowerDownCmd
     /tmp/ccNgkk2X.s:683    .text.PWR_FlashPowerDownCmd:000000000000001c $d
     /tmp/ccNgkk2X.s:688    .text.PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/ccNgkk2X.s:694    .text.PWR_EnterSTOPMode:0000000000000000 PWR_EnterSTOPMode
     /tmp/ccNgkk2X.s:795    .text.PWR_EnterSTOPMode:0000000000000064 $d
     /tmp/ccNgkk2X.s:801    .text.PWR_EnterUnderDriveSTOPMode:0000000000000000 $t
     /tmp/ccNgkk2X.s:807    .text.PWR_EnterUnderDriveSTOPMode:0000000000000000 PWR_EnterUnderDriveSTOPMode
     /tmp/ccNgkk2X.s:907    .text.PWR_EnterUnderDriveSTOPMode:0000000000000064 $d
     /tmp/ccNgkk2X.s:913    .text.PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/ccNgkk2X.s:919    .text.PWR_EnterSTANDBYMode:0000000000000000 PWR_EnterSTANDBYMode
     /tmp/ccNgkk2X.s:970    .text.PWR_EnterSTANDBYMode:000000000000002c $d
     /tmp/ccNgkk2X.s:976    .text.PWR_GetFlagStatus:0000000000000000 $t
     /tmp/ccNgkk2X.s:982    .text.PWR_GetFlagStatus:0000000000000000 PWR_GetFlagStatus
     /tmp/ccNgkk2X.s:1034   .text.PWR_GetFlagStatus:0000000000000030 $d
     /tmp/ccNgkk2X.s:1039   .text.PWR_ClearFlag:0000000000000000 $t
     /tmp/ccNgkk2X.s:1045   .text.PWR_ClearFlag:0000000000000000 PWR_ClearFlag
     /tmp/ccNgkk2X.s:1085   .text.PWR_ClearFlag:0000000000000024 $d

UNDEFINED SYMBOLS
ARM GAS  /tmp/ccNgkk2X.s 			page 47


RCC_APB1PeriphResetCmd
